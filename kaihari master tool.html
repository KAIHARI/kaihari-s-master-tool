<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>kaihari's master tool</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- PDF Generation Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script type="module">
        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js?module";
        import { getAuth, signInAnonymously, onAuthStateChanged, connectAuthEmulator } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js?module";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, addDoc, getDocs, writeBatch } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js?module";

        // --- GLOBAL STATE & CONFIG ---
        const firebaseConfig = {
  apiKey: "AIzaSyDstcgMAdJhXoaZpZsTQbWAcxs6jPRTPBM",
  authDomain: "kaihari-s-master-tool.firebaseapp.com",
  projectId: "kaihari-s-master-tool",
  storageBucket: "kaihari-s-master-tool.firebasestorage.app",
  messagingSenderId: "384258679853",
  appId: "1:384258679853:web:ca207148abc8ee912a84a4",
  measurementId: "G-QMKPHQGY41"
};
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'ygo-evaluator-default';
        
        let app, auth, db, userId;
        let cardDatabase = [];
        let originalCardDatabase = []; // Backup of full database for deck-specific filtering
        let easterEggCardPool = []; // Custom card pool for easter egg animation
        let chibiAnimationState = { hopInterval: null, physicsInterval: null, isPaused: false }; // Global animation state
        let deckLists = [];
        let offlineDecks = [];
        let currentDeck = { main: [], side: [], extra: [], sidingPatterns: {} };
        let currentDeckId = null; // Track the currently loaded/saved deck document ID (online or offline)
        let currentDeckSource = 'unsaved'; // 'online' | 'offline' | 'ydk' | 'unsaved'
        let currentDeckMeta = { name: null, sync: null }; // Additional metadata about the loaded deck
        let isDeckDirty = false;
        const createOfflineDeckId = () => (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function'
            ? crypto.randomUUID()
            : `deck-${Date.now()}-${Math.random().toString(36).slice(2, 10)}`);
        const encodeDeckSelectorValue = (source, id) => `${source}:${id}`;
        const decodeDeckSelectorValue = (value) => {
            if (!value) return { source: null, id: null };
            const [source, ...rest] = value.split(':');
            if (rest.length === 0) {
                return { source: 'online', id: source };
            }
            return { source, id: rest.join(':') };
        };
        const confirmDiscardDeckChanges = () => {
            if (!isDeckDirty) return true;
            if (typeof window !== 'undefined') {
                return window.confirm('You have unsaved changes in the deck builder. Discard them?');
            }
            return true;
        };
        const markDeckDirty = () => {
            isDeckDirty = true;
        };
        const BUILDER_DECK_VALUE = encodeDeckSelectorValue('offline', 'builder');
        let ydkFileHandles = new Map();
        const sanitizeFileBaseName = (name) => {
            if (!name) return 'deck';
            const trimmed = name.trim().replace(/\s+/g, ' ');
            const sanitized = trimmed.replace(/[^a-zA-Z0-9\- _()]+/g, '').trim();
            return sanitized || 'deck';
        };
        const generateUniqueYDKFileName = (baseName, format = 'ydk') => {
            const extension = format === 'ydkx' ? '.ydkx' : '.ydk';
            const base = sanitizeFileBaseName(baseName);
            const existingNames = new Set(ydkFiles.map(f => f.name));
            ydkFileHandles.forEach((_, key) => existingNames.add(key));
            let candidate = `${base}${extension}`;
            let counter = 1;
            while (existingNames.has(candidate)) {
                candidate = `${base} (${counter})${extension}`;
                counter++;
            }
            return candidate;
        };
        let simulationState = {};
        let lastSimulationSettings = {};
        let confirmCallback = null;
        let sidingState = { out: [], in: [] };
        let draggingElement = null;
        let isOffline = true; // NEW: Global flag for offline mode - start in offline mode by default
        let isFirebaseReady = false; // NEW: Flag to ensure Firebase is fully initialized
        let placeholder = null;
        let geminiApiKey = null; // Store API key in memory for the session
        let aiEvaluator = null;
        let autocompleteSelectedIndex = -1; // For tracking selected autocomplete suggestion
        let autocompleteMode = 'db'; // 'db' or 'all' - controls whether to filter DB only or all cards
        let allCardsCache = []; // Cache for all cards fetched from API
        let lastAutocompleteMatches = []; // Store last autocomplete matches for space key shortcut
        let editMode = false; // Controls whether delete buttons are shown
        let extraDeckVisible = true; // Controls whether extra deck section is visible
        let sideDeckVisible = true; // Controls whether side deck section is visible
        let databaseVisible = true; // Controls whether card database section is visible
        let cardDatabaseView = 'grid'; // 'list' or 'grid' - controls card database view mode
        let currentDeckFormat = 'ydk'; // 'ydk' or 'ydkx' - current deck file format
        let selectedGridCards = new Set(); // Track selected cards in grid view for bulk operations
        
        // --- IMMERSION MODE STATE ---
        let immersionMode = {
            active: false,
            mousePos: { x: window.innerWidth / 2, y: window.innerHeight / 2 },
            cards: [], // Array of card elements for efficient updates
            overlay: null,
            animationFrame: null,
            exitHitbox: null,
            scale: 1.1, // Default scale (10% larger than homepage)
            scaleSlider: null,
            sections: [], // Array of section elements for plane management
            activeSection: null, // Currently active section (cursor over)
            planes: {
                back: [], // z-index: 1, translateZ: -100px
                middle: [], // z-index: 2, translateZ: -50px
                front: [] // z-index: 3, translateZ: 0px
            }
        };
        
        // --- ADVANCED CARD SEARCH STATE ---
        let advancedSearchState = {
            filters: {
                text: '',
                cardType: null, // 'monster', 'spell', 'trap'
                cardSubtype: null,
                monsterType: [],
                monsterSubtype: [],
                attribute: [],
                levelMin: 0,
                levelMax: 12,
                atkMin: null,
                atkMax: null,
                defMin: null,
                defMax: null,
                banlistStatus: [],
            },
            sort: { by: 'name', order: 'asc' }, // by: 'name' | 'releaseDate', order: 'asc' | 'desc'
            view: 'grid', // 'grid' | 'list'
            pagination: { page: 1, perPage: 50 },
            results: [],
            allCards: [],
            cardInfo: {
                visible: true,
                currentCard: null
            },
            selection: {
                active: false,
                selectedIndex: -1,
                selectedCardId: null
            }
        };
        let customBanlist = {}; // { cardId: 'forbidden' | 'limited' | 'semi-limited' | 'unlimited' }
        
        // --- YDK FOLDER MANAGEMENT ---
        let ydkFolder = null; // FileSystemDirectoryHandle for YDK folder (optional, for sync)
        let ydkFiles = []; // Array of YDK files with {name, displayName, content, lastModified}
        let defaultDeckName = null; // Name of the default deck
        let ydkFolderPath = null; // Path to the YDK folder (for sync)
        
        // --- SELECTION MODE STATE ---
        let selectionMode = {
            active: false,
            currentDeck: 'main', // 'main', 'side', or 'extra'
            selectedIndices: [], // Array of selected card indices
            anchorIndex: null, // Starting point for shift selections (fixed point)
            focusIndex: null, // End point for shift selections (moves with shift+arrow)
            selectionMode: 'none', // 'none', 'horizontal', or 'vertical'
            columnIndices: [], // For vertical mode: track which columns are selected
            focusMode: false // Focus mode: enlarge and center selected cards
        };

        // --- SCALE TARGET STATE ---
        let scaleTarget = 'main'; // 'main', 'side', or 'extra'
        
        // --- AUTO-ADJUST CONTROL ---
        let allowAutoAdjust = false; // Prevent auto-adjust during page load

        // --- UI ELEMENT REFERENCES ---
        let UI = {
            // Main views
            deckBuilderView: null, simulationView: null, reportView: null, aiTrainingView: null,
            shootoutView: null, shootoutSidingView: null, shootoutSimulatorView: null, shootoutReportView: null,

            // Navigation
            navDeckBuilder: null, navSimulator: null, navAiTraining: null, navShootout: null, navOnlineMode: null, headerTitle: null, fullscreenBtn: null,

            // Card Database
            cardSearchInput: null, addCardBtn: null, cardDbList: null, cardAutocompleteList: null, autocompleteModeToggle: null, editDbToggle: null, viewToggleBtn: null, resetDbBtn: null,
            gridSelectionControls: null, selectAllGridBtn: null, clearSelectionGridBtn: null, deleteSelectedGridBtn: null, selectedCount: null,
            cardDatabaseSection: null, resizeHandle: null, deckBuilderSection: null, deckBuilderContainer: null,
            advancedSearchBtn: null,
            
            // Advanced Search Modal
            advancedSearchModal: null, advancedSearchModalClose: null, advSearchTextInput: null,
            advSearchCardType: null, advSearchCardSubtype: null, advSearchMonsterType: null,
            advSearchAttributeContainer: null, advSearchMonsterSubtypeContainer: null,
            advSearchLevelMin: null, advSearchLevelMax: null, advSearchLevelDisplay: null,
            advSearchAtkMin: null, advSearchAtkMax: null, advSearchDefMin: null, advSearchDefMax: null,
            advSearchBanlistContainer: null, advSearchSortBy: null, advSearchSortOrder: null,
            advSearchApplyBtn: null, advSearchResetBtn: null, advSearchManageBanlistBtn: null,
            advSearchResultsContainer: null, advSearchResultsCount: null, advSearchViewToggle: null,
            advSearchPaginationContainer: null, advSearchPerPageSlider: null, advSearchPerPageDisplay: null,
            advSearchPrevPage: null, advSearchNextPage: null, advSearchPageDisplay: null,
            advSearchCardInfoPanel: null, advSearchCardInfoToggle: null, advSearchCardInfoContent: null,
            
            // Banlist Management Modal
            banlistModal: null, banlistModalClose: null, banlistSearchInput: null, banlistSearchResults: null,
            banlistSaveBtn: null, banlistResetBtn: null,

            // Deck Builder
            mainDeckList: null, sideDeckList: null, extraDeckList: null, deckNameInput: null, saveDeckBtn: null,
            deckSelector: null, loadDeckBtn: null, deleteDeckBtn: null, exportDeckBtn: null, exportDeckYDKXBtn: null,
            exportDeckClipboardBtn: null, importDeckClipboardBtn: null, importDeckInput: null, deckCountDisplay: null, deckTypeCountsDisplay: null,
            deckScaleSlider: null, scaleTargetBtn: null, cardsPerRowDisplay: null, manageSidingBtn: null, toggleExtraDeckBtn: null, extraDeckSection: null, deckGridContainer: null,
            deckOptionsBtn: null, deckOptionsDropdown: null, resetToDefaultSizesBtn: null,
            toggleSideDeckBtn: null, toggleDatabaseBtn: null, sideDeckSection: null, mainDeckSection: null,
            mainSideResizeHandle: null, sideExtraResizeHandle: null,
            
            // YDK Folder Management
            ydkFolderBtn: null, ydkFolderStatus: null, ydkDeckSelector: null, setDefaultDeckBtn: null, quickReselectBtn: null,
            ydkFileInput: null, syncFolderBtn: null, manageFilesBtn: null,
            ydkManagementModal: null, ydkManagementModalClose: null, ydkFilesList: null, clearAllYDKFilesBtn: null, syncYDKFolderBtn: null,
            
            // Easter Egg Modal
            easterEggModal: null, easterEggModalClose: null, easterEggSearchInput: null, addEasterEggCardBtn: null, easterEggSearchResults: null,
            easterEggPoolList: null, easterEggCount: null, addCommonTrapsBtn: null, addStapleTrapsBtn: null, addModernTrapsBtn: null,
            clearEasterEggPoolBtn: null, saveEasterEggPoolBtn: null, resetEasterEggPoolBtn: null, cancelEasterEggModalBtn: null,

            // Simulation Setup
            simDeckSelector: null, simTargetCardSelector: null, simCompareCardSelector: null,
            simReplacementCount: null, simTrialsInput: null, simPostSideModeToggle: null,
            postSideOptions: null, simSidingPatternSelector: null, simModeSelector: null,
            standardSimOptions: null, startSimBtn: null,

            // Simulation Display
            simulationSetup: null, simulationDisplay: null, handAContainer: null, handBContainer: null,
            nextCardsA: null, nextCardsB: null, fullDeckA: null, fullDeckB: null,
            trialCounter: null, toggleNotesBtn: null, notesSection: null, trialNotes: null,
            deleteDraft: null,

            // Report
            reportContent: null, exportReportBtn: null, aiReportAnalysisBtn: null,
            aiReportAnalysisContent: null, rerunSection: null, rerunTrialsInput: null,
            rerunSimBtn: null, generateAiEvaluatorBtn: null,

            // AI Training Mode
            importAiEvaluatorInput: null, aiTrainingTrialsInput: null, aiTrainingInstructions: null,
            startAiTrainingBtn: null, aiTrainingResultsView: null, aiTrainingDeckSelector: null,

            // Shootout Mode
            shootoutUserDeckSelector: null, shootoutOpponentDeckInput: null, shootoutOpponentDeckName: null,
            shootoutTrialsInput: null, startShootoutBtn: null, shootoutSidingViewTitle: null,
            shootoutSidingUserMain: null, shootoutSidingUserSide: null, shootoutSidingOpponentMain: null,
            shootoutSidingOpponentSide: null, shootoutSidingUserInfo: null, shootoutSidingOpponentInfo: null,
            shootoutFinalizeSidingBtn: null, shootoutSimUserHand: null, shootoutSimOpponentHand: null, // MODIFIED
            shootoutSimUserDeckCount: null, shootoutSimScenarioIndicator: null, shootoutSimOpponentDeckCount: null,
            shootoutSimUserControls: null, shootoutJdgUserWinBtn: null, shootoutJdgTieBtn: null, shootoutJdgOpponentWinBtn: null,
            shootoutNotes: null, shootoutReportAnalyzeBtn: null, shootoutReportContinueBtn: null, // MODIFIED
            shootoutReportExportBtn: null, shootoutReportContent: null, drawShootoutCardBtn: null, // MODIFIED
            searchDeckBtn: null, shootoutReportAiBtn: null, shootoutGeneratePromptBtn: null, confirmContinueBtn: null, reportPreviewModal: null,

            // Modals & Overlays
            loadingOverlay: null, messageModal: null, messageModalText: null, messageModalClose: null,
            confirmModal: null, confirmModalText: null, confirmModalCancel: null, confirmModalConfirm: null,
            searchResultsModal: null, searchResultsList: null, searchResultsClose: null,
            sidingPatternModal: null, sidingPatternModalClose: null, sidingPatternMainDeck: null,
            sidingPatternSideDeck: null, sidingPatternNameInput: null, saveSidingPatternBtn: null,
            sidingPatternList: null, sidingSelectedCount: null, exportSidingPatternsBtn: null,
            importSidingPatternsInput: null, searchDeckModal: null, searchDeckModalClose: null,
            searchDeckModalList: null, apiKeyModal: null, apiKeyModalClose: null, apiKeyInput: null,
            saveApiKeyBtn: null, promptModal: null, promptModalClose: null, promptModalTextarea: null,
            copyPromptBtn: null, downloadPromptBtn: null, generatePromptBtn: null, generateAiEvaluatorPromptBtn: null,
        };

        // --- INITIALIZATION ---
        document.addEventListener('DOMContentLoaded', main);

        function initializeUI() {
            const uiKeys = Object.keys(UI); // This function finds all the elements by their ID.
            for (const key of uiKeys) {
                UI[key] = document.getElementById(key);
            }
        }

        function initializeFirebase() {
            return new Promise((resolve) => {
                try {
                    app = initializeApp(firebaseConfig);
                    auth = getAuth(app);
                    db = getFirestore(app);

                    onAuthStateChanged(auth, (user) => {
                        if (user) {
                            userId = user.uid;
                            isOffline = false;
                            isFirebaseReady = true;
                            console.log("Firebase online, user:", userId);
                            document.querySelectorAll('.online-feature').forEach(el => el.style.display = 'block');
                            loadInitialData().then(resolve);
                        } else {
                            signInAnonymously(auth).catch(err => {
                                console.error("Anonymous sign-in failed:", err);
                                isOffline = true;
                                isFirebaseReady = true; // Still ready, but in offline state
                                document.querySelectorAll('.online-feature').forEach(el => el.style.display = 'none');
                                showMessage("Offline Mode: Could not sign in. Deck saving is disabled.");
                                resolve();
                            });
                        }
                    });
                } catch (error) {
                    console.error("Firebase initialization failed, entering offline mode:", error);
                    isOffline = true;
                    isFirebaseReady = true; // Ready for offline operation
                    document.querySelectorAll('.online-feature').forEach(el => el.style.display = 'none');
                    showMessage("Could not connect to the database. Running in Offline Mode.");
                    resolve(); // Resolve the promise to allow the app to continue in offline mode
                }
            });
        }

        async function main() {
            // 1. Show loading screen immediately
            const loadingOverlay = document.getElementById('loadingOverlay');
            if (loadingOverlay) loadingOverlay.classList.remove('hidden');

            // 2. Find all UI elements and set up the theme.
            initializeUI();
            initializeTheme();
            initializeChibiAnimation(); // Add the easter egg
            loadEasterEggCardPool(); // Initialize easter egg card pool

            // 3. Now that the UI is ready, attach all event listeners.
            attachEventListeners();
            
            // 4. Initialize the resize handle for the deck builder
            initializeResizeHandle();
            
            // 5. Initialize the deck resize handles
            initializeDeckResizeHandles();

            // 4. Start in offline mode by default - skip Firebase initialization
            isFirebaseReady = true;
            document.querySelectorAll('.online-feature').forEach(el => el.style.display = 'none');
            
            // 4.5. Run one-time cleanup to fix any existing issues
            performOneTimeCleanup();
            
            // 5. Load any locally stored data that doesn't depend on Firebase.
            loadLocalData();

            // 6. Show the default view and hide the loading screen.
            showView('deckBuilderView');
            UI.loadingOverlay.classList.add('hidden');
            
            // 6.5. Load card database in offline mode
            loadCardDatabase();
            
            // 7. Load YDK files from IndexedDB and auto-load if available
            // Wait for database to be fully loaded before auto-loading decks
            setTimeout(async () => {
                // Wait for card database to be ready
                while (!isDatabaseLoaded) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                console.log('[DEBUG] Card database loaded, proceeding with YDK auto-load');
                
                await migrateOfflineStorage();
                await loadOfflineDecks();
                
                // Load stored YDK files from IndexedDB
                await loadYDKFilesFromDB();
                
                // Auto-load if files are available
                if (ydkFiles.length > 0) {
                    await autoLoadYDKOnStartup();
                } else {
                    // Show import prompt if no files stored
                    await tryAccessDefaultYDKFolder();
                }
            }, 100);
        }

        function performOneTimeCleanup() {
            // Check if cleanup has already been performed for this version
            const cleanupVersion = localStorage.getItem('cleanupVersion');
            const currentVersion = '9.1'; // Increment this when you need to run cleanup again
            
            if (cleanupVersion === currentVersion) {
                // Cleanup already performed for this version
                console.log(`Cleanup already performed for version ${currentVersion}`);
                return;
            }
            
            console.log(`Running one-time cleanup v${currentVersion}...`);
            
            // Clean up duplicate cards in localStorage
            try {
                const savedCards = JSON.parse(localStorage.getItem('offlineCardDatabase') || '[]');
                console.log(`Cleanup: Found ${savedCards.length} total cards in localStorage`);
                
                if (savedCards.length > 0) {
                    // Deduplicate by ID
                    const uniqueCards = [];
                    const seenIds = new Set();
                    let duplicateCount = 0;
                    
                    for (const card of savedCards) {
                        if (!seenIds.has(card.id)) {
                            seenIds.add(card.id);
                            uniqueCards.push(card);
                        } else {
                            duplicateCount++;
                            console.log(`Cleanup: Removing duplicate of '${card.name}' (ID: ${card.id})`);
                        }
                    }
                    
                    console.log(`Cleanup: Removed ${duplicateCount} duplicate cards`);
                    console.log(`Cleanup: Saving ${uniqueCards.length} unique cards`);
                    localStorage.setItem('offlineCardDatabase', JSON.stringify(uniqueCards));
                }
            } catch (e) {
                console.error("Error during card database cleanup:", e);
            }
            
            // Clear deck resize configuration to ensure fresh layout on startup
            try {
                const deckResizeConfig = localStorage.getItem('deckResizeConfig');
                if (deckResizeConfig) {
                    console.log('Cleanup: Found deck resize config:', deckResizeConfig);
                    console.log('Cleanup: Clearing deck resize configuration for fresh layout');
                    localStorage.removeItem('deckResizeConfig');
                } else {
                    console.log('Cleanup: No deck resize config found');
                }
                
                // Also clear deckBuilderConfig if it exists
                const deckBuilderConfig = localStorage.getItem('deckBuilderConfig');
                if (deckBuilderConfig) {
                    console.log('Cleanup: Found deck builder config:', deckBuilderConfig);
                    console.log('Cleanup: Clearing deck builder configuration');
                    localStorage.removeItem('deckBuilderConfig');
                }
                
                // Always clear any bad saved deck resize config
                localStorage.removeItem('deckResizeConfig');
            } catch (e) {
                console.error("Error during deck resize config cleanup:", e);
            }
            
            // Mark cleanup as complete for this version
            localStorage.setItem('cleanupVersion', currentVersion);
            console.log('One-time cleanup complete');
        }
        
        // Global function to manually trigger cleanup (can be called from browser console)
        window.forceCleanup = function() {
            console.log('===== FORCING CLEANUP =====');
            localStorage.removeItem('cleanupVersion'); // Remove version flag
            performOneTimeCleanup(); // Run cleanup
            console.log('===== CLEANUP COMPLETE - Please refresh the page =====');
        };
        
        // Global function to show diagnostic info
        window.showDiagnostics = function() {
            console.log('===== DIAGNOSTICS =====');
            const savedCards = JSON.parse(localStorage.getItem('offlineCardDatabase') || '[]');
            console.log(`Cards in localStorage: ${savedCards.length}`);
            console.log(`Cards in memory: ${cardDatabase.length}`);
            console.log(`Cleanup version: ${localStorage.getItem('cleanupVersion')}`);
            console.log(`Deck resize config: ${localStorage.getItem('deckResizeConfig')}`);
            console.log(`Deck builder config: ${localStorage.getItem('deckBuilderConfig')}`);
            
            // Count duplicates
            const seenIds = new Set();
            let dupCount = 0;
            savedCards.forEach(card => {
                if (seenIds.has(card.id)) {
                    dupCount++;
                } else {
                    seenIds.add(card.id);
                }
            });
            console.log(`Duplicate cards in localStorage: ${dupCount}`);
            
            // Layout diagnostics
            console.log('\n----- LAYOUT DIAGNOSTICS -----');
            if (UI.deckBuilderContainer) {
                console.log(`Deck Builder Container (parent of all deck sections):`);
                console.log(`  style.width: "${UI.deckBuilderContainer.style.width}"`);
                console.log(`  style.display: "${UI.deckBuilderContainer.style.display}"`);
                console.log(`  computed width: ${UI.deckBuilderContainer.offsetWidth}px`);
            }
            if (UI.deckBuilderSection) {
                console.log(`Deck Builder Section (contains deckGridContainer):`);
                console.log(`  style.width: "${UI.deckBuilderSection.style.width}"`);
                console.log(`  style.flexGrow: "${UI.deckBuilderSection.style.flexGrow}"`);
                console.log(`  computed width: ${UI.deckBuilderSection.offsetWidth}px`);
            }
            if (UI.cardDatabaseSection) {
                console.log(`Card Database Section:`);
                console.log(`  style.width: "${UI.cardDatabaseSection.style.width}"`);
                console.log(`  computed width: ${UI.cardDatabaseSection.offsetWidth}px`);
            }
            if (UI.deckGridContainer) {
                console.log(`Deck Grid Container (flex container for main/side/extra):`);
                console.log(`  style.width: "${UI.deckGridContainer.style.width}"`);
                console.log(`  computed width: ${UI.deckGridContainer.offsetWidth}px`);
            }
            if (UI.mainDeckSection) {
                console.log(`Main Deck Section:`);
                console.log(`  style.width: "${UI.mainDeckSection.style.width}"`);
                console.log(`  style.minWidth: "${UI.mainDeckSection.style.minWidth}"`);
                console.log(`  style.flexGrow: "${UI.mainDeckSection.style.flexGrow}"`);
                console.log(`  style.flexShrink: "${UI.mainDeckSection.style.flexShrink}"`);
                console.log(`  computed width: ${UI.mainDeckSection.offsetWidth}px`);
            }
            if (UI.sideDeckSection) {
                console.log(`Side Deck Section:`);
                console.log(`  style.width: "${UI.sideDeckSection.style.width}"`);
                console.log(`  style.minWidth: "${UI.sideDeckSection.style.minWidth}"`);
                console.log(`  style.flexGrow: "${UI.sideDeckSection.style.flexGrow}"`);
                console.log(`  style.flexShrink: "${UI.sideDeckSection.style.flexShrink}"`);
                console.log(`  computed width: ${UI.sideDeckSection.offsetWidth}px`);
            }
            if (UI.extraDeckSection) {
                console.log(`Extra Deck Section:`);
                console.log(`  style.width: "${UI.extraDeckSection.style.width}"`);
                console.log(`  style.minWidth: "${UI.extraDeckSection.style.minWidth}"`);
                console.log(`  style.flexGrow: "${UI.extraDeckSection.style.flexGrow}"`);
                console.log(`  style.flexShrink: "${UI.extraDeckSection.style.flexShrink}"`);
                console.log(`  computed width: ${UI.extraDeckSection.offsetWidth}px`);
            }
            console.log('===== END DIAGNOSTICS =====');
        };

        // Global function to reset new user state for testing
        window.resetNewUserState = function() {
            console.log('===== RESETTING NEW USER STATE =====');
            localStorage.removeItem('hasSeenWelcome');
            localStorage.removeItem('ydkFolderPath');
            localStorage.removeItem('offlineDecksIntroduced');
            console.log('New user state reset. Refresh the page to see the startup modal.');
        };

        // Global function to manually show the new user modal for testing
        window.showNewUserModal = function() {
            console.log('===== MANUALLY SHOWING NEW USER MODAL =====');
            showNewUserStartupModal();
        };

        async function loadInitialData() {
            if (!userId) return;
            // These now run concurrently without blocking the UI.
            loadCardDatabase();
            loadUserDecks();
        }
        
        function cleanupBadConfigs() {
            // Check and clean up bad deckBuilderConfig
            try {
                const deckBuilderConfig = localStorage.getItem('deckBuilderConfig');
                if (deckBuilderConfig) {
                    const config = JSON.parse(deckBuilderConfig);
                    // If config has 100% width and we're on a wide screen, clear it
                    const isNarrowScreen = UI.deckBuilderContainer && UI.deckBuilderContainer.offsetWidth < 1024;
                    if (!isNarrowScreen && config.cardDatabaseWidth === '100%') {
                        console.log('Cleaning up bad deckBuilderConfig (100% width on wide screen)');
                        localStorage.removeItem('deckBuilderConfig');
                    }
                }
            } catch (e) {
                console.error('Error cleaning deckBuilderConfig:', e);
            }
        }

        function loadLocalData() {
            // Load individual deck scales (pixel sizes)
            const mainScale = localStorage.getItem('mainDeckScale') || '68';
            const sideScale = localStorage.getItem('sideDeckScale') || '68';
            const extraScale = localStorage.getItem('extraDeckScale') || '68';
            const dbScale = localStorage.getItem('dbDeckScale') || '80';
            
            document.documentElement.style.setProperty('--main-deck-size', `${mainScale}px`);
            document.documentElement.style.setProperty('--side-deck-size', `${sideScale}px`);
            document.documentElement.style.setProperty('--extra-deck-size', `${extraScale}px`);
            document.documentElement.style.setProperty('--db-card-size', `${dbScale}px`);
            
            // Initialize cards per row if not already set
            if (!localStorage.getItem('mainDeckCardsPerRow')) {
                localStorage.setItem('mainDeckCardsPerRow', '8');
            }
            if (!localStorage.getItem('sideDeckCardsPerRow')) {
                localStorage.setItem('sideDeckCardsPerRow', '3');
            }
            if (!localStorage.getItem('extraDeckCardsPerRow')) {
                localStorage.setItem('extraDeckCardsPerRow', '3');
            }
            if (!localStorage.getItem('dbDeckCardsPerRow')) {
                localStorage.setItem('dbDeckCardsPerRow', '4');
            }
            
            // Load the saved panel configuration
            loadPanelConfiguration();
            
            // SAFETY FIX #1: Ensure card database section doesn't take 100% width on narrow screens
            // This must happen AFTER loadPanelConfiguration() to override any bad saved config
            if (UI.cardDatabaseSection && UI.cardDatabaseSection.style.width === '100%') {
                console.log('SAFETY FIX: Card database was set to 100% width, resetting to 33.333%');
                UI.cardDatabaseSection.style.width = '33.333%';
                UI.cardDatabaseSection.style.height = '';
            }
            
            // Load the extra deck visibility state
            loadExtraDeckVisibility();
            
            // Load the side deck visibility state
            loadSideDeckVisibility();
            
            // Load the database visibility state
            loadDatabaseVisibility();
            
            // Load the card database view preference
            loadCardDatabaseView();
            
            // SAFETY FIX #2: Remove database-visible class if card database is not 100% width
            // This prevents the deck sections from being squished unnecessarily
            if (UI.deckBuilderContainer && UI.cardDatabaseSection) {
                if (UI.cardDatabaseSection.style.width !== '100%' && UI.deckBuilderContainer.classList.contains('database-visible')) {
                    console.log('SAFETY FIX: Removing database-visible class since database is not full width');
                    UI.deckBuilderContainer.classList.remove('database-visible');
                }
            }
            
            // Load deck resize configuration
            loadDeckResizeConfiguration();
            
            // Load YDK folder configuration
            loadDefaultYDKDeck();
            
            // Final cleanup: ensure no bad configs persisted
            cleanupBadConfigs();
            
            // AUTO-FIT: Adjust deck section sizes to fit everything on screen
            // Wait a moment for DOM to be ready
            setTimeout(() => {
                autoFitDeckSections();
                
                // Initialize slider and display to show cards per row for current target
                const currentCardsPerRow = getCurrentCardsPerRow(scaleTarget);
                UI.deckScaleSlider.value = currentCardsPerRow;
                if (UI.cardsPerRowDisplay) {
                    UI.cardsPerRowDisplay.textContent = currentCardsPerRow;
                }
                
                // Enable auto-adjust after initial page load is complete
                setTimeout(() => {
                    allowAutoAdjust = true;
                    console.log('[AUTO-ADJUST] Now enabled after page load');
                }, 500);
            }, 100);
        }

        // --- DECK SCALE FUNCTIONS ---
        function cycleScaleTarget() {
            const targets = ['main', 'side', 'extra', 'db'];
            const currentIndex = targets.indexOf(scaleTarget);
            scaleTarget = targets[(currentIndex + 1) % targets.length];
            
            UI.scaleTargetBtn.textContent = scaleTarget.charAt(0).toUpperCase() + scaleTarget.slice(1);
            
            // Update slider to show current cards per row for the selected target
            const currentCardsPerRow = getCurrentCardsPerRow(scaleTarget);
            UI.deckScaleSlider.value = currentCardsPerRow;
            
            // Update display
            if (UI.cardsPerRowDisplay) {
                UI.cardsPerRowDisplay.textContent = currentCardsPerRow;
            }
        }
        
        function getCurrentCardsPerRow(target) {
            // Get saved cards per row, or calculate from current scale
            const saved = localStorage.getItem(`${target}DeckCardsPerRow`);
            if (saved) {
                return parseInt(saved);
            }
            
            // Calculate from current card scale and section width
            const section = target === 'main' ? UI.mainDeckSection : 
                          target === 'side' ? UI.sideDeckSection : 
                          target === 'extra' ? UI.extraDeckSection :
                          target === 'db' ? UI.cardDatabaseSection : null;
            if (!section) return 8; // default
            
            const currentScale = getCurrentDeckScale(target);
            const sectionWidth = section.offsetWidth;
            const padding = 24;
            const gap = 4;
            const availableWidth = sectionWidth - padding;
            
            return Math.max(1, Math.floor(availableWidth / (currentScale + gap)));
        }
        
        function updateCardsPerRow(target, cardsPerRow) {
            // Convert cards per row to card size and update
            const section = target === 'main' ? UI.mainDeckSection : 
                          target === 'side' ? UI.sideDeckSection : 
                          target === 'extra' ? UI.extraDeckSection :
                          target === 'db' ? UI.cardDatabaseSection : null;
            if (!section) return;
            
            const sectionWidth = section.offsetWidth;
            const padding = 24;
            const gap = 4;
            const availableWidth = sectionWidth - padding;
            
            // Calculate card size to fit exactly this many cards per row
            const cardSize = Math.max(46, Math.min(150, (availableWidth / cardsPerRow) - gap));
            const roundedSize = Math.round(cardSize);
            
            // Update CSS variable and localStorage
            const cssVar = target === 'db' ? '--db-card-size' : `--${target}-deck-size`;
            document.documentElement.style.setProperty(cssVar, `${roundedSize}px`);
            localStorage.setItem(`${target}DeckScale`, roundedSize);
            localStorage.setItem(`${target}DeckCardsPerRow`, cardsPerRow);
            
            // Update display
            if (UI.cardsPerRowDisplay) {
                UI.cardsPerRowDisplay.textContent = cardsPerRow;
            }
            
            console.log(`Updated ${target} deck: ${cardsPerRow} cards/row = ${roundedSize}px per card`);
        }

        function updateDeckScale(target, size) {
            const cssVar = `--${target}-deck-size`;
            document.documentElement.style.setProperty(cssVar, `${size}px`);
            localStorage.setItem(`${target}DeckScale`, size);
            
            // AUTO-FIT: Adjust deck section sizes to fit everything on screen
            // (Instead of updateDeckSectionWidths which applies compact sizes)
            autoFitDeckSections();
        }
        
        function updateDeckSectionWidths() {
            // Calculate appropriate widths based on card sizes and available space
            const mainScale = getCurrentDeckScale('main');
            const sideScale = getCurrentDeckScale('side');
            const extraScale = getCurrentDeckScale('extra');
            
            // Base width calculation: card size + padding + some buffer
            const basePadding = 24; // 12px padding on each side
            const buffer = 20; // Extra space for comfortable viewing
            
            let mainWidth = Math.max(200, mainScale * 2 + basePadding + buffer);
            let sideWidth = Math.max(120, sideScale * 2 + basePadding + buffer);
            let extraWidth = Math.max(120, extraScale * 2 + basePadding + buffer);
            
            // If database is visible, make sections much more compact
            if (UI.deckBuilderContainer && UI.deckBuilderContainer.classList.contains('database-visible')) {
                // Much more aggressive sizing when database is visible
                sideWidth = Math.max(50, Math.min(80, sideScale + 20)); // Cap at 80px max
                extraWidth = Math.max(50, Math.min(80, extraScale + 20)); // Cap at 80px max
                mainWidth = Math.max(80, Math.min(120, mainScale + 20)); // Cap at 120px max
            }
            
            // Check available space and adjust if necessary to prevent overflow
            if (UI.deckGridContainer) {
                const containerWidth = UI.deckGridContainer.offsetWidth;
                const resizeHandleWidth = 16; // Approximate width of resize handles (2 * 8px)
                const gap = 32; // Gap between sections (4 * 8px)
                const availableWidth = containerWidth - resizeHandleWidth - gap;
                
                // Calculate total desired width
                let totalWidth = mainWidth + sideWidth + extraWidth;
                
                // If total exceeds available space, scale down proportionally
                if (totalWidth > availableWidth && availableWidth > 0) {
                    const scale = availableWidth / totalWidth * 0.95; // 95% to leave some breathing room
                    mainWidth = Math.max(150, Math.floor(mainWidth * scale));
                    sideWidth = Math.max(100, Math.floor(sideWidth * scale));
                    extraWidth = Math.max(100, Math.floor(extraWidth * scale));
                }
            }
            
            // Apply the calculated widths
            if (UI.mainDeckSection) {
                UI.mainDeckSection.style.minWidth = `${mainWidth}px`;
            }
            if (UI.sideDeckSection) {
                UI.sideDeckSection.style.width = `${sideWidth}px`;
                UI.sideDeckSection.style.minWidth = `${sideWidth}px`;
            }
            if (UI.extraDeckSection) {
                UI.extraDeckSection.style.width = `${extraWidth}px`;
                UI.extraDeckSection.style.minWidth = `${extraWidth}px`;
            }
        }

        function getCurrentDeckScale(target) {
            const cssVar = `--${target}-deck-size`;
            const computedStyle = getComputedStyle(document.documentElement);
            return parseInt(computedStyle.getPropertyValue(cssVar)) || 68;
        }

        // --- DECK OPTIONS DROPDOWN ---
        function toggleDeckOptionsDropdown() {
            if (UI.deckOptionsDropdown.classList.contains('hidden')) {
                UI.deckOptionsDropdown.classList.remove('hidden');
            } else {
                UI.deckOptionsDropdown.classList.add('hidden');
            }
        }

        function resetToDefaultSizes() {
            // Reset all deck cards-per-row to default values
            const defaultMainCardsPerRow = 8;
            const defaultSideCardsPerRow = 3;
            const defaultExtraCardsPerRow = 3;
            
            // Save cards per row settings
            localStorage.setItem('mainDeckCardsPerRow', defaultMainCardsPerRow);
            localStorage.setItem('sideDeckCardsPerRow', defaultSideCardsPerRow);
            localStorage.setItem('extraDeckCardsPerRow', defaultExtraCardsPerRow);
            
            // Calculate and apply card sizes based on current section widths
            const padding = 24;
            const gap = 4;
            
            if (UI.mainDeckSection) {
                const availableWidth = UI.mainDeckSection.offsetWidth - padding;
                const cardSize = Math.max(46, Math.min(150, (availableWidth / defaultMainCardsPerRow) - gap));
                document.documentElement.style.setProperty('--main-deck-size', `${Math.round(cardSize)}px`);
                localStorage.setItem('mainDeckScale', Math.round(cardSize));
            }
            
            if (UI.sideDeckSection) {
                const availableWidth = UI.sideDeckSection.offsetWidth - padding;
                const cardSize = Math.max(46, Math.min(150, (availableWidth / defaultSideCardsPerRow) - gap));
                document.documentElement.style.setProperty('--side-deck-size', `${Math.round(cardSize)}px`);
                localStorage.setItem('sideDeckScale', Math.round(cardSize));
            }
            
            if (UI.extraDeckSection) {
                const availableWidth = UI.extraDeckSection.offsetWidth - padding;
                const cardSize = Math.max(46, Math.min(150, (availableWidth / defaultExtraCardsPerRow) - gap));
                document.documentElement.style.setProperty('--extra-deck-size', `${Math.round(cardSize)}px`);
                localStorage.setItem('extraDeckScale', Math.round(cardSize));
            }
            
            // Update slider to show current cards per row for the selected target
            UI.deckScaleSlider.value = getCurrentCardsPerRow(scaleTarget);
            
            // Reset element visibility to default states
            resetElementVisibilityToDefault();
            
            // AUTO-FIT: Adjust deck section sizes to fit everything on screen
            setTimeout(() => autoFitDeckSections(), 100);
            
            // Force a layout recalculation to ensure proper positioning
            if (UI.deckGridContainer) {
                UI.deckGridContainer.style.display = 'none';
                UI.deckGridContainer.offsetHeight; // Trigger reflow
                UI.deckGridContainer.style.display = 'flex';
            }
            
            // Ensure extra deck is visible and properly positioned
            if (UI.extraDeckSection) {
                UI.extraDeckSection.style.display = '';
                UI.extraDeckSection.classList.remove('hidden');
                UI.extraDeckSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
            
            // Close dropdown
            UI.deckOptionsDropdown.classList.add('hidden');
            
            // Show confirmation message
            showMessage('All deck settings reset to default values');
        }
        
        function applyDefaultDeckLayout() {
            console.log('Applying default deck layout...');
            // Apply clean default layout
            if (UI.mainDeckSection) {
                UI.mainDeckSection.style.width = '';
                UI.mainDeckSection.style.minWidth = '300px';
                UI.mainDeckSection.style.flexGrow = '1';
                UI.mainDeckSection.style.flexShrink = '1';
                console.log('Main deck layout applied:', UI.mainDeckSection.style.cssText);
            }
            if (UI.sideDeckSection) {
                UI.sideDeckSection.style.width = '280px';
                UI.sideDeckSection.style.minWidth = '200px';
                UI.sideDeckSection.style.flexGrow = '0';
                UI.sideDeckSection.style.flexShrink = '1';
                console.log('Side deck layout applied:', UI.sideDeckSection.style.cssText);
            }
            if (UI.extraDeckSection) {
                UI.extraDeckSection.style.width = '280px';
                UI.extraDeckSection.style.minWidth = '200px';
                UI.extraDeckSection.style.flexGrow = '0';
                UI.extraDeckSection.style.flexShrink = '1';
                console.log('Extra deck layout applied:', UI.extraDeckSection.style.cssText);
            }
            console.log('Default deck layout applied successfully');
        }
        
        function resetElementVisibilityToDefault() {
            // Reset database visibility to default (visible)
            if (UI.cardDatabaseSection && UI.toggleDatabaseBtn) {
                databaseVisible = true;
                UI.cardDatabaseSection.style.display = '';
                UI.cardDatabaseSection.classList.remove('hidden');
                if (UI.resizeHandle) UI.resizeHandle.style.display = '';
                UI.toggleDatabaseBtn.textContent = 'Hide DB';
                UI.toggleDatabaseBtn.title = 'Hide Card Database';
                UI.toggleDatabaseBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
                UI.toggleDatabaseBtn.classList.add('bg-slate-700', 'hover:bg-slate-600');
                
                // Remove database-visible class from container
                if (UI.deckBuilderContainer) {
                    UI.deckBuilderContainer.classList.remove('database-visible');
                }
                
                // Save database visibility state
                localStorage.setItem('databaseVisible', JSON.stringify(databaseVisible));
            }
            
            // Reset side deck visibility to default (visible)
            if (UI.sideDeckSection && UI.toggleSideDeckBtn) {
                sideDeckVisible = true;
                UI.sideDeckSection.style.display = '';
                UI.sideDeckSection.classList.remove('hidden');
                if (UI.mainSideResizeHandle) UI.mainSideResizeHandle.style.display = '';
                UI.toggleSideDeckBtn.textContent = 'Hide Side';
                UI.toggleSideDeckBtn.title = 'Hide Side Deck';
                UI.toggleSideDeckBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
                UI.toggleSideDeckBtn.classList.add('bg-slate-700', 'hover:bg-slate-600');
                
                // Save side deck visibility state
                localStorage.setItem('sideDeckVisible', JSON.stringify(sideDeckVisible));
            }
            
            // Reset extra deck visibility to default (visible)
            if (UI.extraDeckSection && UI.toggleExtraDeckBtn) {
                extraDeckVisible = true;
                UI.extraDeckSection.style.display = '';
                UI.extraDeckSection.classList.remove('hidden');
                if (UI.sideExtraResizeHandle) UI.sideExtraResizeHandle.style.display = '';
                UI.toggleExtraDeckBtn.textContent = 'Hide Extra';
                UI.toggleExtraDeckBtn.title = 'Hide Extra Deck';
                UI.toggleExtraDeckBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
                UI.toggleExtraDeckBtn.classList.add('bg-slate-700', 'hover:bg-slate-600');
                
                // Save extra deck visibility state
                localStorage.setItem('extraDeckVisible', JSON.stringify(extraDeckVisible));
            }
            
            // Clear any saved resize configurations
            localStorage.removeItem('deckResizeConfig');
            localStorage.removeItem('deckBuilderConfig');
            
            // Reset deck builder section to be visible
            if (UI.deckBuilderSection) {
                UI.deckBuilderSection.style.display = '';
                UI.deckBuilderSection.style.width = '';
                UI.deckBuilderSection.style.height = '';
            }
            
            // Reset card database section
            if (UI.cardDatabaseSection) {
                UI.cardDatabaseSection.style.width = '33.333%';
                UI.cardDatabaseSection.style.height = '';
            }
            
            // Apply default deck layout
            applyDefaultDeckLayout();
        }

        // --- PANEL RESIZE FUNCTIONALITY ---
        function loadPanelConfiguration() {
            try {
                // Load from localStorage only (removed config.json fetch to avoid CORS errors)
                let config = JSON.parse(localStorage.getItem('deckBuilderConfig') || '{}');
                
                // Apply saved configuration if it exists
                if (config.cardDatabaseWidth) {
                    UI.cardDatabaseSection.style.width = config.cardDatabaseWidth;
                }
                if (config.cardDatabaseHeight) {
                    UI.cardDatabaseSection.style.height = config.cardDatabaseHeight;
                }
            } catch (e) {
                console.error('Error loading panel configuration:', e);
            }
        }

        function savePanelConfiguration() {
            try {
                // Don't save 100% width on wide screens - it causes layout issues
                const isNarrowScreen = UI.deckBuilderContainer && UI.deckBuilderContainer.offsetWidth < 1024;
                const width = UI.cardDatabaseSection.style.width;
                
                // If on wide screen and width is 100%, don't save (it's a bad config)
                if (!isNarrowScreen && width === '100%') {
                    console.log('Prevented saving 100% width database config on wide screen');
                    return;
                }
                
                const config = {
                    cardDatabaseWidth: UI.cardDatabaseSection.style.width,
                    cardDatabaseHeight: UI.cardDatabaseSection.style.height
                };
                localStorage.setItem('deckBuilderConfig', JSON.stringify(config));
            } catch (e) {
                console.error('Error saving panel configuration:', e);
            }
        }

        function initializeResizeHandle() {
            if (!UI.resizeHandle || !UI.cardDatabaseSection || !UI.deckBuilderSection) return;

            let isResizing = false;
            let startX = 0;
            let startY = 0;
            let startWidth = 0;
            let startHeight = 0;
            let isVertical = false;

            function checkOrientation() {
                const container = UI.deckBuilderContainer;
                return container.offsetWidth < 1024; // lg breakpoint
            }
            
            function calculateAndApplyScale(deckType, newWidth) {
                if (newWidth === 0 || newWidth < 100) {
                    return; // Skip if section is too small
                }
                
                // Get the saved cards-per-row setting for this deck
                const cardsPerRow = getCurrentCardsPerRow(deckType);
                const padding = 24;
                const gap = 4;
                const availableWidth = newWidth - padding;
                
                // Calculate card size to fit exactly this many cards per row
                const cardSize = Math.max(46, Math.min(150, (availableWidth / cardsPerRow) - gap));
                const roundedSize = Math.round(cardSize);
                
                // Apply the new card size
                const cssVar = deckType === 'db' ? '--db-card-size' : `--${deckType}-deck-size`;
                document.documentElement.style.setProperty(cssVar, `${roundedSize}px`);
                localStorage.setItem(`${deckType}DeckScale`, roundedSize);
                console.log(`[DB RESIZE] ${deckType}: ${cardsPerRow} cards/row  ${roundedSize}px per card (width: ${Math.round(newWidth)}px)`);
                
                // Update slider and display if this is the current target
                if (scaleTarget === deckType) {
                    UI.deckScaleSlider.value = cardsPerRow;
                    if (UI.cardsPerRowDisplay) {
                        UI.cardsPerRowDisplay.textContent = cardsPerRow;
                    }
                }
            }

            UI.resizeHandle.addEventListener('mousedown', (e) => {
                isResizing = true;
                isVertical = checkOrientation();
                startX = e.clientX;
                startY = e.clientY;
                
                if (isVertical) {
                    startHeight = UI.cardDatabaseSection.offsetHeight;
                    document.body.style.cursor = 'row-resize';
                } else {
                    startWidth = UI.cardDatabaseSection.offsetWidth;
                    document.body.style.cursor = 'col-resize';
                }
                
                document.body.style.userSelect = 'none';
                e.preventDefault();
            });

            let resizeRaf = null;
            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                if (resizeRaf) return; // throttle to one layout update per frame
                resizeRaf = requestAnimationFrame(() => {
                    resizeRaf = null;
                    if (isVertical) {
                        const containerHeight = UI.deckBuilderContainer.offsetHeight;
                        const deltaY = e.clientY - startY;
                        const newHeight = startHeight + deltaY;
                        const minHeight = containerHeight * 0.2;
                        const maxHeight = containerHeight * 0.6;
                        const constrainedHeight = Math.max(minHeight, Math.min(maxHeight, newHeight));
                        UI.cardDatabaseSection.style.height = `${constrainedHeight}px`;
                        UI.cardDatabaseSection.style.width = '100%';
                    } else {
                        const containerWidth = UI.deckBuilderContainer.offsetWidth;
                        const deltaX = e.clientX - startX;
                        const newWidth = startWidth + deltaX;
                        const minWidth = Math.max(180, containerWidth * 0.2);
                        const maxWidth = containerWidth * 0.6;
                        const constrainedWidth = Math.max(minWidth, Math.min(maxWidth, newWidth));
                        UI.cardDatabaseSection.style.width = `${constrainedWidth}px`;
                        UI.cardDatabaseSection.style.height = '';
                    }
                });
            });

            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                    
                    // Auto-adjust DB card size when DB section is resized
                    const newDbWidth = UI.cardDatabaseSection.offsetWidth;
                    if (newDbWidth > 0) {
                        calculateAndApplyScale('db', newDbWidth);
                    }
                    
                    savePanelConfiguration();
                }
            });

            // Prevent text selection while dragging
            UI.resizeHandle.addEventListener('selectstart', (e) => {
                e.preventDefault();
            });

            // Prevent auto-save during initial page load
            let allowAutoSave = false;
            setTimeout(() => {
                allowAutoSave = true;
            }, 1000); // Wait 1 second after page load before allowing auto-save
            
            // Handle window resize to update orientation
            window.addEventListener('resize', () => {
                if (!isResizing && allowAutoSave) {
                    const newIsVertical = checkOrientation();
                    if (newIsVertical !== isVertical) {
                        // Reset to default layout when orientation changes
                        if (newIsVertical) {
                            UI.cardDatabaseSection.style.width = '100%';
                            UI.cardDatabaseSection.style.height = '40vh';
                        } else {
                            UI.cardDatabaseSection.style.height = '';
                            UI.cardDatabaseSection.style.width = '33.333%';
                        }
                        savePanelConfiguration();
                    }
                }
            });
        }

        // --- EXTRA DECK TOGGLE FUNCTIONALITY ---
        function toggleExtraDeck() {
            if (!UI.extraDeckSection || !UI.toggleExtraDeckBtn) return;
            
            extraDeckVisible = !extraDeckVisible;
            
            if (extraDeckVisible) {
                // Show extra deck with smooth transition
                UI.extraDeckSection.style.display = '';
                UI.extraDeckSection.classList.remove('hidden');
                if (UI.sideExtraResizeHandle) UI.sideExtraResizeHandle.style.display = '';
                
                // Update button appearance
                UI.toggleExtraDeckBtn.textContent = 'Hide Extra';
                UI.toggleExtraDeckBtn.title = 'Hide Extra Deck';
                UI.toggleExtraDeckBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
                UI.toggleExtraDeckBtn.classList.add('bg-slate-700', 'hover:bg-slate-600');
                
                // AUTO-FIT: Adjust deck section sizes to fit everything on screen
                setTimeout(() => autoFitDeckSections(), 50);
            } else {
                // Hide extra deck with smooth transition
                UI.extraDeckSection.classList.add('hidden');
                
                // Update button appearance
                UI.toggleExtraDeckBtn.textContent = 'Show Extra';
                UI.toggleExtraDeckBtn.title = 'Show Extra Deck';
                UI.toggleExtraDeckBtn.classList.remove('bg-slate-700', 'hover:bg-slate-600');
                UI.toggleExtraDeckBtn.classList.add('bg-green-600', 'hover:bg-green-700');
                
                // Hide completely after transition
                const onEnd = () => {
                    UI.extraDeckSection.removeEventListener('transitionend', onEnd);
                    if (!extraDeckVisible) {
                        UI.extraDeckSection.style.display = 'none';
                        if (UI.sideExtraResizeHandle) UI.sideExtraResizeHandle.style.display = 'none';
                    }
                };
                UI.extraDeckSection.addEventListener('transitionend', onEnd, { once: true });
                
                // AUTO-FIT: Adjust deck section sizes to fit everything on screen
                setTimeout(() => autoFitDeckSections(), 50);
            }
            
            // Save the state
            saveExtraDeckVisibility();
            // Normalize widths post-visibility change
            autoFitDeckSections();
        }

        function saveExtraDeckVisibility() {
            try {
                localStorage.setItem('extraDeckVisible', JSON.stringify(extraDeckVisible));
            } catch (e) {
                console.error('Error saving extra deck visibility:', e);
            }
        }

        function loadExtraDeckVisibility() {
            try {
                const saved = localStorage.getItem('extraDeckVisible');
                if (saved !== null) {
                    extraDeckVisible = JSON.parse(saved);
                    if (!extraDeckVisible && UI.extraDeckSection && UI.toggleExtraDeckBtn) {
                        // Apply the hidden state without calling toggle
                        UI.extraDeckSection.style.display = 'none';
                        UI.extraDeckSection.classList.add('hidden');
                        if (UI.sideExtraResizeHandle) UI.sideExtraResizeHandle.style.display = 'none';
                        UI.toggleExtraDeckBtn.textContent = 'Show Extra';
                        UI.toggleExtraDeckBtn.title = 'Show Extra Deck';
                        UI.toggleExtraDeckBtn.classList.remove('bg-slate-700', 'hover:bg-slate-600');
                        UI.toggleExtraDeckBtn.classList.add('bg-green-600', 'hover:bg-green-700');
                        
                        // Make side deck expand to fill the space
                        if (UI.sideDeckSection) {
                            UI.sideDeckSection.style.flexGrow = '1';
                            UI.sideDeckSection.style.width = '';
                            UI.sideDeckSection.style.minWidth = '200px';
                        }
                    }
                }
            } catch (e) {
                console.error('Error loading extra deck visibility:', e);
            }
        }

        // --- SIDE DECK TOGGLE FUNCTIONALITY ---
        function toggleSideDeck() {
            if (!UI.sideDeckSection || !UI.toggleSideDeckBtn) return;
            
            sideDeckVisible = !sideDeckVisible;
            
            if (sideDeckVisible) {
                // Show side deck with smooth transition
                UI.sideDeckSection.style.display = '';
                UI.sideDeckSection.classList.remove('hidden');
                if (UI.mainSideResizeHandle) UI.mainSideResizeHandle.style.display = '';
                
                // Update button appearance
                UI.toggleSideDeckBtn.textContent = 'Hide Side';
                UI.toggleSideDeckBtn.title = 'Hide Side Deck';
                UI.toggleSideDeckBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
                UI.toggleSideDeckBtn.classList.add('bg-slate-700', 'hover:bg-slate-600');
                
                // AUTO-FIT: Adjust deck section sizes to fit everything on screen
                setTimeout(() => autoFitDeckSections(), 50);
            } else {
                // Hide side deck with smooth transition
                UI.sideDeckSection.classList.add('hidden');
                
                // Update button appearance
                UI.toggleSideDeckBtn.textContent = 'Show Side';
                UI.toggleSideDeckBtn.title = 'Show Side Deck';
                UI.toggleSideDeckBtn.classList.remove('bg-slate-700', 'hover:bg-slate-600');
                UI.toggleSideDeckBtn.classList.add('bg-green-600', 'hover:bg-green-700');
                
                // Hide completely after transition
                const onEnd = () => {
                    UI.sideDeckSection.removeEventListener('transitionend', onEnd);
                    if (!sideDeckVisible) {
                        UI.sideDeckSection.style.display = 'none';
                        if (UI.mainSideResizeHandle) UI.mainSideResizeHandle.style.display = 'none';
                    }
                };
                UI.sideDeckSection.addEventListener('transitionend', onEnd, { once: true });
                
                // AUTO-FIT: Adjust deck section sizes to fit everything on screen
                setTimeout(() => autoFitDeckSections(), 50);
            }
            
            // Save the state
            saveSideDeckVisibility();
            autoFitDeckSections();
        }

        function saveSideDeckVisibility() {
            try {
                localStorage.setItem('sideDeckVisible', JSON.stringify(sideDeckVisible));
            } catch (e) {
                console.error('Error saving side deck visibility:', e);
            }
        }

        function loadSideDeckVisibility() {
            try {
                const saved = localStorage.getItem('sideDeckVisible');
                if (saved !== null) {
                    sideDeckVisible = JSON.parse(saved);
                    if (!sideDeckVisible && UI.sideDeckSection && UI.toggleSideDeckBtn) {
                        // Apply the hidden state without calling toggle
                        UI.sideDeckSection.style.display = 'none';
                        UI.sideDeckSection.classList.add('hidden');
                        if (UI.mainSideResizeHandle) UI.mainSideResizeHandle.style.display = 'none';
                        UI.toggleSideDeckBtn.textContent = 'Show Side';
                        UI.toggleSideDeckBtn.title = 'Show Side Deck';
                        UI.toggleSideDeckBtn.classList.remove('bg-slate-700', 'hover:bg-slate-600');
                        UI.toggleSideDeckBtn.classList.add('bg-green-600', 'hover:bg-green-700');
                    }
                }
            } catch (e) {
                console.error('Error loading side deck visibility:', e);
            }
        }

        // --- DATABASE TOGGLE FUNCTIONALITY ---
        function toggleDatabase() {
            if (!UI.cardDatabaseSection || !UI.toggleDatabaseBtn) return;
            
            databaseVisible = !databaseVisible;
            
            if (databaseVisible) {
                // Show database with smooth transition
                UI.cardDatabaseSection.style.display = '';
                UI.cardDatabaseSection.classList.remove('hidden');
                if (UI.resizeHandle) UI.resizeHandle.style.display = '';
                
                // IMPORTANT: Ensure database doesn't take 100% width unless on narrow screen
                // Check if we're in vertical orientation (narrow screen)
                const isNarrowScreen = UI.deckBuilderContainer && UI.deckBuilderContainer.offsetWidth < 1024;
                if (!isNarrowScreen && UI.cardDatabaseSection.style.width === '100%') {
                    // Reset to normal width on wide screens
                    UI.cardDatabaseSection.style.width = '33.333%';
                    UI.cardDatabaseSection.style.height = '';
                    console.log('Database shown: Reset from 100% to 33.333% width (wide screen detected)');
                }
                
                // Only add database-visible class if actually taking 100% width
                if (UI.deckBuilderContainer && UI.cardDatabaseSection.style.width === '100%') {
                    UI.deckBuilderContainer.classList.add('database-visible');
                }
                
                // Normalize after visibility change
                autoFitDeckSections();
                
                // Update button appearance
                UI.toggleDatabaseBtn.textContent = 'Hide DB';
                UI.toggleDatabaseBtn.title = 'Hide Card Database';
                UI.toggleDatabaseBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
                UI.toggleDatabaseBtn.classList.add('bg-slate-700', 'hover:bg-slate-600');
            } else {
                // Hide database with smooth transition
                UI.cardDatabaseSection.classList.add('hidden');
                
                // Remove class from container for normal layout
                if (UI.deckBuilderContainer) {
                    UI.deckBuilderContainer.classList.remove('database-visible');
                }
                
                // AUTO-FIT: Adjust deck section sizes to fit everything on screen
                autoFitDeckSections();
                
                // Update button appearance
                UI.toggleDatabaseBtn.textContent = 'Show DB';
                UI.toggleDatabaseBtn.title = 'Show Card Database';
                UI.toggleDatabaseBtn.classList.remove('bg-slate-700', 'hover:bg-slate-600');
                UI.toggleDatabaseBtn.classList.add('bg-green-600', 'hover:bg-green-700');
                
                // Hide completely after transition
                const onEnd = () => {
                    UI.cardDatabaseSection.removeEventListener('transitionend', onEnd);
                    if (!databaseVisible) {
                        UI.cardDatabaseSection.style.display = 'none';
                        if (UI.resizeHandle) UI.resizeHandle.style.display = 'none';
                    }
                };
                UI.cardDatabaseSection.addEventListener('transitionend', onEnd, { once: true });
            }
            
            // Save the state
            saveDatabaseVisibility();
            autoFitDeckSections();
            
            // Clean up any bad saved configs that might have been created
            cleanupBadConfigs();
        }
        
        function autoFitDeckSections() {
            // Automatically adjust deck section sizes to fit everything on screen
            if (!UI.deckGridContainer || !UI.mainDeckSection || !UI.sideDeckSection || !UI.extraDeckSection) return;
            
            console.log('Auto-fitting deck sections to screen...');
            
            // Get available width for deck sections
            const containerWidth = UI.deckGridContainer.offsetWidth;
            if (containerWidth === 0) {
                console.log('Container width is 0, skipping auto-fit');
                return;
            }
            
            // Account for resize handles and gaps
            const resizeHandleWidth = 8; // Each handle is 8px (w-2)
            const gap = 16; // gap-4 = 16px between sections
            const padding = 24; // Total padding from sections (p-3 on each)
            const availableWidth = containerWidth - (resizeHandleWidth * 2) - (gap * 2) - padding;
            
            console.log(`Available width for deck sections: ${availableWidth}px`);
            
            // Get current widths
            let mainWidth = parseFloat(UI.mainDeckSection.style.width) || UI.mainDeckSection.offsetWidth;
            let sideWidth = parseFloat(UI.sideDeckSection.style.width) || 280;
            let extraWidth = parseFloat(UI.extraDeckSection.style.width) || 280;
            
            // Check if extra deck is visible
            const extraVisible = extraDeckVisible && UI.extraDeckSection.style.display !== 'none';
            const sideVisible = sideDeckVisible && UI.sideDeckSection.style.display !== 'none';
            
            if (!extraVisible) extraWidth = 0;
            if (!sideVisible) sideWidth = 0;
            
            const totalWidth = mainWidth + sideWidth + extraWidth;
            
            console.log(`Current widths - Main: ${mainWidth}px, Side: ${sideWidth}px, Extra: ${extraWidth}px, Total: ${totalWidth}px`);
            
            // Minimum and maximum widths
            const minMainWidth = 200;
            const minSideWidth = 150;
            const minExtraWidth = 150;
            const maxMainWidth = Math.min(1200, availableWidth); // never exceed container
            const maxSideWidth = Math.min(400, availableWidth);
            const maxExtraWidth = Math.min(400, availableWidth);
            
            // Store old widths BEFORE making any changes (for card scale adjustment)
            const oldMainWidth = mainWidth;
            const oldSideWidth = sideWidth;
            const oldExtraWidth = extraWidth;
            
            // Check if we need to adjust sizes
            const needsAdjustment = totalWidth > availableWidth || (totalWidth < availableWidth * 0.85);
            
            if (needsAdjustment) {
                if (totalWidth > availableWidth) {
                    // SHRINK: Sections are too wide, scale down proportionally
                    const scale = availableWidth / totalWidth;
                    console.log(`Sections too wide, scaling down by ${scale.toFixed(3)}`);
                    
                    // Scale down proportionally
                    mainWidth = Math.max(minMainWidth, mainWidth * scale);
                    if (sideVisible) sideWidth = Math.max(minSideWidth, sideWidth * scale);
                    if (extraVisible) extraWidth = Math.max(minExtraWidth, extraWidth * scale);
                    
                    // If still too wide after applying minimums, shrink main deck more
                    const newTotal = mainWidth + sideWidth + extraWidth;
                    if (newTotal > availableWidth) {
                        const deficit = newTotal - availableWidth;
                        mainWidth = Math.max(minMainWidth, mainWidth - deficit);
                    }
                } else {
                    // EXPAND: There's unused space, fill it proportionally
                    const unusedSpace = availableWidth - totalWidth;
                    console.log(`${unusedSpace}px unused space detected, expanding sections to fill`);
                    
                    // Calculate how much each section can expand (respecting maximums)
                    const mainCanExpand = Math.max(0, maxMainWidth - mainWidth);
                    const sideCanExpand = sideVisible ? Math.max(0, maxSideWidth - sideWidth) : 0;
                    const extraCanExpand = extraVisible ? Math.max(0, maxExtraWidth - extraWidth) : 0;
                    const totalCanExpand = mainCanExpand + sideCanExpand + extraCanExpand;
                    
                    if (totalCanExpand > 0) {
                        // Distribute unused space proportionally based on how much each can expand
                        const spaceToDistribute = Math.min(unusedSpace, totalCanExpand);
                        
                        if (mainCanExpand > 0) {
                            const mainExpansion = (mainCanExpand / totalCanExpand) * spaceToDistribute;
                            mainWidth = Math.min(maxMainWidth, mainWidth + mainExpansion);
                        }
                        if (sideVisible && sideCanExpand > 0) {
                            const sideExpansion = (sideCanExpand / totalCanExpand) * spaceToDistribute;
                            sideWidth = Math.min(maxSideWidth, sideWidth + sideExpansion);
                        }
                        if (extraVisible && extraCanExpand > 0) {
                            const extraExpansion = (extraCanExpand / totalCanExpand) * spaceToDistribute;
                            extraWidth = Math.min(maxExtraWidth, extraWidth + extraExpansion);
                        }
                    }
                }
                
                // Apply new widths (no transitions on width to avoid jitter)
                UI.mainDeckSection.style.width = `${mainWidth}px`;
                UI.mainDeckSection.style.minWidth = `${mainWidth}px`;
                UI.mainDeckSection.style.flexGrow = '0';
                UI.mainDeckSection.style.flexShrink = '1';
                
                if (sideVisible) {
                    UI.sideDeckSection.style.width = `${sideWidth}px`;
                    UI.sideDeckSection.style.minWidth = `${sideWidth}px`;
                    // If extra deck is hidden, make side deck expand to fill available space
                    if (!extraVisible) {
                        UI.sideDeckSection.style.flexGrow = '1';
                    } else {
                        UI.sideDeckSection.style.flexGrow = '0';
                    }
                    UI.sideDeckSection.style.flexShrink = '1';
                }
                
                if (extraVisible) {
                    UI.extraDeckSection.style.width = `${extraWidth}px`;
                    UI.extraDeckSection.style.minWidth = `${extraWidth}px`;
                    UI.extraDeckSection.style.flexGrow = '0';
                    UI.extraDeckSection.style.flexShrink = '1';
                }
                
                console.log(`Adjusted widths - Main: ${Math.round(mainWidth)}px, Side: ${Math.round(sideWidth)}px, Extra: ${Math.round(extraWidth)}px`);
                
            // AUTO-ADJUST card scales once after widths applied
                autoAdjustCardScales(mainWidth, sideWidth, extraWidth, oldMainWidth, oldSideWidth, oldExtraWidth);
                
                // Save the new configuration
                saveDeckResizeConfiguration();
            } else {
                console.log('Sections fit within available space, no adjustment needed');
                
                // Even if no width adjustment is needed, we still need to handle flex properties
                // when extra deck is hidden to ensure side deck expands properly
                if (sideVisible && !extraVisible) {
                    UI.sideDeckSection.style.flexGrow = '1';
                } else if (sideVisible && extraVisible) {
                    UI.sideDeckSection.style.flexGrow = '0';
                }
            }
        }
        
        function autoAdjustCardScales(newMainWidth, newSideWidth, newExtraWidth, oldMainWidth, oldSideWidth, oldExtraWidth) {
            // Automatically adjust card scales to maintain saved cards-per-row setting
            // when section widths change. Cards-per-row is the truth; scale is derived.
            
            // Don't adjust during initial page load
            if (!allowAutoAdjust) {
                console.log('[CARD SCALE ADJUST] Skipping during page load');
                return;
            }
            
            console.log('[CARD SCALE ADJUST] Adjusting to maintain cards-per-row...');
            
            const padding = 24;
            const gap = 4;
            
            // Adjust main deck
            if (newMainWidth > 0) {
                const cardsPerRow = getCurrentCardsPerRow('main');
                const availableWidth = newMainWidth - padding;
                const cardSize = Math.max(46, Math.min(150, (availableWidth / cardsPerRow) - gap));
                const roundedSize = Math.round(cardSize);
                
                document.documentElement.style.setProperty('--main-deck-size', `${roundedSize}px`);
                localStorage.setItem('mainDeckScale', roundedSize);
                console.log(`[CARD SCALE ADJUST] Main: ${cardsPerRow} cards/row  ${roundedSize}px per card`);
            }
            
            // Adjust side deck (if visible)
            const isSideVisible = UI.sideDeckSection && UI.sideDeckSection.style.display !== 'none' && !UI.sideDeckSection.classList.contains('hidden');
            if (isSideVisible && newSideWidth > 0) {
                const cardsPerRow = getCurrentCardsPerRow('side');
                const availableWidth = newSideWidth - padding;
                const cardSize = Math.max(46, Math.min(150, (availableWidth / cardsPerRow) - gap));
                const roundedSize = Math.round(cardSize);
                
                document.documentElement.style.setProperty('--side-deck-size', `${roundedSize}px`);
                localStorage.setItem('sideDeckScale', roundedSize);
                console.log(`[CARD SCALE ADJUST] Side: ${cardsPerRow} cards/row  ${roundedSize}px per card`);
            }
            
            // Adjust extra deck (if visible)
            const isExtraVisible = UI.extraDeckSection && UI.extraDeckSection.style.display !== 'none' && !UI.extraDeckSection.classList.contains('hidden');
            if (isExtraVisible && newExtraWidth > 0) {
                const cardsPerRow = getCurrentCardsPerRow('extra');
                const availableWidth = newExtraWidth - padding;
                const cardSize = Math.max(46, Math.min(150, (availableWidth / cardsPerRow) - gap));
                const roundedSize = Math.round(cardSize);
                
                document.documentElement.style.setProperty('--extra-deck-size', `${roundedSize}px`);
                localStorage.setItem('extraDeckScale', roundedSize);
                console.log(`[CARD SCALE ADJUST] Extra: ${cardsPerRow} cards/row  ${roundedSize}px per card`);
            }
            
            // Update slider and display to show current cards per row for active target
            const currentCardsPerRow = getCurrentCardsPerRow(scaleTarget);
            UI.deckScaleSlider.value = currentCardsPerRow;
            if (UI.cardsPerRowDisplay) {
                UI.cardsPerRowDisplay.textContent = currentCardsPerRow;
            }
        }
        
        function autoAdjustCardScalesForManualResize(newMainWidth, newSideWidth, newExtraWidth, oldLeftWidth, oldRightWidth, handleType) {
            // Adjust card scales when user manually resizes sections with drag handles
            // This maintains the cards-per-row layout as sections get bigger or smaller
            
            // Don't adjust during initial page load
            if (!allowAutoAdjust) {
                console.log('[MANUAL RESIZE] Skipping during page load');
                return;
            }
            
            const padding = 24;
            const gap = 4;
            
            function calculateAndApplyScale(deckType, newWidth) {
                if (newWidth === 0 || newWidth < 100) {
                    return; // Skip if section is too small
                }
                
                // Get the saved cards-per-row setting for this deck
                const cardsPerRow = getCurrentCardsPerRow(deckType);
                const availableWidth = newWidth - padding;
                
                // Calculate card size to fit exactly this many cards per row
                const cardSize = Math.max(46, Math.min(150, (availableWidth / cardsPerRow) - gap));
                const roundedSize = Math.round(cardSize);
                
                // Apply the new card size
                const cssVar = deckType === 'db' ? '--db-card-size' : `--${deckType}-deck-size`;
                document.documentElement.style.setProperty(cssVar, `${roundedSize}px`);
                localStorage.setItem(`${deckType}DeckScale`, roundedSize);
                console.log(`[MANUAL RESIZE] ${deckType}: ${cardsPerRow} cards/row  ${roundedSize}px per card (width: ${Math.round(newWidth)}px)`);
                
                // Update slider and display if this is the current target
                if (scaleTarget === deckType) {
                    UI.deckScaleSlider.value = cardsPerRow;
                    if (UI.cardsPerRowDisplay) {
                        UI.cardsPerRowDisplay.textContent = cardsPerRow;
                    }
                }
            }
            
            // Apply scale adjustments based on which handle was dragged
            if (handleType === 'mainSide') {
                // Main-Side handle: left is main, right is side
                calculateAndApplyScale('main', newMainWidth);
                calculateAndApplyScale('side', newSideWidth);
            } else if (handleType === 'sideExtra') {
                // Side-Extra handle: left is side, right is extra
                calculateAndApplyScale('side', newSideWidth);
                calculateAndApplyScale('extra', newExtraWidth);
            }
        }

        function saveDatabaseVisibility() {
            try {
                localStorage.setItem('databaseVisible', JSON.stringify(databaseVisible));
            } catch (e) {
                console.error('Error saving database visibility:', e);
            }
        }

        function loadDatabaseVisibility() {
            try {
                const saved = localStorage.getItem('databaseVisible');
                if (saved !== null) {
                    databaseVisible = JSON.parse(saved);
                    if (!databaseVisible && UI.cardDatabaseSection && UI.toggleDatabaseBtn) {
                        // Apply the hidden state without calling toggle
                        UI.cardDatabaseSection.style.display = 'none';
                        UI.cardDatabaseSection.classList.add('hidden');
                        if (UI.resizeHandle) UI.resizeHandle.style.display = 'none';
                        UI.toggleDatabaseBtn.textContent = 'Show DB';
                        UI.toggleDatabaseBtn.title = 'Show Card Database';
                        UI.toggleDatabaseBtn.classList.remove('bg-slate-700', 'hover:bg-slate-600');
                        UI.toggleDatabaseBtn.classList.add('bg-green-600', 'hover:bg-green-700');
                        
                        // Remove class from container for normal layout
                        if (UI.deckBuilderContainer) {
                            UI.deckBuilderContainer.classList.remove('database-visible');
                        }
                    } else if (databaseVisible && UI.deckBuilderContainer) {
                        // Add class to container for responsive layout when database is visible
                        UI.deckBuilderContainer.classList.add('database-visible');
                    }
                }
            } catch (e) {
                console.error('Error loading database visibility:', e);
            }
        }
        
        function loadCardDatabaseView() {
            try {
                const saved = localStorage.getItem('cardDatabaseView');
                if (saved !== null) {
                    cardDatabaseView = saved;
                    // Update button text to reflect current view
                    if (UI.viewToggleBtn) {
                        if (cardDatabaseView === 'grid') {
                            UI.viewToggleBtn.innerHTML = `<svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z"></path></svg>Grid`;
                        } else {
                            UI.viewToggleBtn.innerHTML = `<svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 10h16M4 14h16M4 18h16"></path></svg>List`;
                        }
                    }
                }
            } catch (e) {
                console.error('Error loading card database view preference:', e);
            }
        }

        // --- FULLSCREEN TOGGLE FUNCTIONALITY ---
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                // Enter fullscreen
                document.documentElement.requestFullscreen().catch(err => {
                    console.error('Error attempting to enable fullscreen:', err);
                    showMessage('Fullscreen mode is not supported or was denied.');
                });
                // Update button icon to exit fullscreen icon
                if (UI.fullscreenBtn) {
                    UI.fullscreenBtn.innerHTML = `
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 9V4.5M9 9H4.5M9 9L3.75 3.75M9 15v4.5M9 15H4.5M9 15l-5.25 5.25M15 9h4.5M15 9V4.5M15 9l5.25-5.25M15 15h4.5M15 15v4.5m0-4.5l5.25 5.25"></path>
                        </svg>
                    `;
                    UI.fullscreenBtn.title = 'Exit Fullscreen';
                }
            } else {
                // Exit fullscreen
                document.exitFullscreen();
                // Update button icon to enter fullscreen icon
                if (UI.fullscreenBtn) {
                    UI.fullscreenBtn.innerHTML = `
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"></path>
                        </svg>
                    `;
                    UI.fullscreenBtn.title = 'Toggle Fullscreen';
                }
            }
        }
        
        // Listen for fullscreen changes (e.g., user presses ESC)
        document.addEventListener('fullscreenchange', () => {
            if (!document.fullscreenElement && UI.fullscreenBtn) {
                // Restore enter fullscreen icon
                UI.fullscreenBtn.innerHTML = `
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"></path>
                    </svg>
                `;
                UI.fullscreenBtn.title = 'Toggle Fullscreen';
            }
        });

        // --- DECK RESIZE FUNCTIONALITY ---
        function initializeDeckResizeHandles() {
            // Main-Side resize handle
            if (UI.mainSideResizeHandle && UI.mainDeckSection && UI.sideDeckSection) {
                initializeDeckResizeHandle(UI.mainSideResizeHandle, UI.mainDeckSection, UI.sideDeckSection, 'mainSide');
            }
            
            // Side-Extra resize handle
            if (UI.sideExtraResizeHandle && UI.sideDeckSection && UI.extraDeckSection) {
                initializeDeckResizeHandle(UI.sideExtraResizeHandle, UI.sideDeckSection, UI.extraDeckSection, 'sideExtra');
            }
            
            // Safety check: Ensure deck builder is always visible
            setTimeout(() => {
                if (UI.deckBuilderSection && UI.deckBuilderSection.offsetWidth < 100) {
                    console.warn('Deck builder not visible or too small, applying emergency defaults');
                    if (UI.cardDatabaseSection) {
                        UI.cardDatabaseSection.style.width = '33.333%';
                        UI.cardDatabaseSection.style.display = '';
                    }
                    if (UI.deckBuilderSection) {
                        UI.deckBuilderSection.style.display = '';
                        UI.deckBuilderSection.style.width = '';
                        UI.deckBuilderSection.style.flexGrow = '1';
                    }
                    if (UI.deckBuilderContainer) {
                        UI.deckBuilderContainer.style.display = 'flex';
                    }
                    applyDefaultDeckLayout();
                }
            }, 200);
        }

        function initializeDeckResizeHandle(handle, leftSection, rightSection, handleType) {
            let isResizing = false;
            let startX = 0;
            let startLeftWidth = 0;
            let startRightWidth = 0;

            handle.addEventListener('mousedown', (e) => {
                isResizing = true;
                startX = e.clientX;
                startLeftWidth = leftSection.offsetWidth;
                startRightWidth = rightSection.offsetWidth;
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
            });

            let deckResizeRaf = null;
            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                if (deckResizeRaf) return;
                deckResizeRaf = requestAnimationFrame(() => {
                    deckResizeRaf = null;
                    const containerWidth = UI.deckGridContainer.offsetWidth;
                    const deltaX = e.clientX - startX;
                    let newLeftWidth = startLeftWidth + deltaX;
                    let newRightWidth = startRightWidth - deltaX;
                    const minWidth = 100;
                    newLeftWidth = Math.max(minWidth, newLeftWidth);
                    newRightWidth = Math.max(minWidth, newRightWidth);
                    const totalOverhead = 64 + 16 + 10;
                    const availableSpace = containerWidth - totalOverhead;
                    let mainWidth, sideWidth, extraWidth;
                    if (handleType === 'mainSide') {
                        mainWidth = newLeftWidth;
                        sideWidth = newRightWidth;
                        extraWidth = UI.extraDeckSection && UI.extraDeckSection.style.display !== 'none' 
                            ? UI.extraDeckSection.offsetWidth 
                            : 0;
                    } else {
                        mainWidth = UI.mainDeckSection ? UI.mainDeckSection.offsetWidth : 0;
                        sideWidth = newLeftWidth;
                        extraWidth = newRightWidth;
                    }
                    let totalWidth = mainWidth + (sideWidth > 0 ? sideWidth : 0) + (extraWidth > 0 ? extraWidth : 0);
                    if (totalWidth > availableSpace) {
                        const excess = totalWidth - availableSpace;
                        const totalBeingResized = newLeftWidth + newRightWidth;
                        const scale = Math.max(0.5, (totalBeingResized - excess) / totalBeingResized);
                        newLeftWidth = Math.max(minWidth, newLeftWidth * scale);
                        newRightWidth = Math.max(minWidth, newRightWidth * scale);
                    }
                    leftSection.style.width = `${newLeftWidth}px`;
                    leftSection.style.minWidth = `${newLeftWidth}px`;
                    rightSection.style.width = `${newRightWidth}px`;
                    rightSection.style.minWidth = `${newRightWidth}px`;
                    if (handleType === 'mainSide') {
                        leftSection.style.flexGrow = '0';
                        leftSection.style.flexShrink = '0';
                    }
                });
            });

            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                    
                    // Manual resize complete - adjust card scales to maintain layout
                    const newMainWidth = parseFloat(UI.mainDeckSection.style.width) || UI.mainDeckSection.offsetWidth;
                    const newSideWidth = parseFloat(UI.sideDeckSection.style.width) || UI.sideDeckSection.offsetWidth;
                    const newExtraWidth = parseFloat(UI.extraDeckSection.style.width) || UI.extraDeckSection.offsetWidth;
                    
                    // Auto-adjust card scales for manual resize
                    autoAdjustCardScalesForManualResize(newMainWidth, newSideWidth, newExtraWidth, startLeftWidth, startRightWidth, handleType);
                    
                    saveDeckResizeConfiguration();
                }
            });

            // Prevent text selection while dragging
            handle.addEventListener('selectstart', (e) => {
                e.preventDefault();
            });
        }

        function saveDeckResizeConfiguration() {
            try {
                // Only save if sections have been manually resized (have explicit widths set)
                const mainWidth = UI.mainDeckSection.style.width;
                const sideWidth = UI.sideDeckSection.style.width;
                const extraWidth = UI.extraDeckSection.style.width;
                
                // Don't save empty values or if all are at defaults
                if (!mainWidth && !sideWidth && !extraWidth) {
                    // All at defaults, remove any saved config
                    localStorage.removeItem('deckResizeConfig');
                    return;
                }
                
                const config = {
                    mainDeckWidth: mainWidth || '',
                    sideDeckWidth: sideWidth || '',
                    extraDeckWidth: extraWidth || ''
                };
                
                localStorage.setItem('deckResizeConfig', JSON.stringify(config));
            } catch (e) {
                console.error('Error saving deck resize configuration:', e);
            }
        }

        function loadDeckResizeConfiguration() {
            console.log('Loading deck resize configuration...');
            try {
                const savedConfig = localStorage.getItem('deckResizeConfig');
                console.log('Saved deck resize config:', savedConfig);
                
                // If no config exists at all, or if it's an empty object, use defaults
                if (!savedConfig || savedConfig === '{}') {
                    console.log('No saved config found, applying default deck layout');
                    applyDefaultDeckLayout();
                    return;
                }
                
                const config = JSON.parse(savedConfig);
                console.log('Parsed deck resize config:', config);
                
                // Check if config has valid data (all three sections)
                const hasValidConfig = config.mainDeckWidth || config.sideDeckWidth || config.extraDeckWidth;
                
                if (!hasValidConfig) {
                    applyDefaultDeckLayout();
                    return;
                }
                
                // Load saved configuration
                if (config.mainDeckWidth) {
                    UI.mainDeckSection.style.width = config.mainDeckWidth;
                    UI.mainDeckSection.style.minWidth = config.mainDeckWidth;
                    UI.mainDeckSection.style.flexGrow = '0';
                    UI.mainDeckSection.style.flexShrink = '0';
                } else {
                    UI.mainDeckSection.style.width = '';
                    UI.mainDeckSection.style.minWidth = '300px';
                    UI.mainDeckSection.style.flexGrow = '1';
                    UI.mainDeckSection.style.flexShrink = '1';
                }
                if (config.sideDeckWidth) {
                    UI.sideDeckSection.style.width = config.sideDeckWidth;
                    UI.sideDeckSection.style.minWidth = config.sideDeckWidth;
                    UI.sideDeckSection.style.flexGrow = '0';
                    UI.sideDeckSection.style.flexShrink = '1';
                } else {
                    UI.sideDeckSection.style.width = '280px';
                    UI.sideDeckSection.style.minWidth = '200px';
                    UI.sideDeckSection.style.flexGrow = '0';
                    UI.sideDeckSection.style.flexShrink = '1';
                }
                if (config.extraDeckWidth) {
                    UI.extraDeckSection.style.width = config.extraDeckWidth;
                    UI.extraDeckSection.style.minWidth = config.extraDeckWidth;
                    UI.extraDeckSection.style.flexGrow = '0';
                    UI.extraDeckSection.style.flexShrink = '1';
                } else {
                    UI.extraDeckSection.style.width = '280px';
                    UI.extraDeckSection.style.minWidth = '200px';
                    UI.extraDeckSection.style.flexGrow = '0';
                    UI.extraDeckSection.style.flexShrink = '1';
                }
            } catch (e) {
                console.error('Error loading deck resize configuration:', e);
                applyDefaultDeckLayout();
            }
        }

        // --- EVENT LISTENERS ---
        function attachEventListeners() {
            if (!UI.navDeckBuilder) return; 
            // Navigation
            UI.navDeckBuilder.addEventListener('click', () => showView('deckBuilderView'));
            UI.headerTitle.addEventListener('click', () => showView('deckBuilderView'));
            
            // Fullscreen toggle
            UI.fullscreenBtn.addEventListener('click', toggleFullscreen);
            
            // Immersion mode toggle
            const immersionModeBtn = document.getElementById('immersionModeBtn');
            if (immersionModeBtn) immersionModeBtn.addEventListener('click', toggleImmersionMode);
            
            UI.navSimulator.addEventListener('click', () => {
                 // Allow access in offline mode if a deck is loaded, otherwise check for saved decks.
                 if (deckLists.length === 0 && !isOffline) {
                     showMessage("You must have at least one saved deck before starting a simulation.");
                     return;
                 }
                 populateSimulationSetup();
                 showView('simulationView');
            });
             UI.navAiTraining.addEventListener('click', () => {
                populateAiTrainingView();
                showView('aiTrainingView');
            });
            UI.navShootout.addEventListener('click', () => { // MODIFIED
                // Allow access in offline mode if a deck is loaded in the builder, otherwise check for saved decks online.
                if (deckLists.length === 0 && !isOffline) {
                     showMessage("You must have at least one saved deck before starting Shootout Mode.");
                     return;
                 }
                ShootoutManager.populateSetup();
                showView('shootoutView');
            });
            UI.navOnlineMode.addEventListener('click', () => {
                showMessage("Online Mode is currently unavailable. The tool is running in offline mode.");
            });
            
            // Card Database
            UI.addCardBtn.addEventListener('click', handleCardSearch);
            UI.cardSearchInput.addEventListener('input', handleAutocomplete);
            UI.cardSearchInput.addEventListener('keydown', handleAutocompleteKeydown);
            UI.cardSearchInput.addEventListener('blur', () => {
                // Delay hiding to allow click on autocomplete item
                setTimeout(() => hideAutocomplete(), 200);
            });
            UI.cardSearchInput.addEventListener('focus', handleAutocomplete);
            UI.autocompleteModeToggle.addEventListener('click', toggleAutocompleteMode);
            UI.editDbToggle.addEventListener('click', toggleEditMode);
            UI.viewToggleBtn.addEventListener('click', toggleCardDatabaseView);
            UI.selectAllGridBtn.addEventListener('click', selectAllGridCards);
            UI.clearSelectionGridBtn.addEventListener('click', clearGridSelection);
            UI.deleteSelectedGridBtn.addEventListener('click', deleteSelectedGridCards);
            UI.resetDbBtn.addEventListener('click', resetDatabase);
            
            // Advanced Search
            UI.advancedSearchBtn.addEventListener('click', openAdvancedSearchModal);
            UI.advancedSearchModalClose.addEventListener('click', closeAdvancedSearchModal);
            
            // Advanced Search Filters
            UI.advSearchCardType.addEventListener('change', (e) => {
                advancedSearchState.filters.cardType = e.target.value || null;
                updateAdvancedSearchUI();
                applyAdvancedFilters();
            });
            
            UI.advSearchCardSubtype.addEventListener('change', (e) => {
                advancedSearchState.filters.cardSubtype = e.target.value || null;
                applyAdvancedFilters();
            });
            
            UI.advSearchMonsterType.addEventListener('change', (e) => {
                const selected = Array.from(e.target.selectedOptions).map(opt => opt.value);
                advancedSearchState.filters.monsterType = selected;
                applyAdvancedFilters();
            });
            
            // Attribute buttons
            UI.advSearchAttributeContainer.querySelectorAll('button').forEach(btn => {
                btn.addEventListener('click', () => {
                    const attr = btn.dataset.attribute;
                    const idx = advancedSearchState.filters.attribute.indexOf(attr);
                    if (idx > -1) {
                        advancedSearchState.filters.attribute.splice(idx, 1);
                        btn.classList.remove('bg-blue-600', 'border-blue-400');
                        btn.classList.add('bg-slate-700');
                    } else {
                        advancedSearchState.filters.attribute.push(attr);
                        btn.classList.remove('bg-slate-700');
                        btn.classList.add('bg-blue-600', 'border-blue-400');
                    }
                    applyAdvancedFilters();
                });
            });
            
            // Monster subtype checkboxes
            UI.advSearchMonsterSubtypeContainer.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                cb.addEventListener('change', () => {
                    advancedSearchState.filters.monsterSubtype = 
                        Array.from(UI.advSearchMonsterSubtypeContainer.querySelectorAll('input[type="checkbox"]:checked'))
                            .map(c => c.value);
                    applyAdvancedFilters();
                });
            });
            
            // Level range inputs
            UI.advSearchLevelMin.addEventListener('input', (e) => {
                advancedSearchState.filters.levelMin = parseInt(e.target.value) || 0;
                UI.advSearchLevelDisplay.textContent = `${advancedSearchState.filters.levelMin} - ${advancedSearchState.filters.levelMax}`;
                applyAdvancedFilters();
            });
            
            UI.advSearchLevelMax.addEventListener('input', (e) => {
                advancedSearchState.filters.levelMax = parseInt(e.target.value) || 12;
                UI.advSearchLevelDisplay.textContent = `${advancedSearchState.filters.levelMin} - ${advancedSearchState.filters.levelMax}`;
                applyAdvancedFilters();
            });
            
            // ATK/DEF range inputs
            UI.advSearchAtkMin.addEventListener('input', (e) => {
                advancedSearchState.filters.atkMin = e.target.value ? parseInt(e.target.value) : null;
                applyAdvancedFilters();
            });
            
            UI.advSearchAtkMax.addEventListener('input', (e) => {
                advancedSearchState.filters.atkMax = e.target.value ? parseInt(e.target.value) : null;
                applyAdvancedFilters();
            });
            
            UI.advSearchDefMin.addEventListener('input', (e) => {
                advancedSearchState.filters.defMin = e.target.value ? parseInt(e.target.value) : null;
                applyAdvancedFilters();
            });
            
            UI.advSearchDefMax.addEventListener('input', (e) => {
                advancedSearchState.filters.defMax = e.target.value ? parseInt(e.target.value) : null;
                applyAdvancedFilters();
            });
            
            // Banlist status checkboxes
            UI.advSearchBanlistContainer.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                cb.addEventListener('change', () => {
                    advancedSearchState.filters.banlistStatus = 
                        Array.from(UI.advSearchBanlistContainer.querySelectorAll('input[type="checkbox"]:checked'))
                            .map(c => c.value);
                    applyAdvancedFilters();
                });
            });
            
            // Sort options
            UI.advSearchSortBy.addEventListener('change', (e) => {
                advancedSearchState.sort.by = e.target.value;
                applyAdvancedFilters();
            });
            
            UI.advSearchSortOrder.addEventListener('change', (e) => {
                advancedSearchState.sort.order = e.target.value;
                applyAdvancedFilters();
            });
            
            // Text search input
            UI.advSearchTextInput.addEventListener('input', (e) => {
                advancedSearchState.filters.text = e.target.value.trim();
                applyAdvancedFilters();
            });
            
            // Action buttons
            UI.advSearchApplyBtn.addEventListener('click', applyAdvancedFilters);
            UI.advSearchResetBtn.addEventListener('click', resetAdvancedSearchFilters);
            UI.advSearchManageBanlistBtn.addEventListener('click', openBanlistModal);
            
            // View toggle
            UI.advSearchViewToggle.addEventListener('click', () => {
                advancedSearchState.view = advancedSearchState.view === 'grid' ? 'list' : 'grid';
                const text = advancedSearchState.view === 'grid' ? 'Grid' : 'List';
                const icon = advancedSearchState.view === 'grid' 
                    ? '<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z"></path></svg>'
                    : '<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg>';
                UI.advSearchViewToggle.innerHTML = `${icon}<span>${text}</span>`;
                renderAdvancedSearchResults();
            });
            
            // Card Info toggle
            UI.advSearchCardInfoToggle.addEventListener('click', toggleCardInfoPanel);
            
            // Arrow key navigation for selection mode
            document.addEventListener('keydown', handleAdvancedSearchKeydown);
            
            // Click outside to deactivate selection mode
            UI.advSearchResultsContainer.addEventListener('click', (e) => {
                // If clicked on the container itself (not a card), deactivate selection mode
                if (e.target === UI.advSearchResultsContainer) {
                    deactivateSelectionMode();
                }
            });
            
            // Pagination
            UI.advSearchPerPageSlider.addEventListener('input', (e) => {
                const perPage = parseInt(e.target.value);
                advancedSearchState.pagination.perPage = perPage;
                advancedSearchState.pagination.page = 1;
                UI.advSearchPerPageDisplay.textContent = perPage;
                renderAdvancedSearchResults();
            });
            
            UI.advSearchPrevPage.addEventListener('click', () => {
                if (advancedSearchState.pagination.page > 1) {
                    advancedSearchState.pagination.page--;
                    renderAdvancedSearchResults();
                }
            });
            
            UI.advSearchNextPage.addEventListener('click', () => {
                const totalPages = Math.ceil(advancedSearchState.results.length / advancedSearchState.pagination.perPage);
                if (advancedSearchState.pagination.page < totalPages) {
                    advancedSearchState.pagination.page++;
                    renderAdvancedSearchResults();
                }
            });
            
            // Banlist Modal
            UI.banlistModalClose.addEventListener('click', closeBanlistModal);
            UI.banlistSaveBtn.addEventListener('click', saveBanlist);
            UI.banlistResetBtn.addEventListener('click', resetBanlist);
            UI.banlistSearchInput.addEventListener('input', (e) => {
                searchCardsForBanlist(e.target.value.trim());
            });

            // Deck Builder
            UI.saveDeckBtn.addEventListener('click', saveCurrentDeck);
            UI.loadDeckBtn.addEventListener('click', loadSelectedDeck);
            UI.deleteDeckBtn.addEventListener('click', deleteSelectedDeck);
            UI.exportDeckBtn.addEventListener('click', exportDeckToYDK);
            UI.exportDeckYDKXBtn.addEventListener('click', exportDeckToYDKX);
            UI.exportDeckClipboardBtn.addEventListener('click', exportDeckToClipboard);
            UI.importDeckClipboardBtn.addEventListener('click', importDeckFromClipboard);
            UI.importDeckInput.addEventListener('change', importDeckFromYDK);
            if (UI.deckNameInput) {
                UI.deckNameInput.addEventListener('input', markDeckDirty);
            }
            UI.deckScaleSlider.addEventListener('input', e => {
                const cardsPerRow = parseInt(e.target.value);
                updateCardsPerRow(scaleTarget, cardsPerRow);
            });
            UI.scaleTargetBtn.addEventListener('click', cycleScaleTarget);

            // Deck Options Dropdown
            UI.deckOptionsBtn.addEventListener('click', toggleDeckOptionsDropdown);
            UI.resetToDefaultSizesBtn.addEventListener('click', resetToDefaultSizes);
            
            // Close dropdown when clicking outside
            document.addEventListener('click', (e) => {
                if (!UI.deckOptionsBtn.contains(e.target) && !UI.deckOptionsDropdown.contains(e.target)) {
                    UI.deckOptionsDropdown.classList.add('hidden');
                }
            });

            // YDK Folder Management
            if (UI.ydkFolderBtn) UI.ydkFolderBtn.addEventListener('click', selectYDKFolder);
            if (UI.ydkFileInput) UI.ydkFileInput.addEventListener('change', importSingleYDKFile);
            if (UI.syncFolderBtn) UI.syncFolderBtn.addEventListener('click', selectYDKFolder);
            if (UI.manageFilesBtn) UI.manageFilesBtn.addEventListener('click', openYDKManagementModal);
            if (UI.ydkDeckSelector) UI.ydkDeckSelector.addEventListener('change', e => loadYDKDeck(parseInt(e.target.value)));
            if (UI.setDefaultDeckBtn) UI.setDefaultDeckBtn.addEventListener('click', setDefaultYDKDeck);
            
            // YDK Management Modal
            if (UI.ydkManagementModalClose) UI.ydkManagementModalClose.addEventListener('click', () => UI.ydkManagementModal.classList.add('hidden'));
            if (UI.clearAllYDKFilesBtn) UI.clearAllYDKFilesBtn.addEventListener('click', handleClearAllYDKFiles);
            if (UI.syncYDKFolderBtn) UI.syncYDKFolderBtn.addEventListener('click', selectYDKFolder);
            
            // Easter Egg Modal
            const editEasterEggBtn = document.getElementById('editEasterEggBtn');
            if (editEasterEggBtn) {
                console.log('Adding event listener to editEasterEggBtn');
                editEasterEggBtn.addEventListener('click', () => {
                    console.log('Edit Easter Egg button clicked!');
                    openEasterEggModal();
                });
            } else {
                console.error('editEasterEggBtn not found!');
                // Try again after a short delay
                setTimeout(() => {
                    const retryBtn = document.getElementById('editEasterEggBtn');
                    if (retryBtn) {
                        console.log('Found editEasterEggBtn on retry, adding event listener');
                        retryBtn.addEventListener('click', () => {
                            console.log('Edit Easter Egg button clicked!');
                            openEasterEggModal();
                        });
                    } else {
                        console.error('editEasterEggBtn still not found after retry');
                    }
                }, 100);
            }
            console.log('Easter egg modal elements:');
            console.log('easterEggModal:', UI.easterEggModal);
            console.log('easterEggModalClose:', UI.easterEggModalClose);
            console.log('editEasterEggBtn:', UI.editEasterEggBtn);
            
            if (UI.easterEggModalClose) UI.easterEggModalClose.addEventListener('click', closeEasterEggModal);
            if (UI.cancelEasterEggModalBtn) UI.cancelEasterEggModalBtn.addEventListener('click', closeEasterEggModal);
            if (UI.saveEasterEggPoolBtn) UI.saveEasterEggPoolBtn.addEventListener('click', saveEasterEggPool);
            if (UI.resetEasterEggPoolBtn) UI.resetEasterEggPoolBtn.addEventListener('click', resetEasterEggPool);
            // Easter Egg Clear All button - use direct element selection
            const clearEasterEggPoolBtn = document.getElementById('clearEasterEggPoolBtn');
            if (clearEasterEggPoolBtn) {
                console.log('Adding clear easter egg pool event listener');
                clearEasterEggPoolBtn.addEventListener('click', clearEasterEggPool);
            } else {
                console.error('clearEasterEggPoolBtn not found');
            }
            if (UI.addEasterEggCardBtn) UI.addEasterEggCardBtn.addEventListener('click', addCardToEasterEggPool);
            // Easter Egg Search - use direct element selection to avoid timing issues
            const easterEggSearchInput = document.getElementById('easterEggSearchInput');
            const easterEggSearchResults = document.getElementById('easterEggSearchResults');
            if (easterEggSearchInput && easterEggSearchResults) {
                console.log('Adding easter egg search event listeners');
                easterEggSearchInput.addEventListener('input', handleEasterEggSearch);
                easterEggSearchInput.addEventListener('keydown', handleEasterEggSearchKeydown);
                easterEggSearchInput.addEventListener('blur', () => {
                    // Delay hiding to allow click on autocomplete item
                    setTimeout(() => easterEggSearchResults.classList.add('hidden'), 200);
                });
                easterEggSearchInput.addEventListener('focus', handleEasterEggSearch);
            } else {
                console.error('Easter egg search elements not found:', {
                    input: easterEggSearchInput,
                    results: easterEggSearchResults
                });
            }
            
            UI.manageSidingBtn.addEventListener('click', openSidingPatternModal);
            UI.toggleExtraDeckBtn.addEventListener('click', toggleExtraDeck);
            UI.toggleSideDeckBtn.addEventListener('click', toggleSideDeck);
            UI.toggleDatabaseBtn.addEventListener('click', toggleDatabase);
            
            // Simulation
            UI.startSimBtn.addEventListener('click', startSimulation);
            UI.simPostSideModeToggle.addEventListener('change', (e) => {
                UI.postSideOptions.classList.toggle('hidden', !e.target.checked);
                updateTargetCardSelector();
            });
            UI.simModeSelector.addEventListener('change', (e) => {
                UI.standardSimOptions.classList.toggle('hidden', e.target.value === 'analyze');
            });
            document.querySelectorAll('input[name="siding-method"]').forEach(radio => {
                radio.addEventListener('change', () => {
                    document.getElementById('siding-pattern-options').style.display = radio.value === 'pattern' && radio.checked ? 'block' : 'none';
                    updateTargetCardSelector();
                });
            });
            UI.toggleNotesBtn.addEventListener('click', () => UI.notesSection.classList.toggle('hidden'));
            UI.deleteDraft.addEventListener('click', () => UI.trialNotes.value = '');
            UI.trialNotes.addEventListener('keydown', (e) => {
                if(e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    UI.trialNotes.blur();
                }
            });


            document.addEventListener('keydown', handleSimulationInput);

            // Report
            UI.exportReportBtn.addEventListener('click', exportReport);
            UI.aiReportAnalysisBtn.addEventListener('click', handleAiReportAnalysis);
            UI.rerunSimBtn.addEventListener('click', rerunSimulation);
            UI.generateAiEvaluatorBtn.addEventListener('click', generateAiEvaluator);
            UI.generatePromptBtn.addEventListener('click', generateStandardSimPrompt);
            UI.generateAiEvaluatorPromptBtn.addEventListener('click', generateAiEvaluatorPrompt);
            
            // Prompt Modal
            UI.promptModalClose.addEventListener('click', () => UI.promptModal.classList.add('hidden'));
            UI.copyPromptBtn.addEventListener('click', copyPromptToClipboard);
            UI.downloadPromptBtn.addEventListener('click', downloadPrompt);
            UI.promptModal.addEventListener('click', (e) => {
                if (e.target === UI.promptModal) UI.promptModal.classList.add('hidden');
            });


            // AI Training Mode
            UI.importAiEvaluatorInput.addEventListener('change', handleAiEvaluatorImport);
            UI.startAiTrainingBtn.addEventListener('click', startAiTrainingSimulation);

            // Shootout Mode
            UI.shootoutOpponentDeckInput.addEventListener('change', (e) => ShootoutManager.handleOpponentDeckYdk(e));
            UI.startShootoutBtn.addEventListener('click', () => ShootoutManager.start());
            UI.shootoutFinalizeSidingBtn.addEventListener('click', () => ShootoutManager.finalizeSiding());
            UI.shootoutJdgUserWinBtn.addEventListener('click', () => ShootoutManager.handleJudgment('user'));
            UI.shootoutJdgTieBtn.addEventListener('click', () => ShootoutManager.handleJudgment('tie'));
            UI.shootoutJdgOpponentWinBtn.addEventListener('click', () => ShootoutManager.handleJudgment('opponent'));
            UI.shootoutReportAnalyzeBtn.addEventListener('click', () => ShootoutManager.handleAnalysisPDF());
            document.getElementById('shootoutUndoBtn').addEventListener('click', () => ShootoutManager.undo());
            UI.shootoutReportContinueBtn.addEventListener('click', () => ShootoutManager.continue());
            UI.confirmContinueBtn.addEventListener('click', () => ShootoutManager.continue(true));
            UI.shootoutReportExportBtn.addEventListener('click', () => ShootoutManager.handleExportPDF());
            UI.shootoutReportAiBtn.addEventListener('click', () => ShootoutManager.handleAIAnalysis());
            UI.shootoutGeneratePromptBtn.addEventListener('click', generateShootoutPrompt);
            UI.drawShootoutCardBtn.addEventListener('click', () => ShootoutManager.drawCard());
            UI.searchDeckBtn.addEventListener('click', () => ShootoutManager.openSearchDeckModal());
            
            // Opponent actions
            document.getElementById('drawOpponentCardBtn').addEventListener('click', () => ShootoutManager.drawCard('opponent'));
            document.getElementById('searchOpponentDeckBtn').addEventListener('click', () => ShootoutManager.openSearchDeckModal('opponent'));

            // Shootout Drag and Drop
            const dropZones = document.querySelectorAll('.shootout-drop-zone');
            dropZones.forEach(zone => {
                zone.addEventListener('dragover', e => e.preventDefault());
                zone.addEventListener('dragenter', () => zone.classList.add('bg-blue-600/50', 'ring-2', 'ring-blue-400'));
                zone.addEventListener('dragleave', () => zone.classList.remove('bg-blue-600/50', 'ring-2', 'ring-blue-400'));
                zone.addEventListener('drop', e => {
                    e.preventDefault();
                    zone.classList.remove('bg-blue-600/50', 'ring-2', 'ring-blue-400');
                    const cardId = e.dataTransfer.getData('text/plain');
                    const player = e.dataTransfer.getData('text/player');
                    const action = zone.dataset.dropAction;
                    ShootoutManager.moveCard(cardId, player, action);
                });
            });


            // Modals
            UI.messageModalClose.addEventListener('click', () => UI.messageModal.classList.add('hidden'));
            UI.confirmModalCancel.addEventListener('click', () => { UI.confirmModal.classList.add('hidden'); confirmCallback = null; });
            UI.confirmModalConfirm.addEventListener('click', () => { if (confirmCallback) confirmCallback(); UI.confirmModal.classList.add('hidden'); confirmCallback = null; });
            UI.searchResultsClose.addEventListener('click', () => UI.searchResultsModal.classList.add('hidden'));
            UI.sidingPatternModalClose.addEventListener('click', () => UI.sidingPatternModal.classList.add('hidden'));
            UI.saveSidingPatternBtn.addEventListener('click', saveSidingPattern);
            UI.exportSidingPatternsBtn.addEventListener('click', exportSidingPatterns);
            UI.importSidingPatternsInput.addEventListener('change', importSidingPatterns);
            UI.searchDeckModalClose.addEventListener('click', () => UI.searchDeckModal.classList.add('hidden'));
            UI.apiKeyModalClose.addEventListener('click', () => UI.apiKeyModal.classList.add('hidden'));
            UI.saveApiKeyBtn.addEventListener('click', saveApiKeyFromModal);

            // Report Preview Modal
            document.getElementById('reportPreviewClose').addEventListener('click', () => {
                UI.reportPreviewModal.classList.add('hidden');
                document.getElementById('reportPreviewContent').innerHTML = ''; // Clean up
            });
            document.getElementById('reportPreviewDownload').addEventListener('click', () => {
                PDFManager.generateFromHTML(document.getElementById('reportPreviewContent'), 'shootout-report.pdf');
            });

            // DRAG-AND-DROP EVENT LISTENERS
            // Check if drag and drop listeners are already attached to prevent duplicates
            if (!UI.mainDeckList.dataset.dragListenersAttached) {
                [UI.mainDeckList, UI.sideDeckList, UI.extraDeckList].forEach(container => {
                    if (!container) return;
                    
                    container.addEventListener('dragover', e => {
                        e.preventDefault(); 
                        if (!placeholder) return; 

                        const afterElement = getDragAfterElement(container, e.clientX, e.clientY);
                        
                        if (afterElement == null) {
                            container.appendChild(placeholder);
                        } else {
                            container.insertBefore(placeholder, afterElement);
                        }
                    });

                    container.addEventListener('drop', e => {
                        e.preventDefault();
                        
                        // Don't handle drops when in immersion mode (immersion mode handles its own drops)
                        if (immersionMode.active) return;
                        
                        // Handle cards from grid (copy operation)
                        const cardId = e.dataTransfer.getData('text/plain');
                        if (cardId && cardDatabase.some(card => card.id === cardId)) {
                            const partName = container.id.replace('DeckList', '').toLowerCase();
                            addCardToDeck(cardId, partName);
                            return;
                        }
                        
                        // Handle existing deck cards (reorder operation)
                        if (!draggingElement || !placeholder) return;
                        
                        placeholder.parentNode.replaceChild(draggingElement, placeholder);
                        placeholder = null;

                        updateDeckOrder();
                    });
                    
                    // Mark this container as having drag listeners attached
                    container.dataset.dragListenersAttached = 'true';
                });
            }
            
            // SELECTION MODE EVENT LISTENERS
            document.addEventListener('keydown', handleSelectionKeydown);
            document.addEventListener('click', handleSelectionClick);
        }

        // --- VIEW MANAGEMENT ---
        function showView(viewId) {
            // Exit selection mode when leaving deck builder view
            if (viewId !== 'deckBuilderView' && selectionMode.active) {
                exitSelectionMode();
            }
            
            ['deckBuilderView', 'simulationView', 'reportView', 'aiTrainingView', 'shootoutView', 'shootoutSidingView', 'shootoutSimulatorView', 'shootoutReportView'].forEach(id => {
                const view = document.getElementById(id);
                if (view) view.classList.add('hidden');
            });
            const activeView = document.getElementById(viewId);
            if (activeView) activeView.classList.remove('hidden');

            UI.navDeckBuilder.classList.toggle('bg-[var(--color-primary)]', viewId === 'deckBuilderView');
            UI.navSimulator.classList.toggle('bg-[var(--color-primary)]', ['simulationView', 'reportView'].includes(viewId));
            UI.navAiTraining.classList.toggle('bg-[var(--color-primary)]', viewId === 'aiTrainingView');
            UI.navShootout.classList.toggle('bg-[var(--color-primary)]', ['shootoutView', 'shootoutSidingView', 'shootoutSimulatorView', 'shootoutReportView'].includes(viewId)); // MODIFIED

        }

        // --- MODAL DIALOGS ---
        function showMessage(text) {
            UI.messageModalText.textContent = text;
            UI.messageModal.classList.remove('hidden');
        }

        // --- TOOLTIP SYSTEM ---
        function showTooltip(text, duration = 3000) {
            // Remove any existing tooltip
            const existingTooltip = document.getElementById('tooltip');
            if (existingTooltip) {
                existingTooltip.remove();
            }

            // Create tooltip element
            const tooltip = document.createElement('div');
            tooltip.id = 'tooltip';
            tooltip.textContent = text;
            tooltip.className = 'fixed top-4 right-4 bg-green-600 text-white px-4 py-2 rounded-lg shadow-lg z-50 transform transition-all duration-300 ease-in-out';
            tooltip.style.opacity = '0';
            tooltip.style.transform = 'translateY(-10px)';
            
            document.body.appendChild(tooltip);

            // Animate in
            requestAnimationFrame(() => {
                tooltip.style.opacity = '1';
                tooltip.style.transform = 'translateY(0)';
            });

            // Auto-dismiss
            setTimeout(() => {
                tooltip.style.opacity = '0';
                tooltip.style.transform = 'translateY(-10px)';
                setTimeout(() => {
                    if (tooltip.parentNode) {
                        tooltip.parentNode.removeChild(tooltip);
                    }
                }, 300);
            }, duration);
        }

        function showConfirmModal(text, onConfirm) {
            UI.confirmModalText.textContent = text;
            confirmCallback = onConfirm;
            UI.confirmModal.classList.remove('hidden');
        }

        // --- CARD DATABASE LOGIC ---
        let isDatabaseLoaded = false; // Prevent multiple loads
        
        async function loadCardDatabase() {
            if (isDatabaseLoaded) {
                console.log('Database already loaded, skipping duplicate load');
                return;
            }
            
            if (isOffline) {
                // In offline mode, load from localStorage
                try {
                    const savedCards = JSON.parse(localStorage.getItem('offlineCardDatabase') || '[]');
                    console.log(`loadCardDatabase: Found ${savedCards.length} cards in localStorage`);
                    
                    // Deduplicate cards by ID
                    const uniqueCards = [];
                    const seenIds = new Set();
                    let dupCount = 0;
                    for (const card of savedCards) {
                        if (!seenIds.has(card.id)) {
                            seenIds.add(card.id);
                            uniqueCards.push(card);
                        } else {
                            dupCount++;
                        }
                    }
                    
                    cardDatabase = uniqueCards;
                    originalCardDatabase = [...uniqueCards]; // Store backup of full database
                    console.log(`[DEBUG] Offline: Stored ${originalCardDatabase.length} cards in original database`);
                    cardDatabase.sort((a, b) => a.name.localeCompare(b.name));
                    
                    // Save the deduplicated database back to localStorage
                    if (uniqueCards.length !== savedCards.length) {
                        console.log(`loadCardDatabase: Removed ${dupCount} duplicate cards from database`);
                        localStorage.setItem('offlineCardDatabase', JSON.stringify(uniqueCards));
                    } else {
                        console.log(`loadCardDatabase: No duplicates found`);
                    }
                    
                    isDatabaseLoaded = true; // Mark as loaded
                    renderCardDatabase();
                    populateSimulationSetup();
                    console.log(`loadCardDatabase: Loaded ${cardDatabase.length} unique cards into memory.`);
                } catch(e) {
                    console.error("Error loading offline card database:", e);
                    cardDatabase = [];
                    renderCardDatabase();
                }
                return;
            }
            
            if (!userId) return;
            const cardDbRef = collection(db, `artifacts/${appId}/users/${userId}/cards`);
            onSnapshot(query(cardDbRef), 
                (snapshot) => {
                    const tempCards = [];
                    snapshot.forEach(doc => tempCards.push({ id: doc.id, ...doc.data() }));
                    
                    // Deduplicate cards by ID (safety check)
                    const uniqueCards = [];
                    const seenIds = new Set();
                    for (const card of tempCards) {
                        if (!seenIds.has(card.id)) {
                            seenIds.add(card.id);
                            uniqueCards.push(card);
                        }
                    }
                    
                    cardDatabase = uniqueCards;
                    originalCardDatabase = [...uniqueCards]; // Store backup of full database
                    console.log(`[DEBUG] Online: Stored ${originalCardDatabase.length} cards in original database`);
                    cardDatabase.sort((a, b) => a.name.localeCompare(b.name));
                    isDatabaseLoaded = true; // Mark as loaded
                    renderCardDatabase();
                    populateSimulationSetup();
                },
                (error) => {
                    console.error("Error loading card database:", error);
                    // This handles cases where the database is not yet fully provisioned.
                    showMessage(`Could not load card database: ${error.code}. The database might still be initializing. Please wait a few minutes and refresh.`);
            });
        }

        // --- AUTOCOMPLETE FUNCTIONS ---
        async function handleAutocomplete() {
            const searchTerm = UI.cardSearchInput.value.trim().toLowerCase();
            
            if (autocompleteMode === 'db') {
                // In DB mode, filter the database list directly instead of showing dropdown
                filterDatabaseList(searchTerm);
                hideAutocomplete();
                return;
            }
            
            // For "All" mode, show dropdown as before
            if (!searchTerm) {
                hideAutocomplete();
                return;
            }
            
            let matches = [];
            
            // Filter from all cards (excluding extra deck)
            if (allCardsCache.length === 0) {
                // Fetch all cards from API if not cached
                await fetchAllCards();
            }
            
            matches = allCardsCache
                .filter(card => card.name.toLowerCase().includes(searchTerm))
                .slice(0, 10); // Limit to 10 suggestions
            
            if (matches.length === 0) {
                hideAutocomplete();
                return;
            }
            
            // Store matches for space key shortcut
            lastAutocompleteMatches = matches;
            
            // Display autocomplete suggestions
            UI.cardAutocompleteList.innerHTML = '';
            matches.forEach((card, index) => {
                const item = document.createElement('div');
                item.className = 'autocomplete-item px-3 py-2 cursor-pointer hover:bg-slate-700 transition-colors';
                item.textContent = card.name;
                item.dataset.index = index;
                item.dataset.cardName = card.name;
                
                item.addEventListener('click', () => {
                    selectAutocompleteItem(card.name);
                });
                
                UI.cardAutocompleteList.appendChild(item);
            });
            
            // Add tooltip at the bottom
            const tooltip = document.createElement('div');
            tooltip.className = 'px-3 py-2 text-xs text-slate-400 border-t border-slate-700 flex items-center gap-2';
            tooltip.innerHTML = '<kbd class="px-1.5 py-0.5 bg-slate-700 rounded text-xs border border-slate-600">Tab</kbd> to cycle  <kbd class="px-1.5 py-0.5 bg-slate-700 rounded text-xs border border-slate-600">Enter</kbd> to add';
            UI.cardAutocompleteList.appendChild(tooltip);
            
            UI.cardAutocompleteList.classList.remove('hidden');
            autocompleteSelectedIndex = -1;
        }
        
        function filterDatabaseList(searchTerm) {
            const cards = UI.cardDbList.querySelectorAll('[data-card-id]');
            
            cards.forEach(cardEl => {
                let cardName = '';
                
                // Get card name based on current view mode
                if (cardDatabaseView === 'grid') {
                    // In grid view, card name is in the title attribute of the image
                    const img = cardEl.querySelector('img');
                    cardName = img ? img.getAttribute('title').toLowerCase() : '';
                } else {
                    // In list view, card name is in the span element
                    const span = cardEl.querySelector('span');
                    cardName = span ? span.textContent.toLowerCase() : '';
                }
                
                const matches = !searchTerm || cardName.includes(searchTerm);
                
                if (matches) {
                    cardEl.style.display = cardDatabaseView === 'grid' ? 'block' : 'flex';
                } else {
                    cardEl.style.display = 'none';
                }
            });
        }
        
        async function fetchAllCards() {
            try {
                const response = await fetch('https://db.ygoprodeck.com/api/v7/cardinfo.php');
                if (!response.ok) throw new Error('Failed to fetch all cards');
                
                const data = await response.json();
                // Filter out extra deck cards (Link, Fusion, Synchro, XYZ)
                allCardsCache = data.data
                    .filter(c => !c.type.includes('Link') && 
                                !c.type.includes('Fusion') && 
                                !c.type.includes('Synchro') && 
                                !c.type.includes('XYZ'))
                    .map(c => ({ id: c.id.toString(), name: c.name, type: c.type }));
                
                console.log(`Loaded ${allCardsCache.length} cards for autocomplete`);
            } catch (error) {
                console.error('Error fetching all cards:', error);
                showTooltip('Failed to load all cards for autocomplete');
            }
        }
        
        // --- ADVANCED CARD SEARCH FUNCTIONS ---
        
        async function fetchFullCardDatabase() {
            if (advancedSearchState.allCards.length > 0) {
                console.log('Card database already loaded');
                return;
            }
            
            try {
                UI.loadingOverlay.classList.remove('hidden');
                const response = await fetch('https://db.ygoprodeck.com/api/v7/cardinfo.php');
                if (!response.ok) throw new Error('Failed to fetch card database');
                
                const data = await response.json();
                // Keep all cards including extra deck for advanced search
                advancedSearchState.allCards = data.data.map(card => ({
                    id: card.id.toString(),
                    name: card.name,
                    desc: card.desc || '',
                    type: card.type,
                    race: card.race || '',
                    attribute: card.attribute || '',
                    level: card.level || null,
                    atk: card.atk !== undefined ? card.atk : null,
                    def: card.def !== undefined ? card.def : null,
                    tcgDate: card.misc_info && card.misc_info[0] ? card.misc_info[0].tcg_date : null,
                    ocgDate: card.misc_info && card.misc_info[0] ? card.misc_info[0].ocg_date : null,
                    imageUrl: card.card_images[0].image_url,
                    imageUrlSmall: card.card_images[0].image_url_small
                }));
                
                // Load custom banlist from localStorage
                try {
                    const saved = localStorage.getItem('customBanlist');
                    if (saved) {
                        customBanlist = JSON.parse(saved);
                    }
                } catch (e) {
                    console.error('Error loading custom banlist:', e);
                }
                
                console.log(`Loaded ${advancedSearchState.allCards.length} cards for advanced search`);
                showTooltip(`Loaded ${advancedSearchState.allCards.length} cards`);
            } catch (error) {
                console.error('Error fetching full card database:', error);
                showMessage('Failed to load card database for advanced search');
            } finally {
                UI.loadingOverlay.classList.add('hidden');
            }
        }
        
        function openAdvancedSearchModal() {
            UI.advancedSearchModal.classList.remove('hidden');
            if (advancedSearchState.allCards.length === 0) {
                fetchFullCardDatabase();
            }
            updateAdvancedSearchUI();
        }
        
        function closeAdvancedSearchModal() {
            UI.advancedSearchModal.classList.add('hidden');
        }
        
        function updateAdvancedSearchUI() {
            // Update card type subtype options based on selected type
            const cardType = advancedSearchState.filters.cardType;
            UI.advSearchCardSubtype.innerHTML = '<option value="">All Subtypes</option>';
            
            if (cardType === 'monster') {
                UI.advSearchCardSubtype.innerHTML += `
                    <option value="Effect Monster">Effect Monster</option>
                    <option value="Normal Monster">Normal Monster</option>
                    <option value="Ritual Monster">Ritual Monster</option>
                    <option value="Pendulum Effect Monster">Pendulum Effect Monster</option>
                `;
                // Show monster-specific filters
                document.getElementById('advSearchMonsterTypeContainer').style.display = 'block';
                document.getElementById('advSearchAttributeContainerWrapper').style.display = 'block';
                document.getElementById('advSearchMonsterSubtypeContainerWrapper').style.display = 'block';
                document.getElementById('advSearchLevelContainer').style.display = 'block';
                document.getElementById('advSearchAtkContainer').style.display = 'block';
                document.getElementById('advSearchDefContainer').style.display = 'block';
            } else if (cardType === 'spell') {
                UI.advSearchCardSubtype.innerHTML += `
                    <option value="Normal">Normal</option>
                    <option value="Continuous">Continuous</option>
                    <option value="Quick-Play">Quick-Play</option>
                    <option value="Field">Field</option>
                    <option value="Equip">Equip</option>
                    <option value="Ritual">Ritual</option>
                `;
                // Hide monster-specific filters
                document.getElementById('advSearchMonsterTypeContainer').style.display = 'none';
                document.getElementById('advSearchAttributeContainerWrapper').style.display = 'none';
                document.getElementById('advSearchMonsterSubtypeContainerWrapper').style.display = 'none';
                document.getElementById('advSearchLevelContainer').style.display = 'none';
                document.getElementById('advSearchAtkContainer').style.display = 'none';
                document.getElementById('advSearchDefContainer').style.display = 'none';
            } else if (cardType === 'trap') {
                UI.advSearchCardSubtype.innerHTML += `
                    <option value="Normal">Normal</option>
                    <option value="Continuous">Continuous</option>
                    <option value="Counter">Counter</option>
                `;
                // Hide monster-specific filters
                document.getElementById('advSearchMonsterTypeContainer').style.display = 'none';
                document.getElementById('advSearchAttributeContainerWrapper').style.display = 'none';
                document.getElementById('advSearchMonsterSubtypeContainerWrapper').style.display = 'none';
                document.getElementById('advSearchLevelContainer').style.display = 'none';
                document.getElementById('advSearchAtkContainer').style.display = 'none';
                document.getElementById('advSearchDefContainer').style.display = 'none';
            } else {
                // Show all filters when no type selected
                document.getElementById('advSearchMonsterTypeContainer').style.display = 'block';
                document.getElementById('advSearchAttributeContainerWrapper').style.display = 'block';
                document.getElementById('advSearchMonsterSubtypeContainerWrapper').style.display = 'block';
                document.getElementById('advSearchLevelContainer').style.display = 'block';
                document.getElementById('advSearchAtkContainer').style.display = 'block';
                document.getElementById('advSearchDefContainer').style.display = 'block';
            }
        }
        
        function applyAdvancedFilters() {
            const filters = advancedSearchState.filters;
            let filtered = [...advancedSearchState.allCards];
            
            // Text search (name and description)
            if (filters.text) {
                const searchText = filters.text.toLowerCase();
                filtered = filtered.filter(card => 
                    card.name.toLowerCase().includes(searchText) || 
                    card.desc.toLowerCase().includes(searchText)
                );
            }
            
            // Card type filter
            if (filters.cardType) {
                if (filters.cardType === 'monster') {
                    filtered = filtered.filter(card => card.type.includes('Monster'));
                } else if (filters.cardType === 'spell') {
                    filtered = filtered.filter(card => card.type.includes('Spell'));
                } else if (filters.cardType === 'trap') {
                    filtered = filtered.filter(card => card.type.includes('Trap'));
                }
            }
            
            // Card subtype filter
            if (filters.cardSubtype) {
                filtered = filtered.filter(card => card.type.includes(filters.cardSubtype));
            }
            
            // Monster type (race) filter
            if (filters.monsterType.length > 0) {
                filtered = filtered.filter(card => 
                    filters.monsterType.some(race => card.race === race)
                );
            }
            
            // Monster subtype (abilities) filter
            if (filters.monsterSubtype.length > 0) {
                filtered = filtered.filter(card => 
                    filters.monsterSubtype.every(subtype => card.type.includes(subtype))
                );
            }
            
            // Attribute filter
            if (filters.attribute.length > 0) {
                filtered = filtered.filter(card => 
                    filters.attribute.includes(card.attribute)
                );
            }
            
            // Level/Rank range filter
            if (filters.levelMin > 0 || filters.levelMax < 12) {
                filtered = filtered.filter(card => {
                    if (card.level === null) return false;
                    return card.level >= filters.levelMin && card.level <= filters.levelMax;
                });
            }
            
            // ATK range filter
            if (filters.atkMin !== null) {
                filtered = filtered.filter(card => card.atk !== null && card.atk >= filters.atkMin);
            }
            if (filters.atkMax !== null) {
                filtered = filtered.filter(card => card.atk !== null && card.atk <= filters.atkMax);
            }
            
            // DEF range filter
            if (filters.defMin !== null) {
                filtered = filtered.filter(card => card.def !== null && card.def >= filters.defMin);
            }
            if (filters.defMax !== null) {
                filtered = filtered.filter(card => card.def !== null && card.def <= filters.defMax);
            }
            
            // Banlist status filter
            if (filters.banlistStatus.length > 0) {
                filtered = filtered.filter(card => {
                    const status = customBanlist[card.id] || 'unlimited';
                    return filters.banlistStatus.includes(status);
                });
            }
            
            // Sort results
            filtered.sort((a, b) => {
                if (advancedSearchState.sort.by === 'name') {
                    const nameA = a.name.toLowerCase();
                    const nameB = b.name.toLowerCase();
                    return advancedSearchState.sort.order === 'asc' 
                        ? nameA.localeCompare(nameB)
                        : nameB.localeCompare(nameA);
                } else if (advancedSearchState.sort.by === 'releaseDate') {
                    const dateA = a.tcgDate || a.ocgDate || '9999-99-99';
                    const dateB = b.tcgDate || b.ocgDate || '9999-99-99';
                    return advancedSearchState.sort.order === 'asc'
                        ? dateA.localeCompare(dateB)
                        : dateB.localeCompare(dateA);
                }
                return 0;
            });
            
            advancedSearchState.results = filtered;
            advancedSearchState.pagination.page = 1;
            renderAdvancedSearchResults();
        }
        
        function renderAdvancedSearchResults() {
            const { results, pagination, view } = advancedSearchState;
            const { page, perPage } = pagination;
            
            // Update results count
            UI.advSearchResultsCount.textContent = results.length;
            
            // Calculate pagination
            const totalPages = Math.ceil(results.length / perPage);
            const startIdx = (page - 1) * perPage;
            const endIdx = startIdx + perPage;
            const pageResults = results.slice(startIdx, endIdx);
            
            // Update pagination UI
            UI.advSearchPageDisplay.textContent = `Page ${page} of ${totalPages || 1}`;
            UI.advSearchPrevPage.disabled = page <= 1;
            UI.advSearchNextPage.disabled = page >= totalPages;
            
            // Clear and render results
            UI.advSearchResultsContainer.innerHTML = '';
            
            // Always update className based on view state
            if (view === 'grid') {
                UI.advSearchResultsContainer.className = 'flex-1 overflow-y-auto pr-2 mb-4 grid grid-cols-4 xl:grid-cols-6 gap-3';
            } else {
                UI.advSearchResultsContainer.className = 'flex-1 overflow-y-auto pr-2 mb-4 space-y-2';
            }
            
            if (results.length === 0) {
                UI.advSearchResultsContainer.innerHTML = '<p class="text-center text-slate-400 mt-20">No cards found matching your filters</p>';
                return;
            }
            
            if (view === 'grid') {
                pageResults.forEach((card, index) => {
                    const cardEl = document.createElement('div');
                    cardEl.className = 'relative group cursor-pointer';
                    cardEl.dataset.cardIndex = startIdx + index;
                    cardEl.dataset.cardId = card.id;
                    
                    // Check if TCG-only unreleased (OCG exists but not TCG)
                    const isOCGOnly = !card.tcgDate && card.ocgDate;
                    const banlistStatus = customBanlist[card.id];
                    
                    cardEl.innerHTML = `
                        <img src="${card.imageUrlSmall}" 
                             class="w-full h-auto rounded-md hover:scale-105 transition-transform" 
                             title="${card.name}"
                             onerror="this.onerror=null;this.src='https://placehold.co/120x168/2d3748/e2e8f0?text=?';">
                        ${isOCGOnly ? '<div class="absolute top-1 right-1 bg-blue-600 text-white text-xs font-bold px-2 py-1 rounded">OCG</div>' : ''}
                        ${banlistStatus && banlistStatus !== 'unlimited' ? `<div class="absolute top-1 left-1 bg-red-600 text-white text-xs font-bold px-2 py-1 rounded uppercase">${banlistStatus}</div>` : ''}
                    `;
                    
                    // Left click - activate selection mode and select card
                    cardEl.addEventListener('click', (e) => {
                        e.stopPropagation();
                        activateSelectionMode(startIdx + index, card);
                    });
                    
                    // Right click - add to database
                    cardEl.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        addCardFromAdvancedSearch(card);
                    });
                    
                    // Hover - update card info panel
                    cardEl.addEventListener('mouseenter', () => {
                        updateCardInfoPanel(card);
                    });
                    
                    UI.advSearchResultsContainer.appendChild(cardEl);
                });
            } else {
                pageResults.forEach((card, index) => {
                    const cardEl = document.createElement('div');
                    cardEl.className = 'p-3 flex items-center justify-between bg-[var(--color-surface-2)]/50 rounded-lg hover:bg-[var(--color-surface-2)] transition-colors cursor-pointer';
                    cardEl.dataset.cardIndex = startIdx + index;
                    cardEl.dataset.cardId = card.id;
                    
                    const isOCGOnly = !card.tcgDate && card.ocgDate;
                    const banlistStatus = customBanlist[card.id];
                    
                    cardEl.innerHTML = `
                        <div class="flex items-center gap-3 overflow-hidden">
                            <img src="${card.imageUrlSmall}" class="w-12 h-auto rounded-md flex-shrink-0" onerror="this.onerror=null;this.src='https://placehold.co/48x67/2d3748/e2e8f0?text=?';">
                            <div class="flex flex-col overflow-hidden">
                                <span class="text-sm font-medium truncate">${card.name}</span>
                                <span class="text-xs text-slate-400">${card.type}${isOCGOnly ? '  OCG Only' : ''}</span>
                            </div>
                        </div>
                        <div class="flex items-center gap-2">
                            ${banlistStatus && banlistStatus !== 'unlimited' ? `<span class="text-xs bg-red-600 px-2 py-1 rounded uppercase">${banlistStatus}</span>` : ''}
                        </div>
                    `;
                    
                    // Left click - activate selection mode and select card
                    cardEl.addEventListener('click', (e) => {
                        e.stopPropagation();
                        activateSelectionMode(startIdx + index, card);
                    });
                    
                    // Right click - add to database
                    cardEl.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        addCardFromAdvancedSearch(card);
                    });
                    
                    // Hover - update card info panel
                    cardEl.addEventListener('mouseenter', () => {
                        updateCardInfoPanel(card);
                    });
                    
                    UI.advSearchResultsContainer.appendChild(cardEl);
                });
            }
        }
        
        async function addCardFromAdvancedSearch(card) {
            // Check if card already exists in database
            if (cardDatabase.some(c => c.id === card.id)) {
                showTooltip(`'${card.name}' is already in the database.`);
                return;
            }
            
            // Format the card data to match what addCardToDatabase expects
            const cardData = {
                id: card.id,
                name: card.name,
                type: card.type,
                card_images: [{
                    image_url: card.imageUrl
                }]
            };
            
            await addCardToDatabase(cardData);
        }
        
        function toggleCardInfoPanel() {
            advancedSearchState.cardInfo.visible = !advancedSearchState.cardInfo.visible;
            if (advancedSearchState.cardInfo.visible) {
                UI.advSearchCardInfoPanel.classList.remove('hidden');
                UI.advSearchCardInfoToggle.textContent = 'Hide Info';
            } else {
                UI.advSearchCardInfoPanel.classList.add('hidden');
                UI.advSearchCardInfoToggle.textContent = 'Show Info';
            }
        }
        
        function updateCardInfoPanel(card) {
            if (!card) {
                UI.advSearchCardInfoContent.innerHTML = '<p class="text-center text-slate-400 mt-20">Hover over a card to see details</p>';
                return;
            }
            
            advancedSearchState.cardInfo.currentCard = card;
            
            const isOCGOnly = !card.tcgDate && card.ocgDate;
            const banlistStatus = customBanlist[card.id];
            
            const atkDef = card.atk !== null && card.def !== null ? `${card.atk} / ${card.def}` : '';
            const level = card.level !== null ? `Level/Rank: ${card.level}` : '';
            const attribute = card.attribute || '';
            
            UI.advSearchCardInfoContent.innerHTML = `
                <div class="flex flex-col h-full">
                    <div class="flex-shrink-0 mb-4">
                        <img src="${card.imageUrl}" 
                             class="w-full h-auto rounded-md shadow-lg" 
                             onerror="this.onerror=null;this.src='https://placehold.co/300x432/2d3748/e2e8f0?text=?';">
                    </div>
                    <div class="flex-1 overflow-y-auto">
                        <h3 class="text-xl font-bold mb-2">${card.name}</h3>
                        <div class="space-y-2 text-sm">
                            <div class="flex justify-between items-center">
                                <span class="text-slate-400">Type:</span>
                                <span class="font-medium">${card.type}</span>
                            </div>
                            ${attribute ? `<div class="flex justify-between items-center">
                                <span class="text-slate-400">Attribute:</span>
                                <span class="font-medium">${attribute}</span>
                            </div>` : ''}
                            ${level ? `<div class="flex justify-between items-center">
                                <span class="text-slate-400">${level.split(':')[0]}:</span>
                                <span class="font-medium">${level.split(': ')[1]}</span>
                            </div>` : ''}
                            ${atkDef ? `<div class="flex justify-between items-center">
                                <span class="text-slate-400">ATK / DEF:</span>
                                <span class="font-medium">${atkDef}</span>
                            </div>` : ''}
                            ${banlistStatus && banlistStatus !== 'unlimited' ? `<div class="flex justify-between items-center">
                                <span class="text-slate-400">Banlist:</span>
                                <span class="font-medium text-red-400 uppercase">${banlistStatus}</span>
                            </div>` : ''}
                            ${isOCGOnly ? `<div class="flex justify-between items-center">
                                <span class="text-slate-400">Status:</span>
                                <span class="font-medium text-blue-400">OCG Only</span>
                            </div>` : ''}
                        </div>
                        <div class="mt-4 pt-4 border-t border-[var(--color-border)]">
                            <p class="text-xs text-slate-300 leading-relaxed">${card.desc}</p>
                        </div>
                    </div>
                </div>
            `;
        }
        
        function activateSelectionMode(index, card) {
            advancedSearchState.selection.active = true;
            advancedSearchState.selection.selectedIndex = index;
            advancedSearchState.selection.selectedCardId = card.id;
            updateSelectedCardUI();
            updateCardInfoPanel(card);
        }
        
        function deactivateSelectionMode() {
            advancedSearchState.selection.active = false;
            advancedSearchState.selection.selectedIndex = -1;
            advancedSearchState.selection.selectedCardId = null;
            updateSelectedCardUI();
        }
        
        function updateSelectedCardUI() {
            // Remove selection from all cards
            const allCards = UI.advSearchResultsContainer.querySelectorAll('[data-card-index]');
            allCards.forEach(el => {
                el.classList.remove('ring-4', 'ring-blue-500', 'ring-offset-2', 'ring-offset-slate-800');
            });
            
            // Add selection to current card
            if (advancedSearchState.selection.active && advancedSearchState.selection.selectedIndex >= 0) {
                const selectedCard = UI.advSearchResultsContainer.querySelector(`[data-card-index="${advancedSearchState.selection.selectedIndex}"]`);
                if (selectedCard) {
                    selectedCard.classList.add('ring-4', 'ring-blue-500', 'ring-offset-2', 'ring-offset-slate-800');
                    scrollToSelectedCard(selectedCard);
                }
            }
        }
        
        function scrollToSelectedCard(cardElement) {
            if (cardElement) {
                cardElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }
        
        function handleAdvancedSearchKeydown(e) {
            // Only handle if modal is open and there are results
            if (UI.advancedSearchModal.classList.contains('hidden') || advancedSearchState.results.length === 0) {
                return;
            }
            
            const { results, pagination, view } = advancedSearchState;
            const { page, perPage } = pagination;
            const startIdx = (page - 1) * perPage;
            const endIdx = Math.min(startIdx + perPage, results.length);
            const pageResultsCount = endIdx - startIdx;
            
            // Arrow keys
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault();
                
                // Activate selection mode on first arrow key press
                if (!advancedSearchState.selection.active) {
                    activateSelectionMode(startIdx, results[startIdx]);
                    return;
                }
                
                let currentLocalIndex = advancedSearchState.selection.selectedIndex - startIdx;
                let newLocalIndex = currentLocalIndex;
                
                if (view === 'grid') {
                    // Calculate grid columns (4 or 6 depending on screen size)
                    const gridCols = window.innerWidth >= 1280 ? 6 : 4;
                    
                    if (e.key === 'ArrowLeft') {
                        newLocalIndex = Math.max(0, currentLocalIndex - 1);
                    } else if (e.key === 'ArrowRight') {
                        newLocalIndex = Math.min(pageResultsCount - 1, currentLocalIndex + 1);
                    } else if (e.key === 'ArrowUp') {
                        newLocalIndex = Math.max(0, currentLocalIndex - gridCols);
                    } else if (e.key === 'ArrowDown') {
                        newLocalIndex = Math.min(pageResultsCount - 1, currentLocalIndex + gridCols);
                    }
                } else {
                    // List view - simple up/down navigation
                    if (e.key === 'ArrowUp') {
                        newLocalIndex = Math.max(0, currentLocalIndex - 1);
                    } else if (e.key === 'ArrowDown') {
                        newLocalIndex = Math.min(pageResultsCount - 1, currentLocalIndex + 1);
                    }
                }
                
                const newGlobalIndex = startIdx + newLocalIndex;
                const newCard = results[newGlobalIndex];
                
                if (newCard) {
                    advancedSearchState.selection.selectedIndex = newGlobalIndex;
                    advancedSearchState.selection.selectedCardId = newCard.id;
                    updateSelectedCardUI();
                    updateCardInfoPanel(newCard);
                }
            }
        }
        
        function resetAdvancedSearchFilters() {
            advancedSearchState.filters = {
                text: '',
                cardType: null,
                cardSubtype: null,
                monsterType: [],
                monsterSubtype: [],
                attribute: [],
                levelMin: 0,
                levelMax: 12,
                atkMin: null,
                atkMax: null,
                defMin: null,
                defMax: null,
                banlistStatus: [],
            };
            advancedSearchState.sort = { by: 'name', order: 'asc' };
            advancedSearchState.pagination.page = 1;
            advancedSearchState.results = [];
            
            // Reset UI
            UI.advSearchTextInput.value = '';
            UI.advSearchCardType.value = '';
            UI.advSearchCardSubtype.value = '';
            UI.advSearchMonsterType.querySelectorAll('option').forEach(opt => opt.selected = false);
            UI.advSearchAttributeContainer.querySelectorAll('button').forEach(btn => {
                btn.classList.remove('bg-blue-600', 'border-blue-400');
                btn.classList.add('bg-slate-700');
            });
            UI.advSearchMonsterSubtypeContainer.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);
            UI.advSearchLevelMin.value = '0';
            UI.advSearchLevelMax.value = '12';
            UI.advSearchLevelDisplay.textContent = '0 - 12';
            UI.advSearchAtkMin.value = '';
            UI.advSearchAtkMax.value = '';
            UI.advSearchDefMin.value = '';
            UI.advSearchDefMax.value = '';
            UI.advSearchBanlistContainer.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);
            UI.advSearchSortBy.value = 'name';
            UI.advSearchSortOrder.value = 'asc';
            
            UI.advSearchResultsContainer.innerHTML = '<p class="text-center text-slate-400 mt-20">Click "Apply Filters" to search</p>';
            UI.advSearchResultsCount.textContent = '0';
            
            updateAdvancedSearchUI();
        }
        
        // --- BANLIST MANAGEMENT FUNCTIONS ---
        
        function openBanlistModal() {
            UI.banlistModal.classList.remove('hidden');
            UI.banlistSearchInput.value = '';
            UI.banlistSearchResults.innerHTML = '<p class="text-center text-slate-400 mt-20">Search for cards to manage their banlist status</p>';
        }
        
        function closeBanlistModal() {
            UI.banlistModal.classList.add('hidden');
        }
        
        async function searchCardsForBanlist(searchTerm) {
            if (!searchTerm || searchTerm.length < 2) {
                UI.banlistSearchResults.innerHTML = '<p class="text-center text-slate-400 mt-20">Enter at least 2 characters to search</p>';
                return;
            }
            
            const searchLower = searchTerm.toLowerCase();
            const matches = advancedSearchState.allCards.filter(card => 
                card.name.toLowerCase().includes(searchLower)
            ).slice(0, 50); // Limit to 50 results
            
            UI.banlistSearchResults.innerHTML = '';
            
            if (matches.length === 0) {
                UI.banlistSearchResults.innerHTML = '<p class="text-center text-slate-400">No cards found</p>';
                return;
            }
            
            matches.forEach(card => {
                const cardEl = document.createElement('div');
                cardEl.className = 'p-3 flex items-center justify-between bg-[var(--color-surface-2)]/50 rounded-lg';
                
                const currentStatus = customBanlist[card.id] || 'unlimited';
                
                cardEl.innerHTML = `
                    <div class="flex items-center gap-3 overflow-hidden">
                        <img src="${card.imageUrlSmall}" class="w-10 h-auto rounded-md flex-shrink-0" onerror="this.onerror=null;this.src='https://placehold.co/40x56/2d3748/e2e8f0?text=?';">
                        <span class="text-sm font-medium">${card.name}</span>
                    </div>
                    <select data-card-id="${card.id}" class="banlist-status-select bg-slate-700 border border-[var(--color-border)] rounded-md px-2 py-1 text-sm">
                        <option value="unlimited" ${currentStatus === 'unlimited' ? 'selected' : ''}>Unlimited</option>
                        <option value="semi-limited" ${currentStatus === 'semi-limited' ? 'selected' : ''}>Semi-Limited</option>
                        <option value="limited" ${currentStatus === 'limited' ? 'selected' : ''}>Limited</option>
                        <option value="forbidden" ${currentStatus === 'forbidden' ? 'selected' : ''}>Forbidden</option>
                    </select>
                `;
                
                const select = cardEl.querySelector('select');
                select.addEventListener('change', (e) => {
                    customBanlist[card.id] = e.target.value;
                });
                
                UI.banlistSearchResults.appendChild(cardEl);
            });
        }
        
        function saveBanlist() {
            try {
                localStorage.setItem('customBanlist', JSON.stringify(customBanlist));
                showTooltip('Banlist saved successfully');
                closeBanlistModal();
            } catch (e) {
                console.error('Error saving banlist:', e);
                showMessage('Failed to save banlist');
            }
        }
        
        function resetBanlist() {
            if (confirm('Are you sure you want to reset all banlist statuses to unlimited?')) {
                customBanlist = {};
                localStorage.removeItem('customBanlist');
                showTooltip('Banlist reset successfully');
                UI.banlistSearchInput.value = '';
                UI.banlistSearchResults.innerHTML = '<p class="text-center text-slate-400 mt-20">Search for cards to manage their banlist status</p>';
            }
        }
        
        function toggleAutocompleteMode() {
            autocompleteMode = autocompleteMode === 'db' ? 'all' : 'db';
            const modeText = autocompleteMode === 'db' ? 'DB' : 'All';
            UI.autocompleteModeToggle.innerHTML = `<svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.207A1 1 0 013 6.5V4z"></path></svg>Autocomplete: <span class="text-[var(--color-primary)]">${modeText}</span>`;
            
            // Clear search and reset database view when switching modes
            UI.cardSearchInput.value = '';
            hideAutocomplete();
            
            // Show all cards in database when switching to DB mode
            if (autocompleteMode === 'db') {
                filterDatabaseList(''); // Show all cards
            }
        }
        
        function toggleEditMode() {
            editMode = !editMode;
            const button = UI.editDbToggle;
            
            if (editMode) {
                button.classList.add('bg-red-700', 'hover:bg-red-600');
                button.classList.remove('bg-slate-700', 'hover:bg-slate-600');
                button.innerHTML = `<svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg>Exit Edit`;
            } else {
                button.classList.remove('bg-red-700', 'hover:bg-red-600');
                button.classList.add('bg-slate-700', 'hover:bg-slate-600');
                button.innerHTML = `<svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg>Edit DB`;
                
                // Clear grid selection when exiting edit mode
                selectedGridCards.clear();
            }
            
            // Re-render the card database to show/hide delete buttons
            renderCardDatabase();
        }
        
        function toggleCardDatabaseView() {
            cardDatabaseView = cardDatabaseView === 'list' ? 'grid' : 'list';
            const button = UI.viewToggleBtn;
            
            if (cardDatabaseView === 'grid') {
                button.innerHTML = `<svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z"></path></svg>Grid`;
            } else {
                button.innerHTML = `<svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 10h16M4 14h16M4 18h16"></path></svg>List`;
            }
            
            // Save preference to localStorage
            localStorage.setItem('cardDatabaseView', cardDatabaseView);
            
            // Re-render the card database with the new view
            renderCardDatabase();
        }
        
        function handleAutocompleteKeydown(e) {
            // In DB mode, no keyboard navigation needed since there's no dropdown
            if (autocompleteMode === 'db') {
                if (e.key === 'Enter') {
                    handleCardSearch();
                }
                return;
            }
            
            const items = UI.cardAutocompleteList.querySelectorAll('.autocomplete-item');
            
            if (!UI.cardAutocompleteList.classList.contains('hidden') && items.length > 0) {
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    autocompleteSelectedIndex = Math.min(autocompleteSelectedIndex + 1, items.length - 1);
                    updateAutocompleteSelection(items);
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    autocompleteSelectedIndex = Math.max(autocompleteSelectedIndex - 1, -1);
                    updateAutocompleteSelection(items);
                } else if (e.key === 'Tab') {
                    e.preventDefault();
                    if (e.shiftKey) {
                        // Shift+Tab: go to previous item
                        autocompleteSelectedIndex = autocompleteSelectedIndex <= 0 ? items.length - 1 : autocompleteSelectedIndex - 1;
                        updateAutocompleteSelection(items);
                    } else {
                        // Tab: go to next item or select if at end
                        if (autocompleteSelectedIndex >= items.length - 1) {
                            // At the end, select the current item
                            selectAutocompleteItem(items[autocompleteSelectedIndex].dataset.cardName);
                        } else {
                            // Move to next item
                            autocompleteSelectedIndex = Math.min(autocompleteSelectedIndex + 1, items.length - 1);
                            updateAutocompleteSelection(items);
                        }
                    }
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    if (autocompleteSelectedIndex >= 0 && autocompleteSelectedIndex < lastAutocompleteMatches.length) {
                        const selectedCard = lastAutocompleteMatches[autocompleteSelectedIndex];
                        // Add card to database directly
                        addCardToDatabaseFromAutocomplete(selectedCard);
                    } else {
                        handleCardSearch();
                    }
                } else if (e.key === ' ') {
                    if (autocompleteSelectedIndex >= 0 && autocompleteSelectedIndex < items.length) {
                        e.preventDefault();
                        selectAutocompleteItem(items[autocompleteSelectedIndex].dataset.cardName);
                    }
                } else if (e.key === 'Escape') {
                    hideAutocomplete();
                }
            } else if (e.key === 'Enter') {
                handleCardSearch();
            }
        }
        
        function updateAutocompleteSelection(items) {
            items.forEach((item, index) => {
                if (index === autocompleteSelectedIndex) {
                    item.classList.add('bg-slate-700');
                    item.scrollIntoView({ block: 'nearest' });
                    
                    // Add space key indicator
                    if (!item.querySelector('.space-indicator')) {
                        const spaceIndicator = document.createElement('span');
                        spaceIndicator.className = 'space-indicator text-xs text-slate-400 ml-2';
                        spaceIndicator.innerHTML = '<kbd class="px-1 py-0.5 bg-slate-600 rounded text-xs">Space</kbd>';
                        item.appendChild(spaceIndicator);
                    }
                } else {
                    item.classList.remove('bg-slate-700');
                    // Remove space key indicator
                    const spaceIndicator = item.querySelector('.space-indicator');
                    if (spaceIndicator) {
                        spaceIndicator.remove();
                    }
                }
            });
        }
        
        function selectAutocompleteItem(cardName) {
            UI.cardSearchInput.value = cardName;
            hideAutocomplete();
            UI.cardSearchInput.focus();
        }
        
        function hideAutocomplete() {
            UI.cardAutocompleteList.classList.add('hidden');
            UI.cardAutocompleteList.innerHTML = '';
            autocompleteSelectedIndex = -1;
        }
        
        async function addCardToDatabaseFromAutocomplete(card) {
            // Check if card already exists in database
            if (cardDatabase.some(dbCard => dbCard.id === card.id)) {
                showTooltip(`'${card.name}' is already in the database.`);
                return;
            }
            
            // If it's from the "All" mode, we need to fetch full card data
            if (autocompleteMode === 'all') {
                try {
                    const response = await fetch(`https://db.ygoprodeck.com/api/v7/cardinfo.php?fname=${encodeURIComponent(card.name)}`);
                    if (!response.ok) throw new Error('Failed to fetch card data');
                    
                    const data = await response.json();
                    const cardData = data.data[0];
                    
                    // Call the existing addCardToDatabase function with full card data
                    await addCardToDatabase(cardData);
                } catch (error) {
                    console.error('Error adding card from autocomplete:', error);
                    showTooltip('Failed to add card to database.');
                }
            } else {
                // If it's from DB mode, the card is already in the database
                showTooltip(`'${card.name}' is already in the database.`);
            }
        }

        async function handleCardSearch() {
            const cardName = UI.cardSearchInput.value.trim();
            if (!cardName) return;
            UI.loadingOverlay.classList.remove('hidden');
            try {
                const response = await fetch(`https://db.ygoprodeck.com/api/v7/cardinfo.php?fname=${encodeURIComponent(cardName)}`);
                if (!response.ok) {
                    if(response.status === 400) throw new Error(`No cards found matching "${cardName}".`);
                    throw new Error('Error fetching card data from API.');
                }
                const data = await response.json();
                const mainDeckCards = data.data.filter(c => !c.type.includes('Link') && !c.type.includes('Fusion') && !c.type.includes('Synchro') && !c.type.includes('XYZ'));
                renderSearchResultsModal(mainDeckCards);
            } catch (error) {
                console.error("Error searching card:", error);
                showMessage(error.message);
            } finally {
                UI.loadingOverlay.classList.add('hidden');
            }
        }
        
        function renderSearchResultsModal(cards) {
            UI.searchResultsList.innerHTML = '';
            if (!cards || cards.length === 0) {
                UI.searchResultsList.innerHTML = `<p class="text-[var(--color-text-muted)] text-center">No Main Deck cards found.</p>`;
                UI.searchResultsModal.classList.remove('hidden');
                return;
            }
            cards.forEach(cardData => {
                const isAlreadyInDb = cardDatabase.some(card => card.id === cardData.id.toString());
                const cardEl = document.createElement('div');
                cardEl.className = 'p-2 flex items-center justify-between bg-[var(--color-surface-2)]/50 rounded-lg';
                const escapedCardData = JSON.stringify(cardData).replace(/'/g, '&#39;');
                cardEl.innerHTML = `
                    <div class="flex items-center gap-3 overflow-hidden">
                        <img src="${cardData.card_images[0].image_url_small}" class="w-10 h-auto rounded-md flex-shrink-0" onerror="this.onerror=null;this.src='https://placehold.co/40x58/2d3748/e2e8f0?text=?';">
                        <span class="text-sm font-medium">${cardData.name}</span>
                    </div>
                    <button data-card-data='${escapedCardData}' class="flex-shrink-0 text-[var(--color-accent-green)] hover:text-green-300 text-xs font-bold px-3 py-1 rounded-md ${isAlreadyInDb ? 'bg-slate-600 text-slate-400 cursor-not-allowed' : 'bg-green-800/50 hover:bg-green-700/50'}" ${isAlreadyInDb ? 'disabled' : ''}>
                        ${isAlreadyInDb ? 'In DB' : 'Add'}
                    </button>`;
                if (!isAlreadyInDb) {
                    cardEl.querySelector('button').addEventListener('click', async (e) => {
                        const btn = e.currentTarget;
                        const data = JSON.parse(btn.dataset.cardData);
                        await addCardToDatabase(data);
                        btn.textContent = 'In DB';
                        btn.disabled = true;
                        btn.className = 'flex-shrink-0 text-slate-400 bg-slate-600 cursor-not-allowed text-xs font-bold px-3 py-1 rounded-md';
                    });
                }
                UI.searchResultsList.appendChild(cardEl);
            });
            UI.searchResultsModal.classList.remove('hidden');
        }

        async function addCardToDatabase(cardData) {
             // Check if card already exists
             if (cardDatabase.some(card => card.id === cardData.id.toString())) {
                 showTooltip(`'${cardData.name}' is already in the database.`);
                 return;
             }
            const newCard = {
                id: cardData.id.toString(),
                name: cardData.name,
                type: cardData.type,
                imageUrl: cardData.card_images[0].image_url
            };
            
            // Add to local database immediately (check for duplicates first)
            const existsInMemory = cardDatabase.some(card => card.id === newCard.id);
            if (!existsInMemory) {
                cardDatabase.push(newCard);
                originalCardDatabase.push(newCard); // Also add to original database
                cardDatabase.sort((a, b) => a.name.localeCompare(b.name));
                originalCardDatabase.sort((a, b) => a.name.localeCompare(b.name));
            } else {
                // Card already exists, don't add it
                showTooltip(`Card '${newCard.name}' already exists in database.`);
                return; // Exit early since card already exists
            }
            renderCardDatabase();
            
            if (isOffline) {
                // In offline mode, save to localStorage
                try {
                    const savedCards = JSON.parse(localStorage.getItem('offlineCardDatabase') || '[]');
                    // Check for duplicates before adding
                    const isDuplicate = savedCards.some(card => card.id === newCard.id);
                    if (!isDuplicate) {
                        savedCards.push(newCard);
                        localStorage.setItem('offlineCardDatabase', JSON.stringify(savedCards));
                        showTooltip(`Added '${newCard.name}' to the database (offline mode).`);
                    } else {
                        console.log(`Card '${newCard.name}' already exists in database, skipping duplicate.`);
                        showTooltip(`Card '${newCard.name}' already exists in database.`);
                    }
                } catch(e) {
                    console.error("Error saving card to localStorage:", e);
                    showMessage("Failed to save card to local database.");
                }
            } else {
                // In online mode, save to Firebase
                if (!userId) { 
                    showMessage("You must be logged in to add cards in online mode."); 
                    // Remove from local database since we can't save it
                    cardDatabase = cardDatabase.filter(card => card.id !== newCard.id);
                    originalCardDatabase = originalCardDatabase.filter(card => card.id !== newCard.id);
                    renderCardDatabase();
                    return; 
                }
                try {
                    await setDoc(doc(db, `artifacts/${appId}/users/${userId}/cards`, newCard.id), newCard);
                    showTooltip(`Added '${newCard.name}' to the database.`);
                } catch(e) {
                     console.error("Error adding card to DB:", e);
                     showMessage("Failed to add card to database.");
                     // Remove from local database since we can't save it
                     cardDatabase = cardDatabase.filter(card => card.id !== newCard.id);
                     originalCardDatabase = originalCardDatabase.filter(card => card.id !== newCard.id);
                     renderCardDatabase();
                }
            }
        }
        
        function deleteCardFromDb(cardId) {
            showConfirmModal("Are you sure you want to delete this card from your database?", async () => {
                // Remove from local database immediately
                const cardToDelete = cardDatabase.find(card => card.id === cardId);
                if (!cardToDelete) {
                    showMessage("Card not found in database.");
                    return;
                }
                
                cardDatabase = cardDatabase.filter(card => card.id !== cardId);
                originalCardDatabase = originalCardDatabase.filter(card => card.id !== cardId);
                renderCardDatabase();
                populateSimulationSetup();
                
                if (isOffline) {
                    // In offline mode, save to localStorage
                    try {
                        const savedCards = JSON.parse(localStorage.getItem('offlineCardDatabase') || '[]');
                        const updatedCards = savedCards.filter(card => card.id !== cardId);
                        localStorage.setItem('offlineCardDatabase', JSON.stringify(updatedCards));
                        showTooltip(`Deleted '${cardToDelete.name}' from the database (offline mode).`);
                    } catch(e) {
                        console.error("Error saving to localStorage:", e);
                        showMessage("Failed to save changes to local database.");
                    }
                } else {
                    // In online mode, delete from Firebase
                    if (!userId) { 
                        showMessage("You must be logged in to delete cards in online mode."); 
                        return; 
                    }
                    try {
                        await deleteDoc(doc(db, `artifacts/${appId}/users/${userId}/cards`, cardId));
                        showTooltip(`Deleted '${cardToDelete.name}' from the database.`);
                    } catch(e) {
                        showMessage("Error deleting card from database.");
                        console.error(e);
                        // Re-add the card to local database since deletion failed
                        cardDatabase.push(cardToDelete);
                        originalCardDatabase.push(cardToDelete); // Also add to original database
                        cardDatabase.sort((a, b) => a.name.localeCompare(b.name));
                        originalCardDatabase.sort((a, b) => a.name.localeCompare(b.name));
                        renderCardDatabase();
                        populateSimulationSetup();
                    }
                }
            });
        }

        // --- DECKBUILDER LOGIC ---
        async function loadUserDecks() {
            if (!userId) return;
            const decksRef = collection(db, `artifacts/${appId}/users/${userId}/decks`);
            onSnapshot(query(decksRef), 
                (snapshot) => {
                    deckLists = [];
                    snapshot.forEach(doc => deckLists.push({ id: doc.id, ...doc.data() }));
                    renderDeckSelector();
                    populateSimulationSetup();
                },
                (error) => {
                    console.error("Error loading user decks:", error);
                    // This error is less critical if the card DB also fails, but good to have.
                    showMessage(`Could not load your saved decks: ${error.code}.`);
            });
        }

        async function loadOfflineDecks() {
            try {
                offlineDecks = await getAllOfflineDecksFromDB();
                renderDeckSelector();
                if (offlineDecks.length === 0 && typeof localStorage !== 'undefined' && !localStorage.getItem('offlineDecksIntroduced')) {
                    showTooltip('Offline save ready: use Save to store decks locally and sync YDK files.');
                    localStorage.setItem('offlineDecksIntroduced', '1');
                }
            } catch (error) {
                console.error('Error loading offline decks:', error);
                showMessage('Error loading offline decks from storage.');
            }
        }
        
        function addCardToDeck(cardId, deckPart = 'main') {
            const card = cardDatabase.find(c => c.id === cardId);
            if (!card) return;
            
            // For main and side deck, check the 3-copy limit
            if (deckPart === 'main' || deckPart === 'side') {
                const totalCount = [...currentDeck.main, ...currentDeck.side].filter(id => id === cardId).length;
                if (totalCount >= 3) {
                    showTooltip(`You can only have 3 copies of '${card.name}' in your Main and Side Deck combined.`);
                    return;
                }
            }
            
            // For extra deck, check if it's already in the extra deck
            if (deckPart === 'extra' && currentDeck.extra.includes(cardId)) {
                showTooltip(`'${card.name}' is already in your Extra Deck.`);
                return;
            }

            if (deckPart === 'main' && currentDeck.main.length >= 60) {
                 showTooltip(`Your main deck cannot exceed 60 cards.`);
                 return;
            }
            if (deckPart === 'side' && currentDeck.side.length >= 15) {
                 showTooltip(`Your side deck cannot exceed 15 cards.`);
                 return;
            }
            if (deckPart === 'extra' && currentDeck.extra.length >= 15) {
                 showTooltip(`Your extra deck cannot exceed 15 cards.`);
                 return;
            }

            currentDeck[deckPart].push(cardId);
            markDeckDirty();
            renderCurrentDeck();
        }

        function removeCardFromDeck(cardId, deckPart) {
            const index = currentDeck[deckPart].indexOf(cardId);
            if (index > -1) {
                currentDeck[deckPart].splice(index, 1);
                markDeckDirty();
                renderCurrentDeck();
            }
        }
        
        async function saveCurrentDeck() {
            const deckName = UI.deckNameInput.value.trim();
            if (!deckName) {
                showMessage("Please enter a name for your deck.");
                return;
            }
            if (currentDeck.main.length < 40) {
                showMessage("Your main deck must have at least 40 cards.");
                return;
            }
            
            UI.loadingOverlay.classList.remove('hidden');
            try {
                const deckData = { 
                    name: deckName, 
                    main: currentDeck.main, 
                    side: currentDeck.side, 
                    extra: currentDeck.extra || [], 
                    sidingPatterns: currentDeck.sidingPatterns || {},
                    cardPool: cardDatabase.map(card => card.id) // Save current card pool
                };

                const savingOffline = isOffline || currentDeckSource === 'offline' || currentDeckSource === 'ydk';
                if (savingOffline) {
                    const existingById = currentDeckSource === 'offline' && currentDeckId
                        ? offlineDecks.find(d => d.id === currentDeckId)
                        : null;
                    const conflictingByName = offlineDecks.find(d => d.name.toLowerCase() === deckName.toLowerCase() && (!existingById || d.id !== existingById.id));

                    if (ydkFiles.length === 0) {
                        await loadYDKFilesFromDB({ silent: true });
                    }

                    if (conflictingByName) {
                        const shouldOverwrite = typeof window !== 'undefined' ? window.confirm(`A local deck named "${deckName}" already exists. Overwrite it?`) : true;
                        if (!shouldOverwrite) {
                            showTooltip('Save cancelled.');
                            return;
                        }
                    }

                    const targetId = conflictingByName ? conflictingByName.id : existingById?.id;
                    const baseRecord = conflictingByName || existingById;
                    const existingSync = baseRecord?.sync || currentDeckMeta?.sync || null;
                    const preferredFormat = existingSync?.format || currentDeckFormat || 'ydk';
                    let syncMeta = existingSync ? { ...existingSync } : null;
                    if (!syncMeta) {
                        const fileName = generateUniqueYDKFileName(deckName, preferredFormat);
                        syncMeta = { type: 'ydk-storage', name: fileName, format: preferredFormat, displayName: deckName };
                    } else {
                        syncMeta.type = syncMeta.type || 'ydk-storage';
                        syncMeta.format = syncMeta.format || preferredFormat;
                        syncMeta.displayName = deckName;
                    }

                    const offlineDeckPayload = {
                        ...deckData,
                        id: targetId,
                        createdAt: baseRecord?.createdAt,
                        sync: syncMeta
                    };

                    let savedDeck = await saveOfflineDeckToDB(offlineDeckPayload);
                    savedDeck = await syncYDKFromDeck(savedDeck, offlineDeckPayload) || savedDeck;

                    currentDeckId = savedDeck.id;
                    currentDeckSource = 'offline';
                    const updatedSync = savedDeck.sync || syncMeta;
                    currentDeckMeta = { name: savedDeck.name, sync: updatedSync ? { ...updatedSync } : null };
                    isDeckDirty = false;

                    await loadOfflineDecks();
                    UI.deckSelector.value = encodeDeckSelectorValue('offline', savedDeck.id);
                    const syncedFileName = (savedDeck.sync || syncMeta)?.name;
                    showTooltip(`Deck '${deckName}' saved locally${syncedFileName ? ` and synced to ${syncedFileName}` : ''}.`);
                    return;
                }

                // Determine if we are updating the currently loaded deck, or creating a new deck
                let performUpdateById = false;
                if (currentDeckSource === 'online' && currentDeckId) {
                    const loaded = deckLists.find(d => d.id === currentDeckId);
                    if (loaded && loaded.name === deckName) {
                        performUpdateById = true; // same deck and same name  update in place
                    }
                }

                if (performUpdateById) {
                    await setDoc(doc(db, `artifacts/${appId}/users/${userId}/decks`, currentDeckId), deckData);
                    currentDeckSource = 'online';
                    currentDeckMeta = { name: deckName, sync: null };
                    isDeckDirty = false;
                    showTooltip(`Deck '${deckName}' updated.`);
                } else {
                    // Name changed or no deck loaded  Save As (create new)
                    // If a deck already exists with this name, confirm overwrite; otherwise create new
                    const existingByName = deckLists.find(d => d.name === deckName);
                    if (existingByName) {
                        await new Promise((resolve) => {
                            showConfirmModal(
                                `A deck named "${deckName}" already exists. Overwrite it?`,
                                async () => {
                                    await setDoc(doc(db, `artifacts/${appId}/users/${userId}/decks`, existingByName.id), deckData);
                                    currentDeckId = existingByName.id;
                                    currentDeckSource = 'online';
                                    currentDeckMeta = { name: deckName, sync: null };
                                    isDeckDirty = false;
                                    resolve();
                                }
                            );
                        });
                        showTooltip(`Deck '${deckName}' overwritten.`);
                    } else {
                        const ref = await addDoc(collection(db, `artifacts/${appId}/users/${userId}/decks`), deckData);
                        currentDeckId = ref.id;
                        currentDeckSource = 'online';
                        currentDeckMeta = { name: deckName, sync: null };
                        isDeckDirty = false;
                        // Keep selector synced
                        if (UI.deckSelector) UI.deckSelector.value = encodeDeckSelectorValue('online', currentDeckId);
                        showTooltip(`Deck '${deckName}' saved.`);
                    }
                }
            } catch(e) {
                console.error("Error saving deck:", e);
                showMessage("An error occurred while saving the deck.");
            } finally {
                UI.loadingOverlay.classList.add('hidden');
            }
        }

        function loadSelectedDeck() {
            const selection = decodeDeckSelectorValue(UI.deckSelector.value);
            if (!selection.id) return;

            if (!confirmDiscardDeckChanges()) {
                const revertValue = currentDeckId && currentDeckSource !== 'unsaved'
                    ? encodeDeckSelectorValue(currentDeckSource, currentDeckId)
                    : '';
                UI.deckSelector.value = revertValue;
                return;
            }

            let selectedDeck = null;
            if (selection.source === 'offline') {
                selectedDeck = offlineDecks.find(d => d.id === selection.id);
                if (!selectedDeck) {
                    showMessage('Offline deck not found.');
                    return;
                }
                currentDeckSource = 'offline';
                currentDeckMeta = { name: selectedDeck.name, sync: selectedDeck.sync ? { ...selectedDeck.sync } : null };
            } else {
                selectedDeck = deckLists.find(d => d.id === selection.id);
                if (!selectedDeck) {
                    showMessage('Deck not found.');
                    return;
                }
                currentDeckSource = 'online';
                currentDeckMeta = { name: selectedDeck.name, sync: null };
            }

                currentDeck.main = [...(selectedDeck.main || [])];
                currentDeck.side = [...(selectedDeck.side || [])];
                currentDeck.extra = [...(selectedDeck.extra || [])];
                currentDeck.sidingPatterns = { ...(selectedDeck.sidingPatterns || {}) };
                UI.deckNameInput.value = selectedDeck.name;
            currentDeckId = selectedDeck.id;
                
                if (selectedDeck.cardPool && Array.isArray(selectedDeck.cardPool)) {
                    console.log(`[DEBUG] Restoring card pool for deck '${selectedDeck.name}' with ${selectedDeck.cardPool.length} cards`);
                    cardDatabase = originalCardDatabase.filter(card => selectedDeck.cardPool.includes(card.id));
                    console.log(`[DEBUG] Card database filtered to ${cardDatabase.length} cards`);
                } else {
                    console.log(`[DEBUG] No card pool found for deck '${selectedDeck.name}', using full database`);
                    cardDatabase = [...originalCardDatabase];
                }
                
                renderCurrentDeck();
            renderCardDatabase();
            populateSimulationSetup();
                showTooltip(`Loaded deck '${selectedDeck.name}'.`);
            isDeckDirty = false;
        }
        
        function deleteSelectedDeck() {
            const selection = decodeDeckSelectorValue(UI.deckSelector.value);
            if (!selection.id) { showMessage("Please select a deck to delete."); return; }

            if (selection.source === 'offline') {
                const deck = offlineDecks.find(d => d.id === selection.id);
                if (!deck) { showMessage('Offline deck not found.'); return; }
                const confirmed = typeof window !== 'undefined' ? window.confirm(`Delete local deck '${deck.name}'? This action cannot be undone.`) : true;
                if (!confirmed) return;

                UI.loadingOverlay.classList.remove('hidden');
                deleteOfflineDeckFromDB(deck.id)
                    .then(async () => {
                        showTooltip(`Deleted local deck '${deck.name}'.`);
                        if (currentDeckSource === 'offline' && currentDeckId === deck.id) {
                            currentDeck = { main: [], side: [], extra: [], sidingPatterns: {} };
                            currentDeckId = null;
                            currentDeckSource = 'unsaved';
                            currentDeckMeta = { name: null, sync: null };
                            isDeckDirty = false;
                            UI.deckNameInput.value = '';
                            cardDatabase = [...originalCardDatabase];
                            renderCurrentDeck();
                            renderCardDatabase();
                        }
                        await loadOfflineDecks();
                        populateSimulationSetup();
                        UI.deckSelector.value = '';
                    })
                    .catch((error) => {
                        console.error('Error deleting offline deck:', error);
                        showMessage('Failed to delete local deck.');
                    })
                    .finally(() => UI.loadingOverlay.classList.add('hidden'));
                return;
            }

            const deckId = selection.id;
            const deckName = deckLists.find(d => d.id === deckId)?.name || 'the selected deck';
            
            showConfirmModal(`Are you sure you want to delete '${deckName}'? This cannot be undone.`, async () => {
                UI.loadingOverlay.classList.remove('hidden');
                try {
                    await deleteDoc(doc(db, `artifacts/${appId}/users/${userId}/decks`, deckId));
                    showTooltip(`Deck deleted successfully.`);
                    if(currentDeckSource === 'online' && currentDeckId === deckId) {
                        currentDeck = { main: [], side: [], extra: [], sidingPatterns: {} };
                        currentDeckId = null;
                        currentDeckSource = 'unsaved';
                        currentDeckMeta = { name: null, sync: null };
                        isDeckDirty = false;
                        UI.deckNameInput.value = '';
                        // Reset card pool to full database when current deck is deleted
                        cardDatabase = [...originalCardDatabase];
                        renderCurrentDeck();
                        renderCardDatabase();
                    }
                    UI.deckSelector.value = '';
                    populateSimulationSetup();
                } catch(e) {
                    console.error("Error deleting deck:", e);
                    showMessage("An error occurred while deleting the deck.");
                } finally {
                    UI.loadingOverlay.classList.add('hidden');
                }
            });
        }

        function exportDeckToYDK() {
            if (currentDeck.main.length === 0) { showMessage("Cannot export an empty deck."); return; }
            let ydkContent = "#main\n";
            ydkContent += currentDeck.main.join('\n');
            if (currentDeck.side.length > 0) {
                ydkContent += "\n!side\n";
                ydkContent += currentDeck.side.join('\n');
            }
            // Add extra section with cards from database that aren't in main/side deck
            if (currentDeck.extra && currentDeck.extra.length > 0) {
                ydkContent += "\n#extra\n";
                ydkContent += currentDeck.extra.join('\n');
            }
            const blob = new Blob([ydkContent], { type: 'text/plain;charset=utf-8' });
            const deckName = UI.deckNameInput.value.trim() || 'deck';
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `${deckName}.ydk`;
            a.click();
            URL.revokeObjectURL(a.href);
        }
        
        function exportDeckToYDKX() {
            if (currentDeck.main.length === 0) { showMessage("Cannot export an empty deck."); return; }
            
            // Build the standard YDK content
            let ydkxContent = "#main\n";
            ydkxContent += currentDeck.main.join('\n');
            if (currentDeck.side.length > 0) {
                ydkxContent += "\n!side\n";
                ydkxContent += currentDeck.side.join('\n');
            }
            if (currentDeck.extra && currentDeck.extra.length > 0) {
                ydkxContent += "\n#extra\n";
                ydkxContent += currentDeck.extra.join('\n');
            }
            
            // Add the extended YDKX metadata
            const extendedData = {
                version: "1.0",
                cardPool: cardDatabase.map(card => card.id),
                configurations: {
                    deckScale: parseInt(UI.deckScaleSlider?.value || 8),
                    scaleTarget: scaleTarget,
                    cardDatabaseView: cardDatabaseView,
                    extraDeckVisible: extraDeckVisible,
                    sideDeckVisible: sideDeckVisible,
                    databaseVisible: databaseVisible
                },
                notes: {
                    cards: {},
                    pairs: {}
                }
            };
            
            ydkxContent += "\n#ydkx-extended\n";
            ydkxContent += JSON.stringify(extendedData, null, 2);
            
            const blob = new Blob([ydkxContent], { type: 'text/plain;charset=utf-8' });
            const deckName = UI.deckNameInput.value.trim() || 'deck';
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `${deckName}.ydkx`;
            a.click();
            URL.revokeObjectURL(a.href);
        }

        function exportDeckToClipboard() {
            if (currentDeck.main.length === 0) { showMessage("Cannot copy an empty deck."); return; }

            const deckToBase64 = (deck) => {
                if (!deck || deck.length === 0) return '';
                // Each ID is 4 bytes (32-bit integer)
                const buffer = new ArrayBuffer(deck.length * 4);
                const view = new DataView(buffer);
                deck.forEach((cardId, index) => {
                    // Write as a 32-bit little-endian unsigned integer
                    view.setUint32(index * 4, parseInt(cardId, 10), true);
                });

                // Convert ArrayBuffer to a binary string for btoa
                const charCodes = new Uint8Array(buffer);
                let binaryString = '';
                for (let i = 0; i < charCodes.length; i++) {
                    binaryString += String.fromCharCode(charCodes[i]);
                }
                return btoa(binaryString);
            };

            const mainDeckB64 = deckToBase64(currentDeck.main);
            const extraDeckB64 = ''; // This tool does not support an extra deck
            const sideDeckB64 = deckToBase64(currentDeck.side);

            const ydkeCode = `ydke://${mainDeckB64}!${extraDeckB64}!${sideDeckB64}`;

            navigator.clipboard.writeText(ydkeCode).then(() => {
                showTooltip("Deck code copied to clipboard!");
            }, () => {
                showMessage("Failed to copy deck code to clipboard.");
            });
        }

        async function importDeckFromClipboard() {
            try {
                if (!confirmDiscardDeckChanges()) {
                    return;
                }
                const content = await navigator.clipboard.readText();
                if (!content) {
                    showMessage("Clipboard is empty or permission was denied.");
                    return;
                }

                if (!content.startsWith('ydke://')) {
                    showMessage("Invalid YDKe code. It must start with 'ydke://'.");
                    return;
                }

                const base64ToDeck = (b64) => {
                    if (!b64) return [];
                    const deck = [];
                    try {
                        const binaryString = atob(b64);
                        const bytes = new Uint8Array(binaryString.length);
                        for (let i = 0; i < binaryString.length; i++) {
                            bytes[i] = binaryString.charCodeAt(i);
                        }
                        const view = new DataView(bytes.buffer);
                        for (let i = 0; i < view.byteLength; i += 4) {
                            deck.push(String(view.getUint32(i, true)));
                        }
                        return deck;
                    } catch (e) {
                        console.error("Base64 decoding error:", e);
                        return null; // Indicate failure
                    }
                };

                // A valid YDKe can have 3 or 4 parts if the side deck ends with '!'
                const parts = content.substring('ydke://'.length).split('!', 4);
                if (parts.length < 3) {
                    showMessage("Invalid YDKe code structure.");
                    return;
                }

                const [mainB64, extraB64, sideB64] = parts;
                const importedDeck = { main: [], side: [] };
                importedDeck.main = base64ToDeck(mainB64);
                importedDeck.side = base64ToDeck(sideB64);

                if (importedDeck.main === null || importedDeck.side === null) {
                    showMessage("Failed to parse YDKe code. It may be corrupted.");
                    return;
                }

                UI.loadingOverlay.classList.remove('hidden');
                const allIds = [...new Set([...importedDeck.main, ...importedDeck.side])];
                const missingCards = allIds.filter(id => !cardDatabase.some(c => c.id === id));

                if (missingCards.length > 0) {
                    showTooltip(`Importing ${missingCards.length} missing card(s)...`);
                    await fetchAndAddMissingCards(missingCards);
                }

                currentDeck = { main: importedDeck.main, side: importedDeck.side, extra: importedDeck.extra || [], sidingPatterns: {} };
                UI.deckNameInput.value = "Pasted Deck";
                currentDeckId = null; // treat pasted deck as a new deck until saved
                currentDeckSource = 'unsaved';
                currentDeckMeta = { name: 'Pasted Deck', sync: null };
                markDeckDirty();
                renderCurrentDeck();
                showTooltip("Deck loaded from clipboard. You can now save it.");
            } catch (err) {
                console.error("Failed to import from clipboard:", err);
                showTooltip("Could not read from clipboard. Check browser permissions or console for errors.");
            } finally {
                UI.loadingOverlay.classList.add('hidden');
            }
        }

        async function importDeckFromYDK(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = async (e) => {
                console.log('[DEBUG] YDK file loaded. Starting import process...');
                if (!confirmDiscardDeckChanges()) {
                    return;
                }
                const content = e.target.result;
                const lines = content.split('\n').map(l => l.trim()).filter(Boolean);
                let currentSection = '';
                const importedDeck = { main: [], side: [], extra: [] };
                let extendedData = null;
                let isYDKX = false;

                for(const line of lines) {
                    if (line === '#main') { currentSection = 'main'; continue; }
                    if (line === '!side') { currentSection = 'side'; continue; }
                    if (line === '#extra') { currentSection = 'extra'; continue; }
                    if (line === '#ydkx-extended') { 
                        currentSection = 'extended'; 
                        isYDKX = true;
                        continue; 
                    }
                    if ((currentSection === 'main' || currentSection === 'side' || currentSection === 'extra') && !isNaN(parseInt(line))) {
                        importedDeck[currentSection].push(line);
                    }
                    if (currentSection === 'extended') {
                        // Collect all lines for JSON parsing
                        if (!extendedData) extendedData = '';
                        extendedData += line + '\n';
                    }
                }
                
                // Parse extended data if present
                if (isYDKX && extendedData) {
                    try {
                        extendedData = JSON.parse(extendedData.trim());
                        console.log('[DEBUG] Parsed YDKX extended data:', extendedData);
                    } catch (e) {
                        console.warn('[DEBUG] Failed to parse YDKX extended data:', e);
                        extendedData = null;
                    }
                }
                console.log(`[DEBUG] Parsed deck. Main: ${importedDeck.main.length}, Side: ${importedDeck.side.length}`);
                
                UI.loadingOverlay.classList.remove('hidden');
                const allIds = [...new Set([...importedDeck.main, ...importedDeck.side])];

                // Wait for Firebase to be ready before proceeding
                while (!isFirebaseReady) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }

                const missingCards = allIds.filter(id => !cardDatabase.some(c => c.id === id));
                if (missingCards.length > 0) {
                    console.log(`[DEBUG] Found ${missingCards.length} missing cards. Fetching...`);
                    showTooltip(`Importing ${missingCards.length} missing card(s)...`);
                    await fetchAndAddMissingCards(missingCards);
                    console.log('[DEBUG] Finished fetching missing cards.');
                }
                
                // NEW: Handle offline mode first to prevent getting stuck.
                if (isOffline) {
                    console.log('[DEBUG] Offline mode detected. Loading deck locally from YDK.');
                    const deckName = file.name.replace(/\.(ydk|ydkx)$/, '');
                    showTooltip(`Loaded deck '${deckName}' in offline mode.`);
                    currentDeck.main = importedDeck.main;
                    currentDeck.side = importedDeck.side;
                    currentDeck.extra = importedDeck.extra || [];
                    currentDeck.sidingPatterns = {};
                    UI.deckNameInput.value = deckName;
                    currentDeckId = null; // new imported deck is not tied to any saved doc yet
                    currentDeckSource = 'unsaved';
                    currentDeckMeta = {
                        name: deckName,
                        sync: { type: 'ydk-storage', name: file.name, format: isYDKX ? 'ydkx' : 'ydk', displayName: deckName }
                    };
                    markDeckDirty();
                    
                    // Handle YDKX extended data
                    if (isYDKX && extendedData) {
                        console.log('[DEBUG] Loading YDKX extended data...');
                        currentDeckFormat = 'ydkx';
                        
                        // Load card pool from extended data
                        if (extendedData.cardPool && Array.isArray(extendedData.cardPool)) {
                            console.log(`[DEBUG] Loading card pool with ${extendedData.cardPool.length} cards`);
                            const poolCardIds = extendedData.cardPool;
                            const missingPoolCards = poolCardIds.filter(id => !cardDatabase.some(c => c.id === id));
                            
                            if (missingPoolCards.length > 0) {
                                console.log(`[DEBUG] Fetching ${missingPoolCards.length} missing pool cards...`);
                                await fetchAndAddMissingCards(missingPoolCards);
                            }
                            
                            // Filter original database to only include cards in the pool
                            console.log(`[DEBUG] Original database has ${originalCardDatabase.length} cards before filtering`);
                            cardDatabase = originalCardDatabase.filter(card => poolCardIds.includes(card.id));
                            console.log(`[DEBUG] Card pool loaded: ${cardDatabase.length} cards from ${poolCardIds.length} pool cards`);
                        }
                        
                        // Apply configurations
                        if (extendedData.configurations) {
                            const config = extendedData.configurations;
                            if (config.deckScale && UI.deckScaleSlider) {
                                UI.deckScaleSlider.value = config.deckScale;
                            }
                            if (config.scaleTarget) {
                                scaleTarget = config.scaleTarget;
                                if (UI.scaleTargetBtn) {
                                    UI.scaleTargetBtn.textContent = config.scaleTarget.charAt(0).toUpperCase() + config.scaleTarget.slice(1);
                                }
                            }
                            if (config.cardDatabaseView) {
                                cardDatabaseView = config.cardDatabaseView;
                                if (UI.viewToggleBtn) {
                                    if (cardDatabaseView === 'grid') {
                                        UI.viewToggleBtn.innerHTML = `<svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z"></path></svg>Grid`;
                                    } else {
                                        UI.viewToggleBtn.innerHTML = `<svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 10h16M4 14h16M4 18h16"></path></svg>List`;
                                    }
                                }
                            }
                            if (config.extraDeckVisible !== undefined) {
                                extraDeckVisible = config.extraDeckVisible;
                            }
                            if (config.sideDeckVisible !== undefined) {
                                sideDeckVisible = config.sideDeckVisible;
                            }
                            if (config.databaseVisible !== undefined) {
                                databaseVisible = config.databaseVisible;
                            }
                        }
                    } else {
                        currentDeckFormat = 'ydk';
                        // For regular YDK files, set card pool to all cards currently in deck
                        const allDeckCardIds = [...new Set([...importedDeck.main, ...importedDeck.side, ...(importedDeck.extra || [])])];
                        console.log(`[DEBUG] YDK: Original database has ${originalCardDatabase.length} cards before filtering`);
                        cardDatabase = originalCardDatabase.filter(card => allDeckCardIds.includes(card.id));
                        console.log(`[DEBUG] YDK: Card pool loaded: ${cardDatabase.length} cards from ${allDeckCardIds.length} deck cards`);
                    }
                    
                    renderCurrentDeck();
                    renderCardDatabase(); // Re-render with new card pool
                    populateSimulationSetup(); // Ensure simulator is updated
                    UI.loadingOverlay.classList.add('hidden');
                    return; // Exit the function entirely for offline mode.
                }

                console.log('[DEBUG] Online mode. Proceeding to save deck to Firebase.');
                const deckName = file.name.replace(/\.(ydk|ydkx)$/, '');
                
                // Set up card pool based on file type
                let cardPoolIds = [];
                if (isYDKX && extendedData && extendedData.cardPool && Array.isArray(extendedData.cardPool)) {
                    // YDKX file with card pool
                    currentDeckFormat = 'ydkx';
                    const poolCardIds = extendedData.cardPool;
                    const missingPoolCards = poolCardIds.filter(id => !originalCardDatabase.some(c => c.id === id));
                    
                    if (missingPoolCards.length > 0) {
                        console.log(`[DEBUG] Fetching ${missingPoolCards.length} missing pool cards...`);
                        await fetchAndAddMissingCards(missingPoolCards);
                    }
                    
                    cardDatabase = originalCardDatabase.filter(card => poolCardIds.includes(card.id));
                    cardPoolIds = poolCardIds;
                    console.log(`[DEBUG] YDKX: Card pool loaded: ${cardDatabase.length} cards from ${poolCardIds.length} pool cards`);
                } else {
                    // YDK file - create card pool from cards in deck
                    currentDeckFormat = 'ydk';
                    const allDeckCardIds = [...new Set([...importedDeck.main, ...importedDeck.side, ...(importedDeck.extra || [])])];
                    cardDatabase = originalCardDatabase.filter(card => allDeckCardIds.includes(card.id));
                    cardPoolIds = allDeckCardIds;
                    console.log(`[DEBUG] YDK: Card pool created: ${cardDatabase.length} cards from ${allDeckCardIds.length} deck cards`);
                }
                
                const deckData = { 
                    name: deckName, 
                    main: importedDeck.main, 
                    side: importedDeck.side, 
                    extra: importedDeck.extra || [],
                    sidingPatterns: {},
                    cardPool: cardPoolIds // Include card pool in saved data
                };
                const existingDeck = deckLists.find(d => d.name === deckName);

                const saveDeckLogic = async (docId) => {
                    console.log(`[DEBUG] Executing saveDeckLogic for docId: ${docId}`);
                    try {
                        let newDocId = docId;
                        if (docId) {
                            await setDoc(doc(db, `artifacts/${appId}/users/${userId}/decks`, docId), deckData);
                            showMessage(`Updated and loaded deck: '${deckName}'.`);
                        } else {
                            const newDocRef = await addDoc(collection(db, `artifacts/${appId}/users/${userId}/decks`), deckData);
                            newDocId = newDocRef.id;
                            showMessage(`Imported, saved, and loaded new deck: '${deckName}'.`);
                        }
                        currentDeck.main = importedDeck.main;
                        currentDeck.side = importedDeck.side;
                        currentDeck.extra = importedDeck.extra || [];
                        currentDeck.sidingPatterns = {};
                        UI.deckNameInput.value = deckName;
                        UI.deckSelector.value = encodeDeckSelectorValue('online', newDocId);
                        currentDeckId = newDocId; // set newly saved/updated deck id
                        currentDeckSource = 'online';
                        currentDeckMeta = { name: deckName, sync: null };
                        isDeckDirty = false;
                        renderCurrentDeck();
                        renderCardDatabase(); // Re-render card database with imported card pool
                        populateSimulationSetup(); // Ensure simulator is updated
                    } catch (err) {
                        console.error("Error saving imported deck:", err);
                        console.log('[DEBUG] Error caught in saveDeckLogic. Hiding overlay in finally block.');
                        showTooltip("Failed to save the imported deck.");
                    } finally {
                        UI.loadingOverlay.classList.add('hidden');
                    }
                };

                if (existingDeck) {
                    console.log(`[DEBUG] Deck "${deckName}" exists. Showing confirmation modal.`);
                    showConfirmModal(
                        `A deck named "${deckName}" already exists. Do you want to overwrite it?`,
                        () => saveDeckLogic(existingDeck.id)
                    );
                } else {
                    console.log(`[DEBUG] New deck "${deckName}". Saving directly.`);
                    saveDeckLogic(null);
                }
            };
            reader.readAsText(file);
            event.target.value = null;
        }

        // --- INDEXEDDB YDK STORAGE FUNCTIONS ---
        let ydkDB = null;

        async function initYDKDatabase() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('YDKStorage', 2);
                
                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    ydkDB = request.result;
                    resolve(ydkDB);
                };
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains('ydkFiles')) {
                        const store = db.createObjectStore('ydkFiles', { keyPath: 'name' });
                        store.createIndex('displayName', 'displayName', { unique: false });
                        store.createIndex('lastModified', 'lastModified', { unique: false });
                    }
                    if (!db.objectStoreNames.contains('offlineDecks')) {
                        const deckStore = db.createObjectStore('offlineDecks', { keyPath: 'id' });
                        deckStore.createIndex('name', 'name', { unique: false });
                        deckStore.createIndex('updatedAt', 'updatedAt', { unique: false });
                        deckStore.createIndex('createdAt', 'createdAt', { unique: false });
                    }
                };
            });
        }

        async function saveYDKFileToDB(name, content, metadata = {}) {
            if (!ydkDB) await initYDKDatabase();
            
            const ydkFile = {
                name,
                displayName: metadata.displayName || name.replace(/\.(ydk|ydkx)$/i, ''),
                content,
                lastModified: metadata.lastModified || new Date().toISOString(),
                format: metadata.format || (name.toLowerCase().endsWith('.ydkx') ? 'ydkx' : 'ydk'),
                cardPool: metadata.cardPool || null
            };
            
            return new Promise((resolve, reject) => {
                const transaction = ydkDB.transaction(['ydkFiles'], 'readwrite');
                const store = transaction.objectStore('ydkFiles');
                const request = store.put(ydkFile);
                
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async function getAllYDKFilesFromDB() {
            if (!ydkDB) await initYDKDatabase();
            
            return new Promise((resolve, reject) => {
                const transaction = ydkDB.transaction(['ydkFiles'], 'readonly');
                const store = transaction.objectStore('ydkFiles');
                const request = store.getAll();
                
                request.onsuccess = () => {
                    const files = (request.result || []).map(file => ({
                        ...file,
                        displayName: file.displayName || file.name.replace(/\.(ydk|ydkx)$/i, ''),
                        format: file.format || (file.name.toLowerCase().endsWith('.ydkx') ? 'ydkx' : 'ydk'),
                        cardPool: file.cardPool || null
                    }));
                    resolve(files);
                };
                request.onerror = () => reject(request.error);
            });
        }

        function normalizeOfflineDeckRecord(record) {
            if (!record) return null;
            return {
                id: record.id,
                name: record.name,
                main: Array.isArray(record.main) ? [...record.main] : [],
                side: Array.isArray(record.side) ? [...record.side] : [],
                extra: Array.isArray(record.extra) ? [...record.extra] : [],
                sidingPatterns: record.sidingPatterns ? JSON.parse(JSON.stringify(record.sidingPatterns)) : {},
                cardPool: Array.isArray(record.cardPool) ? [...record.cardPool] : [],
                createdAt: record.createdAt || record.updatedAt || new Date().toISOString(),
                updatedAt: record.updatedAt || record.createdAt || new Date().toISOString(),
                sync: record.sync ? { ...record.sync } : null
            };
        }

        async function getOfflineDeckFromDB(id) {
            if (!ydkDB) await initYDKDatabase();
            return new Promise((resolve, reject) => {
                const transaction = ydkDB.transaction(['offlineDecks'], 'readonly');
                const store = transaction.objectStore('offlineDecks');
                const request = store.get(id);
                request.onsuccess = () => resolve(normalizeOfflineDeckRecord(request.result));
                request.onerror = () => reject(request.error);
            });
        }

        async function getAllOfflineDecksFromDB() {
            if (!ydkDB) await initYDKDatabase();
            return new Promise((resolve, reject) => {
                const transaction = ydkDB.transaction(['offlineDecks'], 'readonly');
                const store = transaction.objectStore('offlineDecks');
                const request = store.getAll();
                request.onsuccess = () => {
                    const decks = (request.result || []).map(normalizeOfflineDeckRecord);
                    decks.sort((a, b) => new Date(b.updatedAt || 0) - new Date(a.updatedAt || 0));
                    resolve(decks);
                };
                request.onerror = () => reject(request.error);
            });
        }

        async function saveOfflineDeckToDB(deck) {
            if (!deck || !deck.name) {
                throw new Error('Deck data must include a name.');
            }
            if (!ydkDB) await initYDKDatabase();

            const now = new Date().toISOString();
            const record = {
                id: deck.id || createOfflineDeckId(),
                name: deck.name,
                main: Array.isArray(deck.main) ? [...deck.main] : [],
                side: Array.isArray(deck.side) ? [...deck.side] : [],
                extra: Array.isArray(deck.extra) ? [...deck.extra] : [],
                sidingPatterns: deck.sidingPatterns ? JSON.parse(JSON.stringify(deck.sidingPatterns)) : {},
                cardPool: Array.isArray(deck.cardPool) ? [...deck.cardPool] : [],
                createdAt: deck.createdAt || now,
                updatedAt: now,
                sync: deck.sync ? { ...deck.sync } : null
            };

            return new Promise((resolve, reject) => {
                const transaction = ydkDB.transaction(['offlineDecks'], 'readwrite');
                const store = transaction.objectStore('offlineDecks');
                const request = store.put(record);
                request.onsuccess = () => resolve(normalizeOfflineDeckRecord(record));
                request.onerror = () => reject(request.error);
            });
        }

        async function deleteOfflineDeckFromDB(id) {
            if (!ydkDB) await initYDKDatabase();
            return new Promise((resolve, reject) => {
                const transaction = ydkDB.transaction(['offlineDecks'], 'readwrite');
                const store = transaction.objectStore('offlineDecks');
                const request = store.delete(id);
                request.onsuccess = () => resolve(true);
                request.onerror = () => reject(request.error);
            });
        }

        async function clearAllOfflineDecks() {
            if (!ydkDB) await initYDKDatabase();
            return new Promise((resolve, reject) => {
                const transaction = ydkDB.transaction(['offlineDecks'], 'readwrite');
                const store = transaction.objectStore('offlineDecks');
                const request = store.clear();
                request.onsuccess = () => resolve(true);
                request.onerror = () => reject(request.error);
            });
        }

        function buildYDKContent(deckData, options = {}) {
            const format = options.format || 'ydk';
            const main = Array.isArray(deckData.main) ? deckData.main : [];
            const side = Array.isArray(deckData.side) ? deckData.side : [];
            const extra = Array.isArray(deckData.extra) ? deckData.extra : [];
            let content = '#main\n';
            content += main.join('\n');
            content += '\n!side\n';
            content += side.join('\n');
            if (extra.length > 0) {
                content += '\n#extra\n';
                content += extra.join('\n');
            }
            if (format === 'ydkx') {
                const extended = {
                    version: '1.0',
                    cardPool: Array.isArray(deckData.cardPool) ? deckData.cardPool : [],
                    configurations: options.configurations || {}
                };
                content += `\n#ydkx-extended\n${JSON.stringify(extended, null, 2)}`;
            }
            return content;
        }

        async function persistYDKFileToFolder(name, content) {
            const handle = ydkFileHandles.get(name);
            if (!handle) return;
            try {
                const writable = await handle.createWritable();
                await writable.write(content);
                await writable.close();
                console.log(`[DEBUG] Updated YDK file on disk: ${name}`);
            } catch (error) {
                console.error('Error writing YDK file to folder:', error);
                showTooltip('Could not update deck file on disk. Check folder permissions.');
            }
        }

        async function syncYDKFromDeck(deckRecord, deckData) {
            if (!deckRecord?.sync) return deckRecord;
            const syncMeta = { ...deckRecord.sync };
            const format = syncMeta.format || (currentDeckFormat === 'ydkx' ? 'ydkx' : 'ydk');
            syncMeta.format = format;
            const fileName = syncMeta.name;
            if (!fileName) return deckRecord;

            const ydkContent = buildYDKContent(deckData, { format, configurations: deckData.configurations });
            await saveYDKFileToDB(fileName, ydkContent, {
                displayName: syncMeta.displayName || deckRecord.name,
                format,
                cardPool: deckData.cardPool || []
            });

            await loadYDKFilesFromDB({ silent: true });
            if (!ydkFileHandles.has(fileName) && ydkFolder && typeof ydkFolder.getFileHandle === 'function') {
                try {
                    const handle = await ydkFolder.getFileHandle(fileName, { create: true });
                    ydkFileHandles.set(fileName, handle);
                } catch (error) {
                    console.warn('Unable to access YDK folder handle for write:', error);
                }
            }
            if (ydkFileHandles.has(fileName)) {
                await persistYDKFileToFolder(fileName, ydkContent);
            }

            return { ...deckRecord, sync: syncMeta };
        }

        async function migrateOfflineStorage() {
            try {
                const files = await getAllYDKFilesFromDB();
                for (const file of files) {
                    const requiresUpdate = !file.displayName || !file.format;
                    if (!requiresUpdate) continue;
                    await saveYDKFileToDB(file.name, file.content, {
                        displayName: file.displayName || file.name.replace(/\.(ydk|ydkx)$/i, ''),
                        format: file.format || (file.name.toLowerCase().endsWith('.ydkx') ? 'ydkx' : 'ydk'),
                        cardPool: file.cardPool || null,
                        lastModified: file.lastModified
                    });
                }
            } catch (error) {
                console.warn('YDK storage migration skipped:', error);
            }

            try {
                const decks = await getAllOfflineDecksFromDB();
                for (const deck of decks) {
                    if (!deck.sync || deck.sync.type) continue;
                    deck.sync.type = 'ydk-storage';
                    deck.sync.format = deck.sync.format || 'ydk';
                    await saveOfflineDeckToDB(deck);
                }
            } catch (error) {
                console.warn('Offline deck migration skipped:', error);
            }
        }

        async function deleteYDKFileFromDB(name) {
            if (!ydkDB) await initYDKDatabase();
            
            return new Promise((resolve, reject) => {
                const transaction = ydkDB.transaction(['ydkFiles'], 'readwrite');
                const store = transaction.objectStore('ydkFiles');
                const request = store.delete(name);
                
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async function clearAllYDKFiles() {
            if (!ydkDB) await initYDKDatabase();
            
            return new Promise((resolve, reject) => {
                const transaction = ydkDB.transaction(['ydkFiles'], 'readwrite');
                const store = transaction.objectStore('ydkFiles');
                const request = store.clear();
                
                request.onsuccess = () => {
                    ydkFileHandles = new Map();
                    resolve(request.result);
                };
                request.onerror = () => reject(request.error);
            });
        }

        async function loadYDKFilesFromDB(options = {}) {
            const { silent = false } = options;
            try {
                const storedFiles = await getAllYDKFilesFromDB();
                ydkFiles = storedFiles.map(file => ({
                    name: file.name,
                    displayName: file.displayName,
                    content: file.content,
                    lastModified: file.lastModified,
                    format: file.format,
                    cardPool: file.cardPool || null
                }));
                
                updateYDKDeckSelector();
                updateYDKFolderStatus();
                
                if (!silent && ydkFiles.length > 0) {
                    showMessage(`Loaded ${ydkFiles.length} YDK files from storage.`);
                }
                
                return ydkFiles;
            } catch (error) {
                console.error('Error loading YDK files from IndexedDB:', error);
                showMessage('Error loading stored YDK files.');
                return [];
            }
        }

        // --- YDK FOLDER MANAGEMENT FUNCTIONS ---
        // --- NEW USER STARTUP FLOW ---
        function isNewUser() {
            // Check if user has any stored data
            const hasYDKFiles = ydkFiles.length > 0;
            const hasOfflineDecks = offlineDecks.length > 0;
            const hasOnlineDecks = deckLists.length > 0;
            const hasStoredFolder = localStorage.getItem('ydkFolderPath') !== null;
            const hasSeenWelcome = localStorage.getItem('hasSeenWelcome') === 'true';
            
            console.log('[DEBUG] New user check:', {
                hasYDKFiles,
                hasOfflineDecks,
                hasOnlineDecks,
                hasStoredFolder,
                hasSeenWelcome,
                ydkFilesLength: ydkFiles.length,
                offlineDecksLength: offlineDecks.length,
                deckListsLength: deckLists.length
            });
            
            // User is new if they have no decks, no YDK files, no stored folder, and haven't seen welcome
            const isNew = !hasYDKFiles && !hasOfflineDecks && !hasOnlineDecks && !hasStoredFolder && !hasSeenWelcome;
            console.log('[DEBUG] Is new user:', isNew);
            return isNew;
        }

        async function showNewUserStartupModal() {
            console.log('[DEBUG] Creating new user startup modal...');
            
            // Create modal HTML
            const modalHTML = `
                <div id="newUserModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                    <div class="bg-white rounded-lg p-6 max-w-md w-full mx-4">
                        <h2 class="text-xl font-bold mb-4 text-center">Welcome to Kaihari Master Tool!</h2>
                        <p class="text-gray-600 mb-6 text-center">Let's get you started by importing your Yu-Gi-Oh! deck files.</p>
                        
                        <div class="space-y-3">
                            <button id="importFolderBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center">
                                <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z"></path>
                                </svg>
                                Import YDK Folder
                            </button>
                            
                            <button id="importSingleFileBtn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center">
                                <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                                </svg>
                                Import Single YDK File
                            </button>
                            
                            <button id="skipImportBtn" class="w-full bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-4 rounded-lg">
                                Skip for Now
                            </button>
                        </div>
                        
                        <p class="text-sm text-gray-500 mt-4 text-center">
                            You can import files later using the Import buttons in the deck builder.
                        </p>
                    </div>
                </div>
            `;
            
            // Add modal to page
            document.body.insertAdjacentHTML('beforeend', modalHTML);
            console.log('[DEBUG] Modal HTML added to page');
            
            const modal = document.getElementById('newUserModal');
            const importFolderBtn = document.getElementById('importFolderBtn');
            const importSingleFileBtn = document.getElementById('importSingleFileBtn');
            const skipImportBtn = document.getElementById('skipImportBtn');
            
            console.log('[DEBUG] Modal elements found:', {
                modal: !!modal,
                importFolderBtn: !!importFolderBtn,
                importSingleFileBtn: !!importSingleFileBtn,
                skipImportBtn: !!skipImportBtn
            });
            
            // Handle folder import
            importFolderBtn.addEventListener('click', async () => {
                console.log('[DEBUG] Import folder button clicked');
                modal.remove();
                await handleNewUserFolderImport();
            });
            
            // Handle single file import
            importSingleFileBtn.addEventListener('click', async () => {
                console.log('[DEBUG] Import single file button clicked');
                modal.remove();
                await handleNewUserSingleFileImport();
            });
            
            // Handle skip
            skipImportBtn.addEventListener('click', () => {
                console.log('[DEBUG] Skip button clicked');
                modal.remove();
                localStorage.setItem('hasSeenWelcome', 'true');
                showTooltip('Welcome! You can import YDK files anytime using the Import buttons.');
            });
            
            console.log('[DEBUG] Event listeners added to modal buttons');
        }

        async function handleNewUserFolderImport() {
            try {
                if (!('showDirectoryPicker' in window)) {
                    showTooltip('File System Access API not supported in this browser. Please use single file import instead.');
                    return;
                }
                
                showTooltip('Select a folder containing your YDK files...');
                ydkFolder = await window.showDirectoryPicker();
                ydkFolderPath = ydkFolder.name;
                ydkFileHandles = new Map();
                
                // Save folder path for reference
                localStorage.setItem('ydkFolderPath', ydkFolderPath);
                
                // Import all YDK files from the folder
                await importYDKFolder();
                
                if (ydkFiles.length > 0) {
                    showTooltip(`Imported ${ydkFiles.length} YDK files from ${ydkFolderPath}`);
                    
                    // Auto-load the first deck
                    await loadYDKDeck(0);
                    showTooltip(`Auto-loaded: ${ydkFiles[0].displayName}`);
                } else {
                    showTooltip('No YDK files found in the selected folder.');
                }
                
                localStorage.setItem('hasSeenWelcome', 'true');
            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.error('Error importing folder:', error);
                    showTooltip('Error importing folder. Please try again.');
                }
            }
        }

        async function handleNewUserSingleFileImport() {
            // Create a hidden file input
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '.ydk,.ydkx';
            fileInput.style.display = 'none';
            document.body.appendChild(fileInput);
            
            // Show file picker
            fileInput.click();
            
            // Handle file selection
            fileInput.addEventListener('change', async (event) => {
                const file = event.target.files[0];
                if (!file) {
                    document.body.removeChild(fileInput);
                    return;
                }
                
                try {
                    showTooltip('Importing YDK file...');
                    
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        const content = e.target.result;
                        await saveYDKFileToDB(file.name, content, { 
                            format: file.name.toLowerCase().endsWith('.ydkx') ? 'ydkx' : 'ydk', 
                            displayName: file.name.replace(/\.(ydk|ydkx)$/i, '') 
                        });
                        
                        // Reload files from IndexedDB
                        await loadYDKFilesFromDB();
                        
                        if (ydkFiles.length > 0) {
                            showTooltip(`Imported YDK file: ${file.name}`);
                            
                            // Auto-load the imported deck
                            await loadYDKDeck(0);
                            showTooltip(`Auto-loaded: ${ydkFiles[0].displayName}`);
                        }
                        
                        localStorage.setItem('hasSeenWelcome', 'true');
                    };
                    reader.readAsText(file);
                } catch (error) {
                    console.error('Error importing single file:', error);
                    showTooltip('Error importing YDK file. Please try again.');
                } finally {
                    document.body.removeChild(fileInput);
                }
            });
        }

        async function tryAccessDefaultYDKFolder() {
            try {
                console.log('[DEBUG] tryAccessDefaultYDKFolder called');
                
                // Check if this is a new user
                if (isNewUser()) {
                    console.log('[DEBUG] New user detected, showing startup modal');
                    await showNewUserStartupModal();
                    return;
                }
                
                console.log('[DEBUG] Existing user, showing normal message');
                
                // Existing user flow
                const savedFolderPath = localStorage.getItem('ydkFolderPath');
                if (savedFolderPath) {
                    // Show a helpful message about the previously selected folder
                    showTooltip(`No YDK files stored. Previously selected folder: ${savedFolderPath}. Use "Import YDK Folder" to import files.`);
                } else {
                    // User has seen welcome but no folder selected
                    showTooltip('No YDK files stored. Use "Import YDK Folder" or "Import YDK File" to add your deck files.');
                }
            } catch (error) {
                console.log('Could not access default YDK folder:', error);
            }
        }

        async function selectYDKFolder() {
            try {
                if (!('showDirectoryPicker' in window)) {
                    showMessage('File System Access API not supported in this browser.');
                    return;
                }
                
                ydkFolder = await window.showDirectoryPicker();
                ydkFolderPath = ydkFolder.name;
                ydkFileHandles = new Map();
                
                // Save folder path for reference
                localStorage.setItem('ydkFolderPath', ydkFolderPath);
                
                // Import all YDK files from the folder
                await importYDKFolder();
                
                showMessage(`Imported ${ydkFiles.length} YDK files from ${ydkFolderPath}`);
            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.error('Error selecting YDK folder:', error);
                    showMessage('Error selecting YDK folder.');
                }
            }
        }

        async function importYDKFolder() {
            if (!ydkFolder) return;
            
            try {
                const filesToImport = [];
                
                // Scan folder for YDK files
                for await (const [name, handle] of ydkFolder.entries()) {
                    if ((name.toLowerCase().endsWith('.ydk') || name.toLowerCase().endsWith('.ydkx')) && handle.kind === 'file') {
                        const fileData = await handle.getFile();
                        const content = await fileData.text();
                        filesToImport.push({ name, content, handle, format: name.toLowerCase().endsWith('.ydkx') ? 'ydkx' : 'ydk' });
                        ydkFileHandles.set(name, handle);
                    }
                }
                
                // Save all files to IndexedDB
                for (const file of filesToImport) {
                    await saveYDKFileToDB(file.name, file.content, { format: file.format, displayName: file.name.replace(/\.(ydk|ydkx)$/i, '') });
                }
                
                // Reload files from IndexedDB
                await loadYDKFilesFromDB();
                
                // Enable/disable UI elements
                if (UI.ydkDeckSelector) UI.ydkDeckSelector.disabled = ydkFiles.length === 0;
                if (UI.setDefaultDeckBtn) UI.setDefaultDeckBtn.disabled = ydkFiles.length === 0;
                
            } catch (error) {
                console.error('Error importing YDK folder:', error);
                showMessage('Error importing YDK files from folder.');
            }
        }

        async function importSingleYDKFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            try {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    const content = e.target.result;
                    await saveYDKFileToDB(file.name, content, { format: file.name.toLowerCase().endsWith('.ydkx') ? 'ydkx' : 'ydk', displayName: file.name.replace(/\.(ydk|ydkx)$/i, '') });
                    
                    // Reload files from IndexedDB
                    await loadYDKFilesFromDB();
                    
                    // Enable/disable UI elements
                    if (UI.ydkDeckSelector) UI.ydkDeckSelector.disabled = ydkFiles.length === 0;
                    if (UI.setDefaultDeckBtn) UI.setDefaultDeckBtn.disabled = ydkFiles.length === 0;
                    
                    showTooltip(`Imported YDK file: ${file.name}`);
                };
                reader.readAsText(file);
            } catch (error) {
                console.error('Error importing single YDK file:', error);
                showTooltip('Error importing YDK file.');
            }
            
            // Clear the input
            event.target.value = null;
        }

        function openYDKManagementModal() {
            if (!UI.ydkManagementModal) return;
            
            renderYDKFilesList();
            UI.ydkManagementModal.classList.remove('hidden');
        }

        function renderYDKFilesList() {
            if (!UI.ydkFilesList) return;
            
            UI.ydkFilesList.innerHTML = '';
            
            if (ydkFiles.length === 0) {
                UI.ydkFilesList.innerHTML = '<p class="text-gray-400 text-center">No YDK files stored</p>';
                return;
            }
            
            ydkFiles.forEach((file, index) => {
                const fileEl = document.createElement('div');
                fileEl.className = 'flex items-center justify-between bg-slate-700 p-3 rounded-lg';
                
                const lastModified = new Date(file.lastModified).toLocaleDateString();
                
                fileEl.innerHTML = `
                    <div class="flex-1">
                        <div class="font-medium text-white">${file.displayName}</div>
                        <div class="text-sm text-gray-400">Imported: ${lastModified}</div>
                    </div>
                    <div class="flex gap-2">
                        <button class="delete-ydk-file bg-red-600 hover:bg-red-700 text-white font-bold py-1 px-2 rounded text-sm" data-name="${file.name}">Delete</button>
                    </div>
                `;
                
                // Add delete event listener
                const deleteBtn = fileEl.querySelector('.delete-ydk-file');
                deleteBtn.addEventListener('click', async () => {
                    if (confirm(`Delete ${file.displayName}?`)) {
                        await deleteYDKFileFromDB(file.name);
                        await loadYDKFilesFromDB();
                        renderYDKFilesList();
                        showMessage(`Deleted ${file.displayName}`);
                    }
                });
                
                UI.ydkFilesList.appendChild(fileEl);
            });
        }

        async function handleClearAllYDKFiles() {
            if (confirm('Clear all stored YDK files? This cannot be undone.')) {
                try {
                    await clearAllYDKFiles();
                    ydkFiles = [];
                    updateYDKDeckSelector();
                    updateYDKFolderStatus();
                    renderYDKFilesList();
                    showMessage('All YDK files cleared');
                } catch (error) {
                    console.error('Error clearing YDK files:', error);
                    showMessage('Error clearing YDK files');
                }
            }
        }

        async function scanYDKFolder() {
            if (!ydkFolder) return;
            
            ydkFiles = [];
            ydkFileHandles = new Map();
            try {
                for await (const [name, handle] of ydkFolder.entries()) {
                    if ((name.toLowerCase().endsWith('.ydk') || name.toLowerCase().endsWith('.ydkx')) && handle.kind === 'file') {
                        ydkFiles.push({
                            name: name,
                            handle: handle,
                            displayName: name.replace('.ydk', '')
                        });
                        ydkFileHandles.set(name, handle);
                    }
                }
                updateYDKDeckSelector();
            } catch (error) {
                console.error('Error scanning YDK folder:', error);
                showMessage('Error scanning YDK folder.');
            }
        }

        function updateYDKFolderStatus() {
            if (!UI.ydkFolderStatus) return;
            
            if (ydkFiles.length > 0) {
                UI.ydkFolderStatus.textContent = `${ydkFiles.length} YDK files stored`;
                UI.ydkFolderStatus.className = 'text-green-400 text-sm';
                
                // Show sync button if folder was previously selected
                const savedFolderPath = localStorage.getItem('ydkFolderPath');
                if (savedFolderPath && UI.syncFolderBtn) {
                    UI.syncFolderBtn.classList.remove('hidden');
                    UI.syncFolderBtn.textContent = `Sync: ${savedFolderPath}`;
                }
            } else {
                UI.ydkFolderStatus.textContent = 'No YDK files stored';
                UI.ydkFolderStatus.className = 'text-gray-400 text-sm';
                
                // Hide sync button
                if (UI.syncFolderBtn) UI.syncFolderBtn.classList.add('hidden');
            }
        }

        function updateYDKDeckSelector() {
            if (!UI.ydkDeckSelector) return;
            
            // Clear existing options
            UI.ydkDeckSelector.innerHTML = '';
            
            if (ydkFiles.length === 0) {
                const option = document.createElement('option');
                option.value = '';
                option.textContent = 'No YDK files found';
                UI.ydkDeckSelector.appendChild(option);
                return;
            }
            
            // Add options for each YDK file
            ydkFiles.forEach((file, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = file.displayName;
                UI.ydkDeckSelector.appendChild(option);
            });
            
            // Enable the dropdown since we have files
            UI.ydkDeckSelector.disabled = false;
            if (UI.setDefaultDeckBtn) UI.setDefaultDeckBtn.disabled = false;
            
            // Select the default deck in dropdown if set (but don't auto-load it here)
            if (defaultDeckName) {
                const defaultIndex = ydkFiles.findIndex(f => f.displayName === defaultDeckName);
                if (defaultIndex !== -1) {
                    UI.ydkDeckSelector.value = defaultIndex;
                    // Note: autoLoadYDKOnStartup will handle the actual loading
                }
            }
        }

        let isLoadingYDK = false; // Guard to prevent multiple simultaneous loads
        
        async function loadYDKDeck(index) {
            console.log(`[DEBUG] loadYDKDeck called with index: ${index}`);
            
            // Prevent loading if already loading
            if (isLoadingYDK) {
                console.log(`[DEBUG] Already loading a YDK deck, skipping duplicate call`);
                return;
            }
            
            if (!ydkFiles[index]) {
                console.log(`[DEBUG] No YDK file found at index ${index}`);
                return;
            }

            if (!confirmDiscardDeckChanges()) {
                return;
            }
            
            try {
                isLoadingYDK = true; // Set guard
                const file = ydkFiles[index];
                console.log(`[DEBUG] Loading YDK file: ${file.displayName}`);
                const content = file.content; // Content is already stored in IndexedDB
                console.log(`[DEBUG] YDK content length: ${content.length}`);
                
                // Parse YDK content
                const lines = content.split('\n').map(l => l.trim()).filter(Boolean);
                let currentSection = '';
                const importedDeck = { main: [], side: [], extra: [] };

                for(const line of lines) {
                    if (line === '#main') { currentSection = 'main'; continue; }
                    if (line === '!side') { currentSection = 'side'; continue; }
                    if (line === '#extra') { currentSection = 'extra'; continue; }
                    if ((currentSection === 'main' || currentSection === 'side' || currentSection === 'extra') && !isNaN(parseInt(line))) {
                        importedDeck[currentSection].push(line);
                    }
                }
                
                console.log(`[DEBUG] Parsed deck - Main: ${importedDeck.main.length}, Side: ${importedDeck.side.length}, Extra: ${importedDeck.extra.length}`);
                
                // Check if cards exist in database
                const allCardIds = [...new Set([...importedDeck.main, ...importedDeck.side, ...importedDeck.extra])];
                const missingCards = allCardIds.filter(id => !cardDatabase.some(c => c.id === id));
                
                if (missingCards.length > 0) {
                    console.log(`[DEBUG] Found ${missingCards.length} missing cards:`, missingCards);
                    showMessage(`Deck loaded but ${missingCards.length} cards are not in the database. Attempting to fetch missing cards...`);
                    
                    // Try to fetch missing cards
                    try {
                        await fetchAndAddMissingCards(missingCards);
                        showMessage(`Successfully fetched ${missingCards.length} missing cards.`);
                    } catch (error) {
                        console.error('Error fetching missing cards:', error);
                        showMessage(`Deck loaded but ${missingCards.length} cards could not be fetched. Please add them manually to the card database.`);
                    }
                }
                
                // Load the deck
                currentDeck.main = importedDeck.main;
                currentDeck.side = importedDeck.side;
                currentDeck.extra = importedDeck.extra || [];
                currentDeck.sidingPatterns = {};
                UI.deckNameInput.value = file.displayName;
                currentDeckId = null;
                currentDeckSource = 'ydk';
                currentDeckMeta = { name: file.displayName, sync: { type: 'ydk-storage', name: file.name, format: file.format || 'ydk', displayName: file.displayName } };
                isDeckDirty = false;
                currentDeckFormat = file.format || 'ydk';
                
                // Filter card database to only show cards in this deck
                console.log(`[DEBUG] Filtering card database for YDK deck. Original size: ${originalCardDatabase.length}`);
                cardDatabase = originalCardDatabase.filter(card => allCardIds.includes(card.id));
                console.log(`[DEBUG] Filtered card database to ${cardDatabase.length} cards`);
                
                console.log(`[DEBUG] About to render deck with ${currentDeck.main.length} main deck cards`);
                renderCurrentDeck();
                renderCardDatabase(); // Re-render card database with filtered pool
                populateSimulationSetup();
                
                if (missingCards.length === 0) {
                    showTooltip(`Loaded deck: ${file.displayName}`);
                } else {
                    showTooltip(`Loaded deck: ${file.displayName} (${missingCards.length} cards missing from database)`);
                }
            } catch (error) {
                console.error('Error loading YDK deck:', error);
                showTooltip('Error loading YDK deck.');
            } finally {
                isLoadingYDK = false; // Reset guard
                console.log(`[DEBUG] Finished loading YDK deck, reset guard`);
            }
        }

        function setDefaultYDKDeck() {
            const selectedIndex = UI.ydkDeckSelector.value;
            if (selectedIndex === '' || !ydkFiles[selectedIndex]) return;
            
            defaultDeckName = ydkFiles[selectedIndex].displayName;
            localStorage.setItem('defaultYDKDeck', defaultDeckName);
            showMessage(`Set ${defaultDeckName} as default deck`);
        }

        function loadDefaultYDKDeck() {
            const saved = localStorage.getItem('defaultYDKDeck');
            if (saved) {
                defaultDeckName = saved;
            }
        }

        async function autoLoadYDKOnStartup() {
            if (ydkFiles.length === 0) return;
            
            if (ydkFiles.length === 1) {
                // Auto-load single YDK file
                await loadYDKDeck(0);
                showTooltip(`Auto-loaded: ${ydkFiles[0].displayName}`);
            } else if (defaultDeckName) {
                // Load default deck if set
                const defaultIndex = ydkFiles.findIndex(f => f.displayName === defaultDeckName);
                if (defaultIndex !== -1) {
                    await loadYDKDeck(defaultIndex);
                    showTooltip(`Auto-loaded default deck: ${defaultDeckName}`);
                } else {
                    showTooltip(`Found ${ydkFiles.length} YDK files. Please select one from the dropdown.`);
                }
            } else {
                showTooltip(`Found ${ydkFiles.length} YDK files. Please select one from the dropdown.`);
            }
        }

        async function fetchAndAddMissingCards(cardIds) {
            const fetchPromises = cardIds.map(id =>
                fetch(`https://db.ygoprodeck.com/api/v7/cardinfo.php?id=${id}`)
                    .then(res => res.ok ? res.json() : Promise.reject(`Failed to fetch ${id}`))
                    .then(data => {
                        if (data.data && data.data[0]) {
                            const cardData = data.data[0];
                            return {
                                id: cardData.id.toString(),
                                name: cardData.name,
                                type: cardData.type,
                                imageUrl: cardData.card_images[0].image_url
                            };
                        }
                        return null;
                    })
                    .catch(err => {
                        console.warn(`Could not fetch card ID ${id}:`, err);
                        return null;
                    })
            );

            const newCards = (await Promise.all(fetchPromises)).filter(Boolean);

            if (newCards.length === 0) return;

            // Filter out cards that already exist in the ORIGINAL database (check for duplicates)
            // Must check against originalCardDatabase, not cardDatabase (which might be filtered)
            const cardsToAdd = newCards.filter(newCard => !originalCardDatabase.some(existingCard => existingCard.id === newCard.id));
            
            if (cardsToAdd.length === 0) {
                console.log('[DEBUG] All cards already exist in database, skipping add');
                return;
            }
            
            console.log(`[DEBUG] Adding ${cardsToAdd.length} new cards to database (${newCards.length - cardsToAdd.length} already existed)`);

            // Add to original database first
            originalCardDatabase.push(...cardsToAdd);
            originalCardDatabase.sort((a, b) => a.name.localeCompare(b.name));
            
            // Also add to current filtered database if not already present
            const cardsToAddToFiltered = cardsToAdd.filter(newCard => !cardDatabase.some(existingCard => existingCard.id === newCard.id));
            cardDatabase.push(...cardsToAddToFiltered);
            cardDatabase.sort((a, b) => a.name.localeCompare(b.name));
            renderCardDatabase(); // Refresh the DB view

            // Save to localStorage in offline mode
            if (isOffline) {
                try {
                    const savedCards = JSON.parse(localStorage.getItem('offlineCardDatabase') || '[]');
                    // Also check localStorage for duplicates
                    const cardsToSave = cardsToAdd.filter(card => !savedCards.some(saved => saved.id === card.id));
                    if (cardsToSave.length > 0) {
                        savedCards.push(...cardsToSave);
                        localStorage.setItem('offlineCardDatabase', JSON.stringify(savedCards));
                        console.log(`[DEBUG] Saved ${cardsToSave.length} cards to localStorage`);
                    }
                } catch (e) {
                    console.error('Error saving cards to localStorage:', e);
                }
            } else {
                // If online, also save to Firebase
                const batch = writeBatch(db);
                cardsToAdd.forEach(card => {
                    const docRef = doc(db, `artifacts/${appId}/users/${userId}/cards`, card.id);
                    batch.set(docRef, card);
                });
                await batch.commit();
            }
        }

        // --- RENDERING & DRAG-DROP LOGIC ---
        function getCardType(card) {
            if (!card || !card.type) return 'Unknown';
            if (card.type.includes('Monster')) return 'Monster';
            if (card.type.includes('Spell')) return 'Spell';
            if (card.type.includes('Trap')) return 'Trap';
            return 'Unknown';
        }

        function renderCardDatabase() {
            if (cardDatabaseView === 'grid') {
                renderCardDatabaseGrid();
                return;
            }
            
            UI.cardDbList.innerHTML = '';
            UI.cardDbList.className = 'space-y-2 overflow-y-auto pr-2 flex-grow';
            cardDatabase.forEach(card => {
                const cardEl = document.createElement('div');
                cardEl.className = 'p-2 flex items-center justify-between bg-[var(--color-surface-2)]/50 rounded-lg';
                cardEl.setAttribute('data-card-id', card.id); // Add data attribute for filtering
                
                // Build the buttons section based on edit mode
                let buttonsHtml = '';
                if (editMode) {
                    buttonsHtml = `
                        <button data-action="delete" data-id="${card.id}" class="text-red-400 hover:text-red-300 text-xs font-bold flex items-center gap-1" title="Delete from Database">
                            <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                            </svg>
                            DELETE
                        </button>`;
                } else {
                    buttonsHtml = `
                        <button data-action="add-side" data-id="${card.id}" class="text-yellow-400 hover:text-yellow-300 text-xs font-bold" title="Add to Side Deck">SIDE</button>
                        <button data-action="add-main" data-id="${card.id}" class="text-green-400 hover:text-green-300 text-xs font-bold" title="Add to Main Deck">MAIN</button>
                        <button data-action="add-extra" data-id="${card.id}" class="text-blue-400 hover:text-blue-300 text-xs font-bold" title="Add to Extra Deck">EXTRA</button>`;
                }
                
                cardEl.innerHTML = `
                    <div class="flex items-center gap-3 overflow-hidden">
                        <img src="${card.imageUrl}" class="w-10 h-auto rounded-md flex-shrink-0" onerror="this.onerror=null;this.src='https://placehold.co/40x58/2d3748/e2e8f0?text=?';">
                        <span class="text-sm font-medium truncate">${card.name}</span>
                    </div>
                    <div class="flex items-center gap-2 flex-shrink-0">
                        ${buttonsHtml}
                    </div>`;
                UI.cardDbList.appendChild(cardEl);
            });

            // Remove any existing event listeners first to prevent duplicates
            UI.cardDbList.querySelectorAll('button').forEach(btn => {
                btn.replaceWith(btn.cloneNode(true));
            });
            
            UI.cardDbList.querySelectorAll('button').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const action = e.currentTarget.dataset.action;
                    const id = e.currentTarget.dataset.id;
                    if (action === 'add-main') addCardToDeck(id, 'main');
                    else if (action === 'add-side') addCardToDeck(id, 'side');
                    else if (action === 'add-extra') addCardToDeck(id, 'extra');
                    else if (action === 'delete') deleteCardFromDb(id);
                });
            });
        }
        
        function renderCardDatabaseGrid() {
            UI.cardDbList.innerHTML = '';
            UI.cardDbList.className = 'card-db-grid overflow-y-auto pr-2 flex-grow';
            
            // Show/hide selection controls based on edit mode and view
            if (editMode && cardDatabaseView === 'grid') {
                UI.gridSelectionControls.classList.remove('hidden');
                updateSelectedCount();
            } else {
                UI.gridSelectionControls.classList.add('hidden');
            }
            
            cardDatabase.forEach(card => {
                const cardEl = document.createElement('div');
                cardEl.className = 'card-item';
                cardEl.setAttribute('data-card-id', card.id);
                cardEl.draggable = !editMode; // Disable drag in edit mode
                
                // Build content based on edit mode
                let content = `
                    <img src="${card.imageUrl}" 
                         class="w-full h-full object-cover" 
                         title="${card.name}" 
                         onerror="this.onerror=null;this.src='https://placehold.co/80x112/2d3748/e2e8f0?text=?';">
                `;
                
                if (editMode) {
                    const isSelected = selectedGridCards.has(card.id);
                    cardEl.classList.add('edit-mode');
                    content = `
                        <div class="relative w-full h-full">
                            <input type="checkbox" 
                                   class="absolute top-2 left-2 z-10 w-4 h-4 text-blue-600 bg-white rounded border-gray-300 focus:ring-blue-500" 
                                   ${isSelected ? 'checked' : ''}
                                   data-card-id="${card.id}">
                            <img src="${card.imageUrl}" 
                                 class="w-full h-full object-cover" 
                                 title="${card.name}" 
                                 onerror="this.onerror=null;this.src='https://placehold.co/80x112/2d3748/e2e8f0?text=?';">
                        </div>
                    `;
                    if (isSelected) {
                        cardEl.classList.add('selected');
                    }
                }
                
                cardEl.innerHTML = content;
                
                // Add event listeners based on mode
                if (editMode) {
                    // Edit mode: checkbox selection
                    const checkbox = cardEl.querySelector('input[type="checkbox"]');
                    
                    // Make entire card clickable to toggle checkbox
                    cardEl.addEventListener('click', (e) => {
                        // Don't toggle if clicking directly on checkbox (to avoid double-toggle)
                        if (e.target.type === 'checkbox') return;
                        
                        checkbox.checked = !checkbox.checked;
                        checkbox.dispatchEvent(new Event('change'));
                    });
                    
                    checkbox.addEventListener('change', (e) => {
                        if (e.target.checked) {
                            selectedGridCards.add(card.id);
                            cardEl.classList.add('selected');
                        } else {
                            selectedGridCards.delete(card.id);
                            cardEl.classList.remove('selected');
                        }
                        updateSelectedCount();
                    });
                } else {
                    // Normal mode: drag and drop
                    cardEl.addEventListener('dragstart', (e) => {
                        e.dataTransfer.setData('text/plain', card.id);
                        e.dataTransfer.effectAllowed = 'copy';
                        cardEl.classList.add('dragging');
                    });
                    
                    cardEl.addEventListener('dragend', (e) => {
                        cardEl.classList.remove('dragging');
                    });
                    
                    // Shift+click - add card to side deck
                    cardEl.addEventListener('click', (e) => {
                        if (e.shiftKey) {
                            e.preventDefault();
                            addCardToDeck(card.id, 'side');
                        }
                    });
                    
                    // Right click - add card to main deck
                    cardEl.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        addCardToDeck(card.id, 'main');
                    });
                }
                
                UI.cardDbList.appendChild(cardEl);
            });
        }
        
        function updateSelectedCount() {
            if (UI.selectedCount) {
                UI.selectedCount.textContent = selectedGridCards.size;
            }
        }
        
        function selectAllGridCards() {
            selectedGridCards.clear();
            cardDatabase.forEach(card => {
                selectedGridCards.add(card.id);
            });
            
            // Update checkboxes and visual selection
            UI.cardDbList.querySelectorAll('.card-item').forEach((cardEl, index) => {
                const checkbox = cardEl.querySelector('input[type="checkbox"]');
                if (checkbox) {
                    checkbox.checked = true;
                    cardEl.classList.add('selected');
                }
            });
            
            updateSelectedCount();
        }
        
        function clearGridSelection() {
            selectedGridCards.clear();
            
            // Update checkboxes and visual selection
            UI.cardDbList.querySelectorAll('.card-item').forEach(cardEl => {
                const checkbox = cardEl.querySelector('input[type="checkbox"]');
                if (checkbox) {
                    checkbox.checked = false;
                    cardEl.classList.remove('selected');
                }
            });
            
            updateSelectedCount();
        }
        
        function deleteSelectedGridCards() {
            if (selectedGridCards.size === 0) {
                showMessage("No cards selected for deletion.");
                return;
            }
            
            const cardNames = Array.from(selectedGridCards).map(id => {
                const card = cardDatabase.find(c => c.id === id);
                return card ? card.name : id;
            });
            
            showConfirmModal(
                `Are you sure you want to delete ${selectedGridCards.size} card(s)?\n\n${cardNames.slice(0, 5).join(', ')}${cardNames.length > 5 ? '...' : ''}`,
                () => {
                    // Delete cards from database without individual confirmations
                    const cardsToDelete = Array.from(selectedGridCards);
                    const deletedCount = cardsToDelete.length;
                    
                    // Remove from local database
                    cardDatabase = cardDatabase.filter(card => !selectedGridCards.has(card.id));
                    originalCardDatabase = originalCardDatabase.filter(card => !selectedGridCards.has(card.id));
                    
                    // Update localStorage if in offline mode
                    if (isOffline) {
                        try {
                            const savedCards = JSON.parse(localStorage.getItem('offlineCardDatabase') || '[]');
                            const updatedCards = savedCards.filter(card => !selectedGridCards.has(card.id));
                            localStorage.setItem('offlineCardDatabase', JSON.stringify(updatedCards));
                        } catch(e) {
                            console.error('Error updating localStorage:', e);
                        }
                    }
                    
                    // Clear selection and re-render
                    selectedGridCards.clear();
                    renderCardDatabase();
                    populateSimulationSetup();
                    updateSelectedCount();
                    
                    showMessage(`Deleted ${deletedCount} card(s) from database.`);
                }
            );
        }
        
        function resetDatabase() {
            // Get all card IDs currently in the deck
            const deckCardIds = [...new Set([
                ...currentDeck.main,
                ...currentDeck.side,
                ...(currentDeck.extra || [])
            ])];
            
            if (deckCardIds.length === 0) {
                showMessage("Cannot reset database: deck is empty.");
                return;
            }
            
            showConfirmModal(
                `Reset database to only include cards from current deck?\n\nThis will remove all other cards from the database and keep only the ${deckCardIds.length} cards currently in your deck.`,
                async () => {
                    try {
                        // Store current card database for potential restoration
                        const currentCardDatabase = [...cardDatabase];
                        
                        // Clear the current database
                        cardDatabase = [];
                        
                        // Fetch missing cards and add them to the database
                        const missingCards = deckCardIds.filter(id => !currentCardDatabase.some(c => c.id === id));
                        
                        if (missingCards.length > 0) {
                            showMessage(`Fetching ${missingCards.length} missing card(s)...`);
                            await fetchAndAddMissingCards(missingCards);
                        }
                        
                        // Filter original database to only include deck cards
                        cardDatabase = originalCardDatabase.filter(card => deckCardIds.includes(card.id));
                        
                        // Update localStorage if in offline mode
                        if (isOffline) {
                            try {
                                localStorage.setItem('offlineCardDatabase', JSON.stringify(cardDatabase));
                            } catch(e) {
                                console.error('Error updating localStorage:', e);
                            }
                        }
                        
                        // Clear any grid selection
                        selectedGridCards.clear();
                        
                        // Re-render everything
                        renderCardDatabase();
                        populateSimulationSetup();
                        
                        showMessage(`Database reset! Now contains ${cardDatabase.length} cards from your deck.`);
                    } catch (error) {
                        console.error('Error resetting database:', error);
                        showMessage("Error resetting database. Please try again.");
                    }
                }
            );
        }
        
        function renderDeckPart(element, cardIds, partName) {
            console.log(`[DEBUG] renderDeckPart called for ${partName} with ${cardIds.length} cards`);
            console.log(`[DEBUG] cardDatabase has ${cardDatabase.length} cards`);
            element.innerHTML = ''; // Clear before rendering
            cardIds.forEach((cardId, index) => {
                const card = cardDatabase.find(c => c.id === cardId);
                if (!card) {
                    console.log(`[DEBUG] Card not found in database: ${cardId}`);
                    return;
                }
                
                const cardEl = document.createElement('div');
                cardEl.className = 'aspect-[2.5/3.5] rounded-md overflow-hidden shadow-lg cursor-grab transition-opacity';
                cardEl.draggable = true;
                cardEl.dataset.id = cardId;
                cardEl.dataset.part = partName;

                cardEl.innerHTML = `<img src="${card.imageUrl}" class="w-full h-full object-cover" title="${card.name}" onerror="this.onerror=null;this.src='https://placehold.co/100x140/2d3748/e2e8f0?text=?';">`;

                cardEl.addEventListener('dragstart', (e) => {
                    draggingElement = cardEl;
                    placeholder = document.createElement('div');
                    placeholder.className = 'placeholder';
                    
                    setTimeout(() => cardEl.classList.add('dragging'), 0);
                });

                cardEl.addEventListener('dragend', (e) => {
                    cardEl.classList.remove('dragging');
                    draggingElement = null;
                    placeholder?.remove();
                    placeholder = null;
                });

                cardEl.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    removeCardFromDeck(cardId, partName);
                });

                element.appendChild(cardEl);
            });
        }
        
        function getDragAfterElement(container, x, y) {
            const draggableElements = [...container.querySelectorAll('[draggable="true"]:not(.dragging)')];

            if (draggableElements.length === 0) {
                return null;
            }

            const closest = draggableElements.reduce(
                (acc, child) => {
                    const box = child.getBoundingClientRect();
                    const centerX = box.left + box.width / 2;
                    const centerY = box.top + box.height / 2;
                    const distance = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
                    
                    if (distance < acc.distance) {
                        return { distance, element: child };
                    } else {
                        return acc;
                    }
                },
                { distance: Number.POSITIVE_INFINITY, element: null }
            );

            const closestBox = closest.element.getBoundingClientRect();
            const isBefore = x < closestBox.left + closestBox.width / 2;

            if (isBefore) {
                return closest.element;
            } else {
                return closest.element.nextElementSibling;
            }
        }
        
        function updateDeckOrder() {
            currentDeck.main = Array.from(UI.mainDeckList.children).map(el => el.dataset.id);
            currentDeck.side = Array.from(UI.sideDeckList.children).map(el => el.dataset.id);
            currentDeck.extra = Array.from(UI.extraDeckList.children).map(el => el.dataset.id);
            markDeckDirty();
            updateDeckCounts();
        }
        
        function updateDeckCounts() {
            const mainCount = currentDeck.main.length;
            const sideCount = currentDeck.side.length;
            const extraCount = currentDeck.extra.length;
            UI.deckCountDisplay.textContent = `Main: ${mainCount} | Side: ${sideCount} | Extra: ${extraCount}`;
            UI.deckCountDisplay.className = `text-sm font-medium ${(mainCount >= 40 && mainCount <= 60) ? 'text-green-400' : 'text-red-400'}`;
            
            const counts = { Monster: 0, Spell: 0, Trap: 0 };
            currentDeck.main.forEach(id => {
                const card = cardDatabase.find(c => c.id === id);
                const type = getCardType(card);
                if (counts[type] !== undefined) counts[type]++;
            });
            UI.deckTypeCountsDisplay.innerHTML = `
                <span class="text-yellow-400">M: ${counts.Monster}</span> |&nbsp;
                <span class="text-green-400">S: ${counts.Spell}</span> |&nbsp;
                <span class="text-purple-400">T: ${counts.Trap}</span>`;
        }

        function renderCurrentDeck() {
            renderDeckPart(UI.mainDeckList, currentDeck.main, 'main');
            renderDeckPart(UI.sideDeckList, currentDeck.side, 'side');
            renderDeckPart(UI.extraDeckList, currentDeck.extra, 'extra');
            updateDeckCounts();
        }
        
        // --- SELECTION MODE FUNCTIONS ---
        function getActiveDeckContainer() {
            const deckMap = {
                'main': UI.mainDeckList,
                'side': UI.sideDeckList,
                'extra': UI.extraDeckList
            };
            return deckMap[selectionMode.currentDeck];
        }
        
        function getActiveDeckData() {
            const deckMap = {
                'main': currentDeck.main,
                'side': currentDeck.side,
                'extra': currentDeck.extra
            };
            return deckMap[selectionMode.currentDeck];
        }
        
        function updateSelectionVisuals() {
            // Clear all selections
            [UI.mainDeckList, UI.sideDeckList, UI.extraDeckList].forEach(container => {
                if (!container) return;
                Array.from(container.children).forEach(card => {
                    card.classList.remove('card-selected');
                });
            });
            
            // Apply selection to current deck
            if (!selectionMode.active || selectionMode.selectedIndices.length === 0) return;
            
            const container = getActiveDeckContainer();
            if (!container) return;
            
            const cards = Array.from(container.children);
            selectionMode.selectedIndices.forEach(index => {
                if (cards[index]) {
                    cards[index].classList.add('card-selected');
                }
            });
            
            // Scroll to first selected card if needed
            if (cards[selectionMode.selectedIndices[0]]) {
                cards[selectionMode.selectedIndices[0]].scrollIntoView({
                    behavior: 'smooth',
                    block: 'nearest',
                    inline: 'nearest'
                });
            }
        }
        
        function startSelectionMode() {
            // Only start if we're in deck builder view and have cards
            if (!UI.deckBuilderView.classList.contains('hidden') === false) return;
            
            const deck = getActiveDeckData();
            if (!deck || deck.length === 0) return;
            
            selectionMode.active = true;
            selectionMode.anchorIndex = 0;
            selectionMode.focusIndex = 0;
            selectionMode.selectedIndices = [0];
            selectionMode.selectionMode = 'none';
            selectionMode.columnIndices = [];
            updateSelectionVisuals();
        }
        
        function exitSelectionMode() {
            if (selectionMode.focusMode) {
                exitFocusMode();
            }
            selectionMode.active = false;
            selectionMode.selectedIndices = [];
            selectionMode.anchorIndex = null;
            selectionMode.focusIndex = null;
            selectionMode.selectionMode = 'none';
            selectionMode.columnIndices = [];
            updateSelectionVisuals();
        }
        
        function enterFocusMode() {
            if (!selectionMode.active || selectionMode.selectedIndices.length === 0) return;
            
            selectionMode.focusMode = true;
            
            // Create focus overlay
            let overlay = document.getElementById('selection-focus-overlay');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.id = 'selection-focus-overlay';
                overlay.className = 'selection-focus-overlay';
                document.body.appendChild(overlay);
            }
            
            // Create focus container
            let focusContainer = document.getElementById('selection-focus-container');
            if (!focusContainer) {
                focusContainer = document.createElement('div');
                focusContainer.id = 'selection-focus-container';
                focusContainer.className = 'selection-focus-container';
                overlay.appendChild(focusContainer);
            }
            
            // Clear previous content
            focusContainer.innerHTML = '';
            
            // Create card wrapper
            const cardWrapper = document.createElement('div');
            cardWrapper.className = 'focus-mode-cards-wrapper';
            focusContainer.appendChild(cardWrapper);
            
            // Clone and display selected cards
            const container = getActiveDeckContainer();
            if (!container) return;
            
            const cards = Array.from(container.children);
            selectionMode.selectedIndices.forEach(index => {
                if (cards[index]) {
                    const clone = cards[index].cloneNode(true);
                    clone.classList.add('focus-mode-card');
                    clone.classList.remove('card-selected');
                    cardWrapper.appendChild(clone);
                }
            });
            
            // Add instruction text at bottom (after cards)
            const instructions = document.createElement('div');
            instructions.className = 'focus-mode-instructions';
            instructions.innerHTML = `
                <p><kbd>Tab</kbd> to exit  <kbd>Space</kbd> to return to first card</p>
            `;
            focusContainer.appendChild(instructions);
            
            // Show overlay with animation
            requestAnimationFrame(() => {
                overlay.classList.add('active');
            });
        }
        
        function exitFocusMode() {
            selectionMode.focusMode = false;
            
            const overlay = document.getElementById('selection-focus-overlay');
            if (overlay) {
                overlay.classList.remove('active');
                setTimeout(() => {
                    overlay.remove();
                }, 300); // Match CSS transition duration
            }
        }
        
        function returnToFirstCard() {
            if (selectionMode.focusMode) {
                exitFocusMode();
            }
            
            // Reset to first card in current deck
            const deck = getActiveDeckData();
            if (!deck || deck.length === 0) return;
            
            selectionMode.anchorIndex = 0;
            selectionMode.focusIndex = 0;
            selectionMode.selectedIndices = [0];
            selectionMode.selectionMode = 'none';
            selectionMode.columnIndices = [];
            updateSelectionVisuals();
        }
        
        function updateSelectionRange(gridColumns) {
            const container = getActiveDeckContainer();
            const totalCards = container ? container.children.length : 0;
            
            if (selectionMode.selectionMode === 'horizontal') {
                // Horizontal mode: select rectangular range (normal behavior)
                const start = Math.min(selectionMode.anchorIndex, selectionMode.focusIndex);
                const end = Math.max(selectionMode.anchorIndex, selectionMode.focusIndex);
                
                selectionMode.selectedIndices = [];
                for (let i = start; i <= end; i++) {
                    if (i < totalCards) {
                        selectionMode.selectedIndices.push(i);
                    }
                }
            } else if (selectionMode.selectionMode === 'vertical') {
                // Vertical mode: only select cards in the same column(s)
                const startRow = Math.floor(Math.min(selectionMode.anchorIndex, selectionMode.focusIndex) / gridColumns);
                const endRow = Math.floor(Math.max(selectionMode.anchorIndex, selectionMode.focusIndex) / gridColumns);
                
                selectionMode.selectedIndices = [];
                
                // For each column in our selection
                for (const col of selectionMode.columnIndices) {
                    // Select cards in that column from startRow to endRow
                    for (let row = startRow; row <= endRow; row++) {
                        const index = row * gridColumns + col;
                        // Only add if card exists at this position
                        if (index < totalCards) {
                            selectionMode.selectedIndices.push(index);
                        }
                    }
                }
                
                // Sort and ensure uniqueness
                selectionMode.selectedIndices = [...new Set(selectionMode.selectedIndices)].sort((a, b) => a - b);
            } else {
                // None mode: just single selection
                selectionMode.selectedIndices = [selectionMode.anchorIndex];
            }
            
            // Reset to neutral mode if selection contracted back to one card
            if (selectionMode.anchorIndex === selectionMode.focusIndex) {
                selectionMode.selectionMode = 'none';
                selectionMode.columnIndices = [];
            }
        }
        
        function moveSelection(direction, extend = false) {
            if (!selectionMode.active) {
                startSelectionMode();
                return;
            }
            
            const container = getActiveDeckContainer();
            if (!container) return;
            
            const deck = getActiveDeckData();
            if (!deck || deck.length === 0) return;
            
            const cards = Array.from(container.children);
            const gridColumns = getComputedColumns(container);
            
            const isVerticalMove = (direction === 'up' || direction === 'down');
            const isHorizontalMove = (direction === 'left' || direction === 'right');
            
            if (extend) {
                // Determine selection mode on first extend
                if (selectionMode.selectionMode === 'none') {
                    if (isVerticalMove) {
                        selectionMode.selectionMode = 'vertical';
                        // Store the column(s) we're selecting
                        const anchorCol = selectionMode.anchorIndex % gridColumns;
                        selectionMode.columnIndices = [anchorCol];
                    } else if (isHorizontalMove) {
                        selectionMode.selectionMode = 'horizontal';
                    }
                }
                
                // Check if move is allowed in current mode
                if (selectionMode.selectionMode === 'vertical' && isHorizontalMove) {
                    // Can't move horizontally in vertical mode
                    return;
                }
                
                // Shift + arrow key: move focus index
                const newFocusIndex = calculateNewIndex(selectionMode.focusIndex, direction, cards.length, gridColumns);
                
                if (newFocusIndex !== -1) {
                    // In vertical mode, check if new focus is in an allowed column
                    if (selectionMode.selectionMode === 'vertical') {
                        const newCol = newFocusIndex % gridColumns;
                        if (!selectionMode.columnIndices.includes(newCol)) {
                            // Add this column to our selection
                            selectionMode.columnIndices.push(newCol);
                            selectionMode.columnIndices.sort((a, b) => a - b);
                        }
                    }
                    
                    selectionMode.focusIndex = newFocusIndex;
                    updateSelectionRange(gridColumns);
                }
            } else {
                // Arrow key only: move both anchor and focus (move the whole selection)
                const offset = getOffsetForDirection(direction, gridColumns);
                
                // Calculate new positions
                const newAnchorIndex = selectionMode.anchorIndex + offset;
                const newFocusIndex = selectionMode.focusIndex + offset;
                
                // Check if the movement is valid for all selected cards
                const allIndicesValid = selectionMode.selectedIndices.every(i => {
                    const newIndex = i + offset;
                    return newIndex >= 0 && newIndex < cards.length;
                });
                
                if (allIndicesValid) {
                    selectionMode.anchorIndex = newAnchorIndex;
                    selectionMode.focusIndex = newFocusIndex;
                    
                    // Update column indices if in vertical mode
                    if (selectionMode.selectionMode === 'vertical') {
                        selectionMode.columnIndices = selectionMode.columnIndices.map(col => {
                            if (direction === 'left') return Math.max(0, col - 1);
                            if (direction === 'right') return Math.min(gridColumns - 1, col + 1);
                            return col;
                        });
                    }
                    
                    updateSelectionRange(gridColumns);
                }
            }
            
            updateSelectionVisuals();
        }
        
        function getComputedColumns(container) {
            const style = window.getComputedStyle(container);
            const gridTemplateColumns = style.gridTemplateColumns;
            return gridTemplateColumns.split(' ').length || 1;
        }
        
        function calculateNewIndex(currentIndex, direction, totalCards, columns) {
            let newIndex = currentIndex;
            
            switch(direction) {
                case 'left':
                    newIndex = currentIndex - 1;
                    break;
                case 'right':
                    newIndex = currentIndex + 1;
                    break;
                case 'up':
                    newIndex = currentIndex - columns;
                    break;
                case 'down':
                    newIndex = currentIndex + columns;
                    break;
            }
            
            return (newIndex >= 0 && newIndex < totalCards) ? newIndex : -1;
        }
        
        function getOffsetForDirection(direction, columns) {
            switch(direction) {
                case 'left': return -1;
                case 'right': return 1;
                case 'up': return -columns;
                case 'down': return columns;
                default: return 0;
            }
        }
        
        function cycleDeck(forward = true) {
            const decks = ['main', 'side', 'extra'];
            const visibleDecks = decks.filter(d => {
                if (d === 'side') return sideDeckVisible;
                if (d === 'extra') return extraDeckVisible;
                return true;
            });
            
            const currentIndex = visibleDecks.indexOf(selectionMode.currentDeck);
            const nextIndex = forward 
                ? (currentIndex + 1) % visibleDecks.length 
                : (currentIndex - 1 + visibleDecks.length) % visibleDecks.length;
            
            selectionMode.currentDeck = visibleDecks[nextIndex];
            
            // Reset selection to first card of new deck
            const newDeck = getActiveDeckData();
            if (newDeck && newDeck.length > 0) {
                selectionMode.anchorIndex = 0;
                selectionMode.focusIndex = 0;
                selectionMode.selectedIndices = [0];
                selectionMode.selectionMode = 'none';
                selectionMode.columnIndices = [];
                updateSelectionVisuals();
            } else {
                exitSelectionMode();
            }
        }
        
        function handleSelectionKeydown(e) {
            // Only handle in deck builder view
            if (!UI.deckBuilderView || !UI.deckBuilderView.classList || UI.deckBuilderView.classList.contains('hidden')) {
                return;
            }
            
            // Ignore if typing in an input
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') {
                return;
            }
            
            const arrowKeys = ['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'];
            
            if (arrowKeys.includes(e.key)) {
                e.preventDefault();
                
                const direction = e.key.replace('Arrow', '').toLowerCase();
                moveSelection(direction, e.shiftKey);
            } else if (e.key === 'Tab' && selectionMode.active) {
                e.preventDefault();
                
                // Toggle focus mode if cards are selected
                if (selectionMode.focusMode) {
                    exitFocusMode();
                } else {
                    enterFocusMode();
                }
            } else if (e.key === ' ' && selectionMode.active) {
                // Space key in select mode: return to first card
                e.preventDefault();
                returnToFirstCard();
            } else if (e.key === 'Escape' && selectionMode.active) {
                e.preventDefault();
                exitSelectionMode();
            }
        }
        
        function handleSelectionClick(e) {
            // Exit selection mode when clicking outside the deck grids
            if (!selectionMode.active) return;
            
            const deckContainers = [
                UI.mainDeckSection,
                UI.sideDeckSection,
                UI.extraDeckSection
            ].filter(Boolean);
            
            const clickedInside = deckContainers.some(container => 
                container.contains(e.target)
            );
            
            if (!clickedInside) {
                exitSelectionMode();
            }
        }
        
        function renderDeckSelector() {
            if (!UI.deckSelector) return;

            const previousSelection = decodeDeckSelectorValue(UI.deckSelector.value);
            UI.deckSelector.innerHTML = '';

            UI.deckSelector.appendChild(new Option('-- Select a Saved Deck --', ''));

            if (offlineDecks.length > 0) {
                const offlineGroup = document.createElement('optgroup');
                offlineGroup.label = 'Offline Decks';
                offlineDecks.forEach(deck => {
                    const option = new Option(deck.name, encodeDeckSelectorValue('offline', deck.id));
                    offlineGroup.appendChild(option);
                });
                UI.deckSelector.appendChild(offlineGroup);
            }

            if (deckLists.length > 0) {
                const onlineGroup = document.createElement('optgroup');
                onlineGroup.label = 'Online Decks';
                deckLists.forEach(deck => {
                    const option = new Option(deck.name, encodeDeckSelectorValue('online', deck.id));
                    onlineGroup.appendChild(option);
                });
                UI.deckSelector.appendChild(onlineGroup);
            }

            if (previousSelection.source && previousSelection.id) {
                const encoded = encodeDeckSelectorValue(previousSelection.source, previousSelection.id);
                const hasOption = [...UI.deckSelector.options].some(opt => opt.value === encoded);
                UI.deckSelector.value = hasOption ? encoded : '';
            } else {
                UI.deckSelector.value = '';
            }
        }

        // --- SIDING PATTERN LOGIC ---
        function openSidingPatternModal(isTemp = false, onTempSave = null) {
            // In offline mode, check if a deck is in the builder. Online, check if a saved deck is loaded.
            if (isOffline) {
                if (currentDeck.main.length === 0) {
                    showMessage("Please build or import a deck before managing siding patterns.");
                    return;
                }
            } else if (!UI.deckSelector.value) {
                // This check is for online mode only.
                showMessage("Please load a saved deck before managing siding patterns.");
                return;
            }
            sidingState = { out: [], in: [] }; // Reset state
            renderSidingPatternEditor();

            // Configure modal for temporary (simulation) or permanent (deckbuilder) use
            document.getElementById('siding-permanent-controls').style.display = isTemp ? 'none' : 'block';
            const tempControls = document.getElementById('siding-temp-controls');
            if (tempControls) { // Defensive check
                tempControls.style.display = isTemp ? 'block' : 'none';
            }
            
            // In manual siding for the simulator, we don't need to save a permanent pattern.
            // The logic for handling the temporary pattern is already in place.
            // This modal is now correctly opened, and the temporary save button will be configured.
            // The `isTemp` flag correctly handles showing/hiding the permanent save controls.
            
            
            if (isTemp) {
                const tempSaveBtn = document.getElementById('saveTempSidingPatternBtn');
                // Clone and replace to remove old listeners
                const newBtn = tempSaveBtn.cloneNode(true);
                tempSaveBtn.parentNode.replaceChild(newBtn, tempSaveBtn);
                newBtn.addEventListener('click', () => {
                    saveSidingPattern(true, onTempSave);
                });
            }

            renderSidingPatternList();
            UI.sidingPatternModal.classList.remove('hidden');
        }
        
        // This is a new helper function to get the deck currently being worked on, whether online or offline.
        function getActiveDeckForSiding() {
            const selection = decodeDeckSelectorValue(UI.deckSelector.value);
            if (!selection.id || (selection.source === 'offline' && selection.id === 'builder')) {
                return currentDeck;
            }
            if (selection.source === 'offline') {
                return offlineDecks.find(d => d.id === selection.id) || currentDeck;
            }
            if (selection.source === 'online') {
                return deckLists.find(d => d.id === selection.id) || currentDeck;
            }
            return currentDeck;
        }

        function renderSidingPatternEditor() {
            const render = (container, cardIds, part) => {
                container.innerHTML = '';
                const counts = cardIds.reduce((acc, val) => { acc[val] = (acc[val] || 0) + 1; return acc; }, {});
                Object.entries(counts).forEach(([id, count]) => {
                    const card = cardDatabase.find(c => c.id === id);
                    if(!card) return;
                    const el = document.createElement('div');
                    el.className = 'p-2 flex items-center justify-between bg-slate-700/50 rounded-lg cursor-pointer hover:bg-blue-600/50';
                    el.dataset.id = id;
                    el.innerHTML = `
                        <div class="flex items-center gap-2">
                            <img src="${card.imageUrl}" class="w-8 h-auto rounded-sm" onerror="this.onerror=null;this.src='https://placehold.co/32x46/2d3748/e2e8f0?text=?';">
                            <span>${card.name}</span>
                        </div>
                        <span class="font-mono text-slate-400">x${count}</span>`;
                    el.addEventListener('click', () => handleSidingCardClick(id, part));
                    el.addEventListener('contextmenu', (e) => handleSidingCardRightClick(e, id, part));
                    container.appendChild(el);
                });
            };
            const activeDeck = getActiveDeckForSiding();
            render(UI.sidingPatternMainDeck, activeDeck.main, 'out');
            render(UI.sidingPatternSideDeck, activeDeck.side, 'in');
            updateSidingSelectionVisuals();
        }

        function handleSidingCardClick(cardId, part) {
            const deckList = currentDeck[part === 'out' ? 'main' : 'side'];
            const sidingList = sidingState[part];
            const totalAvailable = deckList.filter(id => id === cardId).length;
            let currentlySelected = sidingList.filter(id => id === cardId).length;

            if (currentlySelected < totalAvailable) {
                sidingList.push(cardId);
            } else {
                sidingState[part] = sidingList.filter(id => id !== cardId);
            }
            updateSidingSelectionVisuals();
        }
        
        function handleSidingCardRightClick(e, cardId, part) {
            e.preventDefault();
            sidingState[part] = sidingState[part].filter(id => id !== cardId);
            updateSidingSelectionVisuals();
        }

        function updateSidingSelectionVisuals() {
            [...UI.sidingPatternMainDeck.children, ...UI.sidingPatternSideDeck.children].forEach(el => {
                const id = el.dataset.id;
                const part = UI.sidingPatternMainDeck.contains(el) ? 'out' : 'in';
                const selectedCount = sidingState[part].filter(cid => cid === id).length;
                el.classList.toggle('ring-2', selectedCount > 0);
                el.classList.toggle('ring-amber-400', selectedCount > 0);

                let countEl = el.querySelector('.siding-count');
                if (selectedCount > 0) {
                    if (!countEl) {
                        countEl = document.createElement('span');
                        countEl.className = 'siding-count font-bold text-amber-300 mr-2';
                        el.prepend(countEl);
                    }
                    countEl.textContent = `(${selectedCount})`;
                } else if (countEl) {
                    countEl.remove();
                }
            });
            UI.sidingSelectedCount.textContent = `Siding out ${sidingState.out.length}, Siding in ${sidingState.in.length}`;
        }

        async function saveSidingPattern(isTemp = false, onTempSave = null) {
            // For temporary siding (like in the simulator), bypass the permanent save logic.
            if (isTemp && onTempSave) {
                if (sidingState.out.length !== sidingState.in.length) {
                    showMessage("The number of cards sided in and out must be equal.");
                    return;
                }
                // Note: We allow 0 cards to be sided if the user just wants to proceed.
                const tempPattern = { out: sidingState.out, in: sidingState.in };
                onTempSave(tempPattern);
                UI.sidingPatternModal.classList.add('hidden');
                return;
            }

            // The rest of this function is for PERMANENTLY saving a pattern to a deck.
            const name = UI.sidingPatternNameInput.value.trim();
            if (!name) {
                showMessage("Please enter a name for the siding pattern.");
                return;
            }
            if (sidingState.out.length !== sidingState.in.length || sidingState.out.length === 0) { // Stricter check for permanent saves
                showMessage("The number of cards sided in and out must be equal and greater than zero.");
                return;
            }
            
            const selection = decodeDeckSelectorValue(UI.deckSelector.value);
            const activeDeck = getActiveDeckForSiding();
            
            if (!activeDeck.sidingPatterns) {
                activeDeck.sidingPatterns = {};
            }
            activeDeck.sidingPatterns[name] = { out: sidingState.out, in: sidingState.in };
            if (activeDeck === currentDeck || (currentDeckSource === 'offline' && activeDeck.id === currentDeckId)) {
                markDeckDirty();
            }

            if (selection.source === 'online' && selection.id) {
                const deckDocRef = doc(db, `artifacts/${appId}/users/${userId}/decks`, selection.id);
            try {
                await updateDoc(deckDocRef, {
                    sidingPatterns: currentDeck.sidingPatterns
                });
                showMessage(`Siding pattern "${name}" saved.`);
            } catch (error) {
                console.error("Error saving siding pattern:", error);
                showMessage("Failed to save siding pattern.");
                    return;
                }
            } else {
                showTooltip(`Pattern "${name}" saved locally. Remember to save your deck to keep it.`);
            }

            UI.sidingPatternNameInput.value = '';
            sidingState = { out: [], in: [] };
            renderSidingPatternEditor();
            renderSidingPatternList();
        }

        function renderSidingPatternList() {
             UI.sidingPatternList.innerHTML = '';
             const patterns = getActiveDeckForSiding().sidingPatterns || {};
             if (Object.keys(patterns).length === 0) {
                 UI.sidingPatternList.innerHTML = `<p class="text-xs text-slate-500 text-center">No patterns saved for this deck.</p>`;
                 return;
             }
             Object.keys(patterns).forEach(name => {
                 const el = document.createElement('div');
                 el.className = 'flex justify-between items-center p-2 bg-slate-700/50 rounded-lg';
                 el.innerHTML = `<span>${name}</span> <button data-name="${name}" class="text-red-400 text-xs font-bold hover:text-red-300">DEL</button>`;
                 el.querySelector('button').addEventListener('click', deleteSidingPattern);
                 UI.sidingPatternList.appendChild(el);
             });
        }
        
        async function deleteSidingPattern(e){
            const name = e.target.dataset.name;
            const selection = decodeDeckSelectorValue(UI.deckSelector.value);
            const activeDeck = getActiveDeckForSiding();
            
            delete activeDeck.sidingPatterns[name];

            if (selection.source === 'online' && selection.id) {
                const deckDocRef = doc(db, `artifacts/${appId}/users/${userId}/decks`, selection.id);
            try { // This will only work online, which is the intended behavior for permanent patterns
                await updateDoc(deckDocRef, {
                    sidingPatterns: currentDeck.sidingPatterns
                });
                showMessage(`Pattern "${name}" deleted.`);
            } catch(error){
                 console.error("Error deleting siding pattern:", error);
                showMessage("Failed to delete siding pattern.");
                    return;
            }
            } else {
                markDeckDirty();
                showTooltip(`Pattern "${name}" removed locally. Save your deck to keep changes.`);
            }
            renderSidingPatternList();
        }
        
        function exportSidingPatterns() {
            const activeDeck = getActiveDeckForSiding();
            if (!activeDeck.sidingPatterns || Object.keys(activeDeck.sidingPatterns).length === 0) {
                showMessage("There are no siding patterns for the current deck to export.");
                return;
            }
            const blob = new Blob([JSON.stringify(activeDeck.sidingPatterns, null, 2)], { type: 'application/json' });
            const deckName = UI.deckNameInput.value.trim() || 'deck';
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `${deckName}_siding_patterns.json`;
            a.click();
            URL.revokeObjectURL(a.href);
        }

        function importSidingPatterns(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const importedPatterns = JSON.parse(e.target.result);
                    const selection = decodeDeckSelectorValue(UI.deckSelector.value);
                    if (!selection.id) {
                        showMessage("Please load a deck before importing siding patterns.");
                        return;
                    }
                    
                    const activeDeck = getActiveDeckForSiding();
                    // Merge imported patterns with existing ones
                    activeDeck.sidingPatterns = { ...activeDeck.sidingPatterns, ...importedPatterns };
                    markDeckDirty();
                    
                    if (selection.source === 'online') {
                        const deckDocRef = doc(db, `artifacts/${appId}/users/${userId}/decks`, selection.id);
                    await updateDoc(deckDocRef, { sidingPatterns: currentDeck.sidingPatterns });
                    showMessage("Siding patterns imported and saved successfully.");
                    } else {
                        showTooltip('Siding patterns imported locally. Save your deck to persist them.');
                    }
                    renderSidingPatternList(); // Refresh the list in the modal
                } catch (err) {
                    showMessage("Invalid siding pattern file. Please ensure it's a valid JSON file.");
                    console.error("Error importing siding patterns:", err);
                }
            };
            reader.readAsText(file);
            event.target.value = null; // Reset the input
        }

        // --- EASTER EGG CARD POOL MANAGEMENT ---
        function openEasterEggModal() {
            console.log('openEasterEggModal called');
            console.log('UI.easterEggModal:', UI.easterEggModal);
            if (!UI.easterEggModal) {
                console.error('Easter egg modal not found!');
                return;
            }
            
            // Check if easter egg is active (chibi animation is running)
            const chibi = document.getElementById('chibi-logo');
            if (!chibi || !chibi.style.transform || chibi.style.transform === 'none') {
                showMessage("Easter egg is not active. Please activate the easter egg first by clicking the chibi logo multiple times.");
                return;
            }
            
            // Pause animations
            pauseChibiAnimation();
            
            loadEasterEggCardPool();
            renderEasterEggPool();
            UI.easterEggModal.classList.remove('hidden');
        }
        
        function closeEasterEggModal() {
            UI.easterEggModal.classList.add('hidden');
            // Resume animations
            resumeChibiAnimation();
        }
        
        function pauseChibiAnimation() {
            if (chibiAnimationState.hopInterval) {
                clearInterval(chibiAnimationState.hopInterval);
                chibiAnimationState.hopInterval = null;
            }
            if (chibiAnimationState.physicsInterval) {
                clearInterval(chibiAnimationState.physicsInterval);
                chibiAnimationState.physicsInterval = null;
            }
            chibiAnimationState.isPaused = true;
        }
        
        function resumeChibiAnimation() {
            if (!chibiAnimationState.isPaused) return;
            
            const chibi = document.getElementById('chibi-logo');
            if (!chibi) return;
            
            // Resume hopping animation if the functions are available
            if (window.chibiAnimationFunctions && window.chibiAnimationFunctions.startHopping) {
                window.chibiAnimationFunctions.startHopping();
            }
            
            chibiAnimationState.isPaused = false;
        }

        function loadEasterEggCardPool() {
            const saved = localStorage.getItem('easterEggCardPool');
            if (saved) {
                easterEggCardPool = JSON.parse(saved);
            } else {
                // Default to some common trap cards
                easterEggCardPool = [
                    { id: 4206964, name: "Trap Hole" },
                    { id: 53582587, name: "Torrential Tribute" },
                    { id: 29401950, name: "Bottomless Trap Hole" },
                    { id: 94192409, name: "Compulsory Evacuation Device" },
                    { id: 44095762, name: "Mirror Force" },
                    { id: 70342167, name: "Dimensional Prison" },
                    { id: 50078509, name: "Fiendish Chain" },
                    { id: 38411870, name: "Needle Ceiling" },
                    { id: 78474168, name: "Breakthrough Skill" },
                    { id: 82732705, name: "Crackdown" }
                ];
            }
        }

        function saveEasterEggPool() {
            localStorage.setItem('easterEggCardPool', JSON.stringify(easterEggCardPool));
            showMessage("Easter egg card pool saved successfully!");
            closeEasterEggModal();
        }

        function resetEasterEggPool() {
            easterEggCardPool = [
                { id: 4206964, name: "Trap Hole" },
                { id: 53582587, name: "Torrential Tribute" },
                { id: 29401950, name: "Bottomless Trap Hole" },
                { id: 94192409, name: "Compulsory Evacuation Device" },
                { id: 44095762, name: "Mirror Force" },
                { id: 70342167, name: "Dimensional Prison" },
                { id: 50078509, name: "Fiendish Chain" },
                { id: 38411870, name: "Needle Ceiling" },
                { id: 78474168, name: "Breakthrough Skill" },
                { id: 82732705, name: "Crackdown" }
            ];
            renderEasterEggPool();
        }

        function clearEasterEggPool() {
            easterEggCardPool = [];
            renderEasterEggPool();
        }

        function renderEasterEggPool() {
            if (!UI.easterEggPoolList) return;
            
            UI.easterEggPoolList.innerHTML = '';
            UI.easterEggCount.textContent = easterEggCardPool.length;
            
            if (easterEggCardPool.length === 0) {
                UI.easterEggPoolList.innerHTML = '<p class="text-gray-400 text-center">No cards in easter egg pool</p>';
                return;
            }
            
            easterEggCardPool.forEach((card, index) => {
                const cardEl = document.createElement('div');
                cardEl.className = 'flex items-center justify-between bg-slate-700 p-2 rounded-lg';
                cardEl.innerHTML = `
                    <div class="flex items-center gap-2">
                        <img src="https://images.ygoprodeck.com/images/cards_small/${card.id}.jpg" 
                             alt="${card.name}" class="w-8 h-8 object-cover rounded">
                        <span class="text-sm">${card.name}</span>
                    </div>
                    <button data-index="${index}" class="text-red-400 hover:text-red-300 text-xs font-bold">Remove</button>
                `;
                cardEl.querySelector('button').addEventListener('click', (e) => {
                    const index = parseInt(e.target.dataset.index);
                    easterEggCardPool.splice(index, 1);
                    renderEasterEggPool();
                });
                UI.easterEggPoolList.appendChild(cardEl);
            });
        }

        async function handleEasterEggSearch() {
            const query = UI.easterEggSearchInput.value.toLowerCase().trim();
            
            if (!query) {
                UI.easterEggSearchResults.classList.add('hidden');
                return;
            }
            
            // Fetch all cards if not cached (same as card database autocomplete)
            if (allCardsCache.length === 0) {
                await fetchAllCards();
            }
            
            // Filter from allCardsCache and exclude cards already in pool
            const results = allCardsCache.filter(card => 
                card.name.toLowerCase().includes(query) && 
                !easterEggCardPool.some(eggCard => eggCard.id === card.id)
            ).slice(0, 10);
            
            if (results.length === 0) {
                UI.easterEggSearchResults.innerHTML = '<div class="p-2 text-gray-400">No cards found</div>';
            } else {
                UI.easterEggSearchResults.innerHTML = results.map(card => `
                    <div class="p-2 hover:bg-slate-700 cursor-pointer flex items-center gap-2 autocomplete-item" data-card-id="${card.id}">
                        <img src="https://images.ygoprodeck.com/images/cards_small/${card.id}.jpg" 
                             alt="${card.name}" class="w-6 h-6 object-cover rounded">
                        <span class="text-sm">${card.name}</span>
                    </div>
                `).join('');
                
                // Add click listeners
                UI.easterEggSearchResults.querySelectorAll('.autocomplete-item').forEach(el => {
                    el.addEventListener('click', () => {
                        const cardId = el.dataset.cardId;
                        const card = allCardsCache.find(c => c.id === cardId);
                        if (card) {
                            addCardToEasterEggPool(card);
                            UI.easterEggSearchInput.value = '';
                            UI.easterEggSearchResults.classList.add('hidden');
                        }
                    });
                });
            }
            
            UI.easterEggSearchResults.classList.remove('hidden');
        }
        
        function handleEasterEggSearchKeydown(e) {
            const items = UI.easterEggSearchResults.querySelectorAll('.autocomplete-item');
            
            if (!UI.easterEggSearchResults.classList.contains('hidden') && items.length > 0) {
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    const currentSelected = UI.easterEggSearchResults.querySelector('.autocomplete-item.selected');
                    const currentIndex = currentSelected ? Array.from(items).indexOf(currentSelected) : -1;
                    const nextIndex = Math.min(currentIndex + 1, items.length - 1);
                    
                    // Remove previous selection
                    items.forEach(item => item.classList.remove('selected'));
                    // Add selection to next item
                    if (nextIndex >= 0) items[nextIndex].classList.add('selected');
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    const currentSelected = UI.easterEggSearchResults.querySelector('.autocomplete-item.selected');
                    const currentIndex = currentSelected ? Array.from(items).indexOf(currentSelected) : items.length;
                    const prevIndex = Math.max(currentIndex - 1, -1);
                    
                    // Remove previous selection
                    items.forEach(item => item.classList.remove('selected'));
                    // Add selection to previous item
                    if (prevIndex >= 0) items[prevIndex].classList.add('selected');
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    const selected = UI.easterEggSearchResults.querySelector('.autocomplete-item.selected');
                    if (selected) {
                        selected.click();
                    }
                } else if (e.key === 'Escape') {
                    UI.easterEggSearchResults.classList.add('hidden');
                }
            }
        }

        function addCardToEasterEggPool(card) {
            if (!card) return;
            
            if (easterEggCardPool.some(eggCard => eggCard.id === card.id)) {
                showMessage(`${card.name} is already in the easter egg pool.`);
                return;
            }
            
            easterEggCardPool.push({ id: card.id, name: card.name });
            renderEasterEggPool();
        }


        // --- SIMULATION LOGIC ---
        function updateTargetCardSelector() {
            const deckValue = UI.simDeckSelector.value;
            if (!deckValue) {
                UI.simTargetCardSelector.innerHTML = '<option value="">-- Select a Deck first --</option>';
                // Also clear the compare card selector if no deck is selected
                if (UI.simCompareCardSelector) {
                    const currentCompareVal = UI.simCompareCardSelector.value;
                    UI.simCompareCardSelector.innerHTML = '<option value="">-- Select Comparison Card --</option>';
                    UI.simCompareCardSelector.value = currentCompareVal;
                }
                UI.simSidingPatternSelector.innerHTML = '<option value="">--</option>';
                updateReplacementCountOptions();
                return;
            }
            
            const selection = decodeDeckSelectorValue(deckValue);
            let selectedDeck;
            if (selection.source === 'offline' && selection.id === 'builder') {
                selectedDeck = { name: UI.deckNameInput.value || 'Deckbuilder', main: currentDeck.main, side: currentDeck.side, extra: currentDeck.extra || [], sidingPatterns: currentDeck.sidingPatterns || {} };
            } else if (selection.source === 'offline') {
                selectedDeck = offlineDecks.find(d => d.id === selection.id);
            } else if (selection.source === 'online') {
                selectedDeck = deckLists.find(d => d.id === selection.id);
            }

            if (!selectedDeck) return;
            
            // Populate comparison cards based on the full card DB, not just the deck
            const currentCompareVal = UI.simCompareCardSelector.value;
            UI.simCompareCardSelector.innerHTML = '<option value="">-- Select Comparison Card --</option>';
            cardDatabase
                .filter(Boolean).sort((a,b) => a.name.localeCompare(b.name))
                .forEach(card => UI.simCompareCardSelector.add(new Option(card.name, card.id)));
            UI.simCompareCardSelector.value = currentCompareVal;

            // Now, handle the target cards based on the selected deck
            let cardsToPopulate = [...(selectedDeck.main || [])];
            
            const currentPatternName = UI.simSidingPatternSelector.value;
            UI.simSidingPatternSelector.innerHTML = '<option value="">-- Select Siding Pattern --</option>';
             if (selectedDeck.sidingPatterns) {
                 Object.keys(selectedDeck.sidingPatterns).forEach(name => {
                     UI.simSidingPatternSelector.add(new Option(name, name));
                 });
            }
            UI.simSidingPatternSelector.value = currentPatternName;

            const sidingMethod = document.querySelector('input[name="siding-method"]:checked')?.value;

            if(UI.simPostSideModeToggle.checked && sidingMethod === 'manual') {
                // In manual mode, we don't pre-filter the deck. The siding will be applied at simulation start.
                // We just show the main deck cards.
                cardsToPopulate = [...(selectedDeck.main || [])];
            } else if(UI.simPostSideModeToggle.checked && sidingMethod === 'pattern') {
                const patternName = UI.simSidingPatternSelector.value;
                if (patternName && selectedDeck.sidingPatterns?.[patternName]) {
                    const pattern = selectedDeck.sidingPatterns[patternName];
                    let cardsToSideOut = [...pattern.out];
                    cardsToPopulate = cardsToPopulate.filter(cardId => {
                         const index = cardsToSideOut.indexOf(cardId);
                         if (index > -1) {
                             cardsToSideOut.splice(index, 1);
                             return false;
                         }
                         return true;
                    });
                    cardsToPopulate.push(...pattern.in);
                } else {
                    cardsToPopulate = [];
                }
            }

            const currentTarget = UI.simTargetCardSelector.value;
            UI.simTargetCardSelector.innerHTML = '';
            if(cardsToPopulate.length === 0) {
                 UI.simTargetCardSelector.innerHTML = UI.simPostSideModeToggle.checked ? '<option value="">-- Select Pattern/Method --</option>' : '<option value="">-- Deck is Empty --</option>';
            } else {
                 UI.simTargetCardSelector.innerHTML = '<option value="">-- Select Card to Replace --</option>';
                 [...new Set(cardsToPopulate)].map(id => cardDatabase.find(c => c.id === id))
                    .filter(Boolean).sort((a,b) => a.name.localeCompare(b.name))
                    .forEach(card => UI.simTargetCardSelector.add(new Option(card.name, card.id)));
            }
            UI.simTargetCardSelector.value = currentTarget;

            updateReplacementCountOptions();
        }

        function updateReplacementCountOptions() {
             const deckValue = UI.simDeckSelector.value;
             const targetCardId = UI.simTargetCardSelector.value;
             if (!deckValue || !targetCardId) {
                 UI.simReplacementCount.innerHTML = '';
                 return;
             }
             
             const selection = decodeDeckSelectorValue(deckValue);
             let selectedDeck;
             if (selection.source === 'offline' && selection.id === 'builder') {
                selectedDeck = { name: UI.deckNameInput.value || 'Deckbuilder', main: currentDeck.main, side: currentDeck.side, extra: currentDeck.extra || [], sidingPatterns: currentDeck.sidingPatterns || {} };
             } else if (selection.source === 'offline') {
                selectedDeck = offlineDecks.find(d => d.id === selection.id);
             } else if (selection.source === 'online') {
                selectedDeck = deckLists.find(d => d.id === selection.id);
             }

             if (!selectedDeck) return;

             const sidingMethod = document.querySelector('input[name="siding-method"]:checked')?.value;
             let deckForCount = [...selectedDeck.main];

             if (UI.simPostSideModeToggle.checked && sidingMethod === 'manual') {
                // For manual siding, the count is based on the pre-sided main deck.
                // The actual siding happens later.
                deckForCount = [...selectedDeck.main];
             }

             if (UI.simPostSideModeToggle.checked) {
                 const patternName = UI.simSidingPatternSelector.value;
                 if (patternName && selectedDeck.sidingPatterns?.[patternName]) {
                      const pattern = selectedDeck.sidingPatterns[patternName];
                      let tempDeck = [...selectedDeck.main];
                      let cardsToSideOut = [...pattern.out];
                       tempDeck = tempDeck.filter(cardId => {
                           const index = cardsToSideOut.indexOf(cardId);
                           if (index > -1) {
                               cardsToSideOut.splice(index, 1);
                               return false;
                           }
                           return true;
                       });
                      tempDeck.push(...pattern.in);
                      deckForCount = tempDeck;
                 }
             }
             const count = deckForCount.filter(id => id === targetCardId).length;
             UI.simReplacementCount.innerHTML = '';
             for (let i = 1; i <= count; i++) {
                 UI.simReplacementCount.add(new Option(i, i));
             }
        }
        
        function populateSimulationSetup() {
            // Decks
            const currentDeckVal = UI.simDeckSelector.value || BUILDER_DECK_VALUE;
            UI.simDeckSelector.innerHTML = '';
                UI.simDeckSelector.disabled = false;

            UI.simDeckSelector.appendChild(new Option('Using Deck from Deckbuilder', BUILDER_DECK_VALUE));

            if (offlineDecks.length > 0) {
                const offlineGroup = document.createElement('optgroup');
                offlineGroup.label = 'Offline Decks';
                offlineDecks.forEach(deck => {
                    const option = new Option(deck.name, encodeDeckSelectorValue('offline', deck.id));
                    offlineGroup.appendChild(option);
                });
                UI.simDeckSelector.appendChild(offlineGroup);
            }

            if (!isOffline && deckLists.length > 0) {
                const onlineGroup = document.createElement('optgroup');
                onlineGroup.label = 'Online Decks';
                deckLists.forEach(deck => {
                    const option = new Option(deck.name, encodeDeckSelectorValue('online', deck.id));
                    onlineGroup.appendChild(option);
                });
                UI.simDeckSelector.appendChild(onlineGroup);
            }

            const hasPrevious = [...UI.simDeckSelector.options].some(opt => opt.value === currentDeckVal);
            UI.simDeckSelector.value = hasPrevious ? currentDeckVal : BUILDER_DECK_VALUE;

            // Comparison Cards
            const currentCompareVal = UI.simCompareCardSelector.value;
            UI.simCompareCardSelector.innerHTML = '<option value="">-- Select a Deck to see options --</option>';
            cardDatabase.forEach(card => UI.simCompareCardSelector.add(new Option(card.name, card.id)));
            UI.simCompareCardSelector.value = currentCompareVal;
            
            UI.simDeckSelector.onchange = updateTargetCardSelector;
            UI.simSidingPatternSelector.onchange = updateTargetCardSelector;
            UI.simTargetCardSelector.onchange = updateReplacementCountOptions;

            // Set initial visibility of siding pattern dropdown
            const initialSidingMethod = document.querySelector('input[name="siding-method"]:checked')?.value;
            document.getElementById('siding-pattern-options').style.display = initialSidingMethod === 'pattern' ? 'block' : 'none';
            
            updateTargetCardSelector();
        }

        function startSimulation() {
            simulationState = {};

            const deckValue = UI.simDeckSelector.value || BUILDER_DECK_VALUE;
            if(!deckValue) { showMessage("Please select a deck first."); return; }

            const selection = decodeDeckSelectorValue(deckValue);
            let baseDeckData;
            if (selection.source === 'offline' && selection.id === 'builder') {
                baseDeckData = { name: UI.deckNameInput.value || 'Deckbuilder', main: currentDeck.main, side: currentDeck.side, extra: currentDeck.extra || [], sidingPatterns: currentDeck.sidingPatterns || {} };
            } else if (selection.source === 'offline') {
                baseDeckData = offlineDecks.find(d => d.id === selection.id);
            } else if (selection.source === 'online') {
                baseDeckData = deckLists.find(d => d.id === selection.id);
            }
            if(!baseDeckData) { showMessage("Selected deck not found or unavailable offline."); return; }
            
            simulationState = {
                baseDeckData: baseDeckData,
                trials: parseInt(UI.simTrialsInput.value),
                mode: UI.simModeSelector.value,
                isPostSide: UI.simPostSideModeToggle.checked,
            };

            if (simulationState.isPostSide) {
                const sidingMethod = document.querySelector('input[name="siding-method"]:checked')?.value;
                if (sidingMethod === 'manual') {
                    // For manual siding, we can use the existing siding pattern modal.
                    // We'll pass a callback to `openSidingPatternModal` which will start the simulation
                    // once the user has defined and "saved" a temporary pattern.
                    openSidingPatternModal(true, (tempPattern) => {
                        // This is the callback that runs after the user defines their manual siding.
                        // It receives the temporary pattern and continues the simulation process.
                        if (!simulationState) { // Safety check
                            console.error("Simulation state lost during manual siding."); return;
                        }
                        simulationState.sidingPattern = tempPattern;
                        
                        // Continue the simulation flow from here
                        applySidingAndContinue(simulationState, baseDeckData); // This sets up the deck

                        // The rest of the logic from startSimulation needs to run now
                        if(simulationState.mode === 'standard') {
                            simulationState.targetCardId = UI.simTargetCardSelector.value;
                            simulationState.compareCardId = UI.simCompareCardSelector.value;
                            simulationState.replacementCount = parseInt(UI.simReplacementCount.value);
                        }
                        lastSimulationSettings = {...simulationState};
                        startEvaluationPhase();
                    });
                    return; // Stop here, the callback will continue the process.
                }

                // This part now only runs for the 'pattern' method.
                const patternName = UI.simSidingPatternSelector.value;
                if (!patternName) { showMessage("Please select a siding pattern for Post-side Mode."); return; }
                const pattern = baseDeckData.sidingPatterns[patternName];
                if (!pattern) { showMessage("Siding pattern not found."); return; }
                
                let sidedDeck = [...baseDeckData.main];
                 let cardsToSideOut = [...pattern.out];
                sidedDeck = sidedDeck.filter(cardId => {
                    const index = cardsToSideOut.indexOf(cardId);
                    if (index > -1) {
                        cardsToSideOut.splice(index, 1);
                        return false;
                    }
                    return true;
                });
                sidedDeck.push(...pattern.in);
                
                simulationState.sidingPattern = pattern;
                simulationState.baseDeckForSim = sidedDeck;

            } else {
                 simulationState.baseDeckForSim = baseDeckData.main;
            }

            if(simulationState.mode === 'standard') {
                simulationState.targetCardId = UI.simTargetCardSelector.value;
                simulationState.compareCardId = UI.simCompareCardSelector.value;
                simulationState.replacementCount = parseInt(UI.simReplacementCount.value);

                if (!simulationState.targetCardId || !simulationState.compareCardId || !simulationState.replacementCount) {
                    showMessage("Please fill out all comparison card parameters."); return;
                }
                 if (simulationState.targetCardId === simulationState.compareCardId) {
                    showMessage("Target card and comparison card cannot be the same."); return;
                }
            }
            lastSimulationSettings = {...simulationState};
            startEvaluationPhase();
        }

        function applySidingAndContinue(simState, deckData) {
            const { sidingPattern } = simState;
            if (!sidingPattern) {
                showMessage("Siding pattern was not defined. Aborting simulation.");
                return;
            }

            let sidedDeck = [...deckData.main];
            let cardsToSideOut = [...sidingPattern.out];
            sidedDeck = sidedDeck.filter(cardId => {
                const index = cardsToSideOut.indexOf(cardId);
                if (index > -1) {
                    cardsToSideOut.splice(index, 1);
                    return false;
                }
                return true;
            });
            sidedDeck.push(...sidingPattern.in);
            simState.baseDeckForSim = sidedDeck;
        }
        function rerunSimulation() {
            simulationState = {...lastSimulationSettings};
            simulationState.trials = parseInt(UI.rerunTrialsInput.value);
            startEvaluationPhase();
        }
        

        function startEvaluationPhase() {
            simulationState.totalTrials = simulationState.trials;
            simulationState.currentTrial = 0;
            simulationState.results = [];
            simulationState.history = [];
            
            showView('simulationView');
            UI.simulationSetup.classList.add('hidden');
            UI.simulationDisplay.classList.remove('hidden');
            UI.trialCounter.parentElement.classList.remove('hidden');
            
            nextTrial();
        }

        function nextTrial() {
            if (simulationState.currentTrial >= simulationState.totalTrials) {
                endSimulation();
                return;
            }
            simulationState.currentTrial++;
            UI.trialCounter.textContent = `${simulationState.currentTrial} / ${simulationState.totalTrials}`;
            
            if (simulationState.mode === 'standard') {
                generateStandardTrial();
            } else {
                generateSidingAnalysisTrial();
            }
            UI.trialNotes.value = '';
        }
        
        function generateStandardTrial() {
            let shuffledDeck, handA, attempts = 0;
            do {
                shuffledDeck = shuffleArray([...simulationState.baseDeckForSim]);
                handA = shuffledDeck.slice(0, 5);
                attempts++;
                if (attempts > 1000) { showMessage("Could not generate a valid hand with the target card. Aborting."); endSimulation(true); return; }
            } while (!handA.includes(simulationState.targetCardId));
            
            const deckPileA = shuffledDeck.slice(5);

            let deckB_complete = [...shuffledDeck];
            let replacedCount = 0;
            for(let i = 0; i < deckB_complete.length && replacedCount < simulationState.replacementCount; i++) {
                if(deckB_complete[i] === simulationState.targetCardId) {
                    deckB_complete[i] = simulationState.compareCardId;
                    replacedCount++;
                }
            }

            const handB = deckB_complete.slice(0,5);
            const deckPileB = deckB_complete.slice(5);

            simulationState.history.push({ deckA: deckPileA, handA, deckB: deckPileB, handB });
            renderTrial({ handA, handB, deckA: deckPileA, deckB: deckPileB });
        }
        
        function generateSidingAnalysisTrial() {
            const { sidingPattern, baseDeckData } = simulationState;
            const { out, in: in_cards } = sidingPattern;

            let shuffledDeck, handA, hasSidedCard, attempts = 0;
            do {
                shuffledDeck = shuffleArray([...baseDeckData.main]);
                handA = shuffledDeck.slice(0, 5);
                hasSidedCard = handA.some(cardId => out.includes(cardId));
                attempts++;
                if (attempts > 1000) {
                    showMessage("Could not generate a valid hand containing a card to be sided out. Aborting.");
                    endSimulation(true);
                    return;
                }
            } while (!hasSidedCard);

            const deckPileA = shuffledDeck.slice(5);
            
            const cardsToSideOut = [...out];
            const cardsToSideIn = [...in_cards];

            const mapCard = (cardId) => {
                const indexToSideOut = cardsToSideOut.indexOf(cardId);
                if (indexToSideOut > -1 && cardsToSideIn.length > 0) {
                    cardsToSideOut.splice(indexToSideOut, 1);
                    return cardsToSideIn.shift(); 
                }
                return cardId;
            };

            const handB = handA.map(mapCard);
            const deckPileB = deckPileA.map(mapCard);

            simulationState.history.push({ deckA: deckPileA, handA, deckB: deckPileB, handB });
            renderTrial({ handA, handB, deckA: deckPileA, deckB: deckPileB });
        }

        function shuffleArray(deck) {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            return deck;
        }

        function renderTrial(trialData) {
            const cardMapper = (id) => {
                const card = cardDatabase.find(c => c.id === id);
                const cardName = card?.name || `Unknown ID: ${id}`;
                const cardImage = card?.imageUrl;
                
                const cardEl = document.createElement('img');
                cardEl.src = cardImage || 'https://placehold.co/120x175/2d3748/e2e8f0?text=?';
                cardEl.className = 'w-full rounded-lg shadow-lg cursor-pointer transition-transform duration-100';
                cardEl.title = cardName;
                cardEl.onerror = function() { this.onerror=null; this.src='https://placehold.co/120x175/2d3748/e2e8f0?text=?'; };
                
                cardEl.addEventListener('click', () => {
                    UI.trialNotes.value += (UI.trialNotes.value ? ' ' : '') + cardName;
                    
                    cardEl.classList.add('animate-pop');
                    setTimeout(() => cardEl.classList.remove('animate-pop'), 200);
                });
                return cardEl;
            };

            const populateContainer = (container, hand) => {
                container.innerHTML = '';
                hand.forEach(id => container.appendChild(cardMapper(id)));
            };

            populateContainer(UI.handAContainer, trialData.handA);
            populateContainer(UI.handBContainer, trialData.handB);
            
            const simpleCardMapper = (id) => {
                 const card = cardDatabase.find(c => c.id === id);
                 if (!card) return `<div class="w-full aspect-[2.5/3.5] rounded-lg shadow-lg bg-slate-700 flex items-center justify-center text-xs text-center p-1">Unknown ID: ${id}</div>`;
                 return `<img src="${card.imageUrl}" class="w-full rounded-lg shadow-lg" title="${card.name}" onerror="this.onerror=null;this.src='https://placehold.co/120x175/2d3748/e2e8f0?text=?';">`;
            }
            UI.nextCardsA.innerHTML = trialData.deckA.slice(0,4).map(simpleCardMapper).join('');
            UI.fullDeckA.innerHTML = trialData.deckA.slice(4).map(simpleCardMapper).join('');
            UI.nextCardsB.innerHTML = trialData.deckB.slice(0,4).map(simpleCardMapper).join('');
            UI.fullDeckB.innerHTML = trialData.deckB.slice(4).map(simpleCardMapper).join('');
        }

        function handleSimulationInput(e) {
            if (document.activeElement === UI.trialNotes) return;
            if (document.activeElement === UI.shootoutNotes) return;
            
            // Handle simulation mode
            if (UI.simulationView.classList.contains('hidden') || UI.simulationDisplay.classList.contains('hidden')) {
                // Handle shootout mode
                if (!UI.shootoutSimulatorView.classList.contains('hidden')) {
                    handleShootoutInput(e);
                }
                return;
            }
            
            let choice = null;
            if (e.key === 'ArrowLeft') choice = 'A';
            if (e.key === 'ArrowRight') choice = 'B';
            if (e.key === 'ArrowDown') choice = 'TIE';
            if (e.key === 'ArrowUp') { undoLastChoice(); return; }
            if (e.key === 'Delete') { e.preventDefault(); endSimulation(); return; }
            if (choice) {
                e.preventDefault();
                const lastTrial = simulationState.history[simulationState.history.length - 1];
                const notes = UI.trialNotes.value.trim();
                simulationState.results.push({ choice, handA: lastTrial.handA, handB: lastTrial.handB, notes });
                nextTrial();
            }
        }

        function handleShootoutInput(e) {
            if (e.key === 'ArrowLeft') {
                e.preventDefault();
                ShootoutManager.handleJudgment('user');
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                ShootoutManager.handleJudgment('opponent');
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                ShootoutManager.handleJudgment('tie');
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                ShootoutManager.undo();
            }
        }

        function undoLastChoice() {
            if (simulationState.results.length === 0) { showMessage("No choices to undo."); return; }
            simulationState.results.pop();
            simulationState.currentTrial--;
            simulationState.history.pop();
            const lastTrialData = simulationState.history[simulationState.history.length-1];
            renderTrial(lastTrialData);
            UI.trialCounter.textContent = `${simulationState.currentTrial} / ${simulationState.totalTrials}`;
        }
        
        function endSimulation(premature = false) {
            if (simulationState.results && simulationState.results.length > 0) {
                lastSimulationSettings = { ...simulationState };
                generateReport();
                showView('reportView');
            } else {
                if (!premature) showMessage("No data to report. Simulation cancelled.");
                showView('simulationView');
            }
            
            UI.simulationSetup.classList.remove('hidden');
            UI.simulationDisplay.classList.add('hidden');
            UI.trialCounter.parentElement.classList.add('hidden');
            // FIX: Don't clear simulationState here, it's needed for the report. Clear it at the start of a new simulation.
            // simulationState = {};
        }
        
        // --- REPORTING LOGIC ---
        function generateReport() {
            const { results, targetCardId, compareCardId, baseDeckForSim, sidingPattern, mode } = lastSimulationSettings;
            if (!results || results.length === 0) return;

            const total = results.length;
            const winsA = results.filter(r => r.choice === 'A').length;
            const winsB = results.filter(r => r.choice === 'B').length;
            const ties = results.filter(r => r.choice === 'TIE').length;
            const getCardName = (id) => cardDatabase.find(c => c.id === id)?.name || `Unknown (${id})`;
            const cardFreq = {};
            const allInvolvedCards = new Set(baseDeckForSim);
            if(compareCardId) allInvolvedCards.add(compareCardId);
            if(sidingPattern) sidingPattern.in.forEach(id => allInvolvedCards.add(id));

            allInvolvedCards.forEach(id => {
                 cardFreq[id] = { name: getCardName(id), in_A_wins: 0, in_B_wins: 0 };
            });
            
            results.forEach(result => {
                let tempHandA = [...result.handA];
                let tempHandB = [...result.handB];

                if (lastSimulationSettings.mode === 'standard') {
                    const forcedIndexA = tempHandA.indexOf(targetCardId);
                    if (forcedIndexA > -1) tempHandA.splice(forcedIndexA, 1);
                    const forcedIndexB = tempHandB.indexOf(compareCardId);
                     if (forcedIndexB > -1 && result.handA.includes(targetCardId)) tempHandB.splice(forcedIndexB, 1);
                }
                
                if (result.choice === 'A') {
                    new Set(tempHandA).forEach(id => { if(cardFreq[id]) cardFreq[id].in_A_wins++; });
                } else if (result.choice === 'B') {
                    new Set(tempHandB).forEach(id => { if(cardFreq[id]) cardFreq[id].in_B_wins++; });
                }
            });

            const sortedFreqA = Object.values(cardFreq).filter(c => c.in_A_wins > 0).sort((a,b) => b.in_A_wins - a.in_A_wins);
            const sortedFreqB = Object.values(cardFreq).filter(c => c.in_B_wins > 0).sort((a,b) => b.in_B_wins - a.in_B_wins);
            
            const deckAName = lastSimulationSettings.mode === 'analyze' ? 'Deck (Pre-side)' : `Deck (Control)`;
            const deckBName = lastSimulationSettings.mode === 'analyze' ? 'Deck (Post-side)' : `Deck (Test)`;

            UI.reportContent.innerHTML = `
                <h2 class="text-2xl font-bold mb-4 text-white">Simulation Report</h2>
                <div class="bg-slate-800 p-4 rounded-lg mb-6">
                    <h3 class="text-xl font-semibold mb-2 text-blue-300">Overall Results</h3>
                    <p><strong>${deckAName}:</strong> ${winsA} wins (${((winsA/total)*100||0).toFixed(1)}%)</p>
                    <p><strong>${deckBName}:</strong> ${winsB} wins (${((winsB/total)*100||0).toFixed(1)}%)</p>
                    <p><strong>Tied Hands:</strong> ${ties} (${((ties/total)*100||0).toFixed(1)}%)</p>
                    <p><strong>Total Trials Evaluated:</strong> ${total}</p>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div class="bg-slate-800 p-4 rounded-lg">
                        <h3 class="text-xl font-semibold mb-2 text-green-400">${deckAName}: Top Performing Cards</h3>
                        <ul id="top-cards-list-a" class="list-disc list-inside space-y-1"></ul>
                        <button id="show-more-btn-a" class="text-sm text-blue-400 hover:underline mt-2 hidden">Show More</button>
                    </div>
                    <div class="bg-slate-800 p-4 rounded-lg">
                        <h3 class="text-xl font-semibold mb-2 text-green-400">${deckBName}: Top Performing Cards</h3>
                        <ul id="top-cards-list-b" class="list-disc list-inside space-y-1"></ul>
                        <button id="show-more-btn-b" class="text-sm text-blue-400 hover:underline mt-2 hidden">Show More</button>
                    </div>
                </div>
            `;
            
            // Populate the "Show More" lists
            const listA = document.getElementById('top-cards-list-a');
            const btnA = document.getElementById('show-more-btn-a');
            listA.innerHTML = sortedFreqA.slice(0, 5).map(c => `<li>${c.name}: ${c.in_A_wins} wins</li>`).join('');

            if (sortedFreqA.length > 5) {
                btnA.classList.remove('hidden');
                btnA.onclick = () => {
                    listA.innerHTML = sortedFreqA.map(c => `<li>${c.name}: ${c.in_A_wins} wins</li>`).join('');
                    btnA.classList.add('hidden');
                };
            }
            
            const listB = document.getElementById('top-cards-list-b');
            const btnB = document.getElementById('show-more-btn-b');
            listB.innerHTML = sortedFreqB.slice(0, 5).map(c => `<li>${c.name}: ${c.in_B_wins} wins</li>`).join('');
            
            if (sortedFreqB.length > 5) {
                btnB.classList.remove('hidden');
                btnB.onclick = () => {
                    listB.innerHTML = sortedFreqB.map(c => `<li>${c.name}: ${c.in_B_wins} wins</li>`).join('');
                    btnB.classList.add('hidden');
                };
            }

            UI.aiReportAnalysisContent.innerHTML = '';
            
            // Show appropriate buttons based on API key availability
            if (geminiApiKey) {
                // Online mode: show API-based buttons
                UI.aiReportAnalysisBtn.classList.remove('hidden');
                UI.generateAiEvaluatorBtn.classList.remove('hidden');
                UI.generatePromptBtn.classList.add('hidden');
                UI.generateAiEvaluatorPromptBtn.classList.add('hidden');
            } else {
                // Offline mode: show prompt generation buttons
                UI.aiReportAnalysisBtn.classList.add('hidden');
                UI.generateAiEvaluatorBtn.classList.add('hidden');
                UI.generatePromptBtn.classList.remove('hidden');
                UI.generateAiEvaluatorPromptBtn.classList.remove('hidden');
            }
            
            UI.rerunSection.classList.remove('hidden');
            UI.rerunTrialsInput.value = lastSimulationSettings.trials;

        }

        function exportReport() {
            const reportText = UI.reportContent.innerText + "\n\n--- AI ANALYSIS ---\n" + UI.aiReportAnalysisContent.innerText;
            const blob = new Blob([reportText], { type: 'text/plain;charset=utf-8' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `ygo-evaluation-report.txt`;
            a.click();
            URL.revokeObjectURL(a.href);
        }

        // --- THEME CUSTOMIZER ---
        function initializeTheme() {
            const customizerBtn = document.getElementById('toggle-customizer-btn');
            const customizerPanel = document.getElementById('customizer-panel');
            if (!customizerBtn || !customizerPanel) return;
            const colorInputs = customizerPanel.querySelectorAll('input[type="color"]');
            const resetBtn = document.getElementById('reset-theme-btn');

            const defaultTheme = {
                '--color-bg': '#1b1c1d',
                '--color-surface-1': '#2a2b2d',
                '--color-primary': '#2563eb',
                '--color-text-base': '#e2e8f0',
                '--color-border': '#475569',
            };

            function applyTheme(theme) {
                for (const [key, value] of Object.entries(theme)) {
                    document.documentElement.style.setProperty(key, value);
                    const input = customizerPanel.querySelector(`[data-var="${key}"]`);
                    if(input) input.value = value;
                }
            }

            const savedTheme = JSON.parse(localStorage.getItem('ygo-theme')) || defaultTheme;
            applyTheme(savedTheme);

            customizerBtn.addEventListener('click', () => customizerPanel.classList.toggle('hidden'));
            
            colorInputs.forEach(input => {
                input.addEventListener('input', (e) => {
                    const varName = e.target.dataset.var;
                    const value = e.target.value;
                    document.documentElement.style.setProperty(varName, value);
                    
                    const currentTheme = JSON.parse(localStorage.getItem('ygo-theme')) || {};
                    currentTheme[varName] = value;
                    localStorage.setItem('ygo-theme', JSON.stringify(currentTheme));
                });
            });

            resetBtn.addEventListener('click', () => {
                localStorage.removeItem('ygo-theme');
                applyTheme(defaultTheme);
            });
        }
        
        // --- CHIBI EASTER EGG ---
        function initializeChibiAnimation() {
            console.log('Initializing chibi animation...');
            let chibi = document.getElementById('chibi-logo');
            if (!chibi) {
                console.error('Chibi logo element not found!');
                return;
            }
            console.log('Chibi logo element found:', chibi);

            // Logging function for chibi actions
            const logChibiAction = (message) => {
                console.log(`[Chibi] ${message}`);
            };

            let clickCount = 0;
            let isAnimated = false;
            let animationStarting = false; // NEW: Flag to prevent multiple simultaneous starts
            let lastClickTime = 0; // NEW: For debouncing clicks
            let pos = { x: 0, y: 0 };
            let vel = { x: 0, y: 0 };
            let hyperSpeedCleanup = false; // NEW: Flag for fast cleanup
            let cleanupClickListener = null; // NEW: Listener for triple-click
            let cleanupClickCount = 0;
            // NEW: Counters for coins and particles
            let coinClickCounter = 0;
            let coinsOnScreenCounter = 0;
            let confettiOnScreenCounter = 0;
            let diamondsOnScreenCounter = 0;
            let counterDisplayElement = null;
            let cleanupClickTimer = null;
            const gravity = 0.5;
            const friction = 0.98;
            const chibiSize = 200; // Make the chibi even bigger
            let effectCycle = 0; // To cycle through different effects
            let itemContainer = null; // To hold all the thrown items
            let throwCoinsAndLootImpl = null; // Unified throw handler set when animation starts
            // Preloaded Normal Trap card images (pool + fallback)
            let normalTrapImages = [];
            let trapPoolLoading = false;
            // --- Helper Clones State ---
            let cloneContainer = null;
            let chibiClones = [];
            const CLONE_MAX = 8;
            const CLONE_SIZE = 140;
            const DESPAWN_THRESHOLD = 3;
            let cloneClickSpawnHandler = null;
            let cloneKeySpawnHandler = null;
            let lastCloneSpawnTs = 0;
            const CLONE_SPAWN_THROTTLE_MS = 150;
            const FALLBACK_TRAP_IDS = [
                4206964,   // Trap Hole
                53582587,  // Torrential Tribute
                29401950,  // Bottomless Trap Hole
                94192409,  // Compulsory Evacuation Device
                44095762,  // Mirror Force
                70342167,  // Dimensional Prison
                50078509,  // Fiendish Chain
                38411870,  // Needle Ceiling
                78474168,  // Breakthrough Skill
                82732705,  // Crackdown
                97631303,  // Evenly Matched
                43694650,  // Ice Dragon's Prison
                10045474,  // Infinite Impermanence
                69680031,  // Dogmatika Punishment
                14532163,  // Lost Wind
                83555666,  // Ring of Destruction
                71587526,  // Karma Cut
                63356631   // Phoenix Wing Wind Blast
            ];
            const getTrapSmallUrl = (id) => `https://images.ygoprodeck.com/images/cards_small/${id}.jpg`;
            const pickRandom = (arr) => arr[Math.floor(Math.random() * arr.length)];
            const getRandomFallbackTrapUrl = () => getTrapSmallUrl(pickRandom(FALLBACK_TRAP_IDS));
            const loadNormalTrapPoolOnce = async () => {
                if (trapPoolLoading || normalTrapImages.length > 0) return;
                trapPoolLoading = true;
                try {
                    const resp = await fetch('https://db.ygoprodeck.com/api/v7/cardinfo.php?type=Trap%20Card&race=Normal&num=200');
                    if (resp.ok) {
                        const data = await resp.json();
                        if (data && Array.isArray(data.data)) {
                            normalTrapImages = data.data
                                .map(c => c?.card_images?.[0]?.image_url_small)
                                .filter(Boolean);
                        }
                    }
                } catch (_e) {
                    // ignore; fallback will be used
                } finally {
                    trapPoolLoading = false;
                }
            };

            let activeDiamonds = []; // NEW: To store active diamonds for force field effect

            // Animation state machine variables (moved to proper scope)
            const ANIM_STATES = {
                IDLE: { duration: 0, scaleY: 1.0, scaleX: 1.0, rotation: 0 },
                ANTICIPATE: { duration: 200, scaleY: 0.7, scaleX: 1.2, rotation: 0 },
                JUMP: { duration: 100, scaleY: 1.3, scaleX: 0.8, rotation: 0 },
                APEX: { duration: 150, scaleY: 1.0, scaleX: 1.0, rotation: 0 },
                FALL: { duration: 200, scaleY: 1.1, scaleX: 0.95, rotation: 0 },
                LAND: { duration: 100, scaleY: 0.6, scaleX: 1.3, rotation: 0 },
                BOUNCE: { duration: 80, scaleY: 0.8, scaleX: 1.1, rotation: 0 }
            };

            let currentState = 'IDLE';
            let stateStartTime = 0;
            let stateProgress = 0;
            let animationFrameId = null;
            let bounceCount = 0;
            let maxBounces = 2;
            let isLanding = false;

            // Easing functions for smooth animation
            const easing = {
                easeOutQuad: (t) => t * (2 - t),
                easeInQuad: (t) => t * t,
                easeOutElastic: (t) => t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * ((2 * Math.PI) / 3)) + 1,
                easeInOutCubic: (t) => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2,
                lerp: (a, b, t) => a + (b - a) * t
            };

            // Animation functions (moved to proper scope)
            const setAnimationState = (newState) => {
                console.log(`State transition: ${currentState} -> ${newState}`);
                currentState = newState;
                stateStartTime = performance.now();
                stateProgress = 0;
            };

            const updateChibiTransform = () => {
                const state = ANIM_STATES[currentState];
                const elapsed = performance.now() - stateStartTime;
                stateProgress = Math.min(elapsed / state.duration, 1);

                // Apply easing based on state
                let easedProgress = stateProgress;
                if (currentState === 'JUMP') {
                    easedProgress = easing.easeOutQuad(stateProgress);
                } else if (currentState === 'FALL') {
                    easedProgress = easing.easeInQuad(stateProgress);
                } else if (currentState === 'LAND' || currentState === 'BOUNCE') {
                    easedProgress = easing.easeOutElastic(stateProgress);
                } else if (currentState === 'ANTICIPATE') {
                    easedProgress = easing.easeInOutCubic(stateProgress);
                }

                // Calculate squash and stretch
                const scaleY = easing.lerp(1.0, state.scaleY, easedProgress);
                const scaleX = easing.lerp(1.0, state.scaleX, easedProgress);
                
                // Calculate rotation based on horizontal velocity
                const rotation = Math.min(Math.max(vel.x * 0.5, -15), 15);

                // Apply physics for position - always apply if there's velocity
                if (Math.abs(vel.x) > 0.1 || Math.abs(vel.y) > 0.1) {
                    vel.y += gravity;
                    pos.x += vel.x;
                    pos.y += vel.y;
                    
                    // Debug: Log when position changes
                    if (Math.abs(vel.x) > 0.1 || Math.abs(vel.y) > 0.1) {
                        console.log(`Physics applied: pos(${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}) vel(${vel.x.toFixed(1)}, ${vel.y.toFixed(1)}) state:${currentState}`);
                    }

                    // Bounce off walls
                    if (pos.x <= 0 || pos.x >= window.innerWidth - chibiSize) {
                        vel.x *= -0.8;
                        pos.x = Math.max(0, Math.min(pos.x, window.innerWidth - chibiSize));
                    }
                    // Bounce off floor and ceiling
                    if (pos.y <= 0 || pos.y >= window.innerHeight - chibiSize) {
                        vel.y *= -0.8;
                        pos.y = Math.max(0, Math.min(pos.y, window.innerHeight - chibiSize));
                        // If it hits the floor, apply friction to horizontal movement
                        if (pos.y >= window.innerHeight - chibiSize) {
                            vel.x *= friction;
                        }
                    }
                }

                // Apply transform with squash, stretch, and rotation
                chibi.style.transform = `translate(${pos.x}px, ${pos.y}px) scale(${scaleX}, ${scaleY}) rotate(${rotation}deg)`;
                
                // Debug: Log position and velocity occasionally
                if (Math.random() < 0.01) {
                    console.log(`Chibi: pos(${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}) vel(${vel.x.toFixed(1)}, ${vel.y.toFixed(1)}) state:${currentState}`);
                }
            };

            const animationLoop = () => {
                if (!isAnimated) {
                    console.log('Animation loop stopped - isAnimated is false');
                    return;
                }

                updateChibiTransform();
                
                // Debug: Log occasionally to see if loop is running
                if (Math.random() < 0.01) {
                    console.log('Animation loop running, pos:', pos.x, pos.y, 'vel:', vel.x, vel.y, 'state:', currentState);
                }

                // Check for state transitions
                const state = ANIM_STATES[currentState];
                const elapsed = performance.now() - stateStartTime;

                if (elapsed >= state.duration) {
                    switch (currentState) {
                        case 'ANTICIPATE':
                            setAnimationState('JUMP');
                            // Apply jump velocity
                            vel.y = -12 - Math.random() * 6;
                            vel.x = (Math.random() - 0.5) * 18;
                            break;
                        case 'JUMP':
                            setAnimationState('APEX');
                            break;
                        case 'APEX':
                            setAnimationState('FALL');
                            break;
                        case 'FALL':
                            if (pos.y >= window.innerHeight - chibiSize) {
                                setAnimationState('LAND');
                                isLanding = true;
                                // Create dust cloud on landing
                                createDustCloud();
                                // Screen shake on heavy landing
                                if (Math.abs(vel.y) > 5) {
                                    createScreenShake();
                                }
                            } else {
                                setAnimationState('FALL');
                            }
                            break;
                        case 'LAND':
                            if (bounceCount < maxBounces && Math.abs(vel.y) > 2) {
                                setAnimationState('BOUNCE');
                                bounceCount++;
                                vel.y *= -0.6; // Reduce bounce energy
                            } else {
                                setAnimationState('IDLE');
                                bounceCount = 0;
                                isLanding = false;
                            }
                            break;
                        case 'BOUNCE':
                            if (bounceCount < maxBounces && Math.abs(vel.y) > 2) {
                                setAnimationState('BOUNCE');
                                bounceCount++;
                                vel.y *= -0.6;
                            } else {
                                setAnimationState('IDLE');
                                bounceCount = 0;
                                isLanding = false;
                            }
                            break;
                        case 'IDLE':
                            // Add breathing animation to idle state
                            if (!chibi.classList.contains('chibi-idle')) {
                                chibi.classList.add('chibi-idle');
                            }
                            break;
                    }
                }

                animationFrameId = requestAnimationFrame(animationLoop);
                console.log('Animation frame scheduled, ID:', animationFrameId);
            };

            // Visual effects functions (moved to proper scope)
            const createDustCloud = () => {
                if (!itemContainer) return; // Don't create dust if container doesn't exist
                for (let i = 0; i < 8; i++) {
                    const dust = document.createElement('div');
                    dust.classList.add('chibi-dust');
                    dust.style.left = `${pos.x + chibiSize / 2 + (Math.random() - 0.5) * 40}px`;
                    dust.style.top = `${pos.y + chibiSize}px`;
                    itemContainer.appendChild(dust);
                    
                    // Animate dust particle
                    const dustVel = { x: (Math.random() - 0.5) * 4, y: -2 - Math.random() * 2 };
                    const dustGravity = 0.1;
                    let dustPos = { x: parseFloat(dust.style.left), y: parseFloat(dust.style.top) };
                    
                    const dustStartTime = performance.now();
                    const dustLoop = () => {
                        dustVel.y += dustGravity;
                        dustPos.x += dustVel.x;
                        dustPos.y += dustVel.y;
                        
                        dust.style.left = `${dustPos.x}px`;
                        dust.style.top = `${dustPos.y}px`;
                        dust.style.opacity = Math.max(0, 1 - (performance.now() - dustStartTime) / 1000);
                        
                        if (dust.style.opacity > 0) {
                            requestAnimationFrame(dustLoop);
                        } else {
                            dust.remove();
                        }
                    };
                    dustLoop();
                }
            };

            const createScreenShake = () => {
                const originalTransform = document.body.style.transform;
                let shakeIntensity = 3;
                let shakeCount = 0;
                const maxShakes = 8;
                
                const shake = () => {
                    if (shakeCount >= maxShakes) {
                        document.body.style.transform = originalTransform;
                        return;
                    }
                    
                    const x = (Math.random() - 0.5) * shakeIntensity;
                    const y = (Math.random() - 0.5) * shakeIntensity;
                    document.body.style.transform = `translate(${x}px, ${y}px)`;
                    
                    shakeIntensity *= 0.8;
                    shakeCount++;
                    setTimeout(shake, 50);
                };
                shake();
            };

            const createMotionTrail = () => {
                if (Math.abs(vel.x) > 3 || Math.abs(vel.y) > 3) {
                    const trail = chibi.cloneNode(true);
                    trail.style.position = 'fixed';
                    trail.style.opacity = '0.3';
                    trail.style.pointerEvents = 'none';
                    trail.style.zIndex = '999';
                    trail.style.transform = chibi.style.transform;
                    // Avoid duplicate IDs and events on cloned node
                    trail.removeAttribute('id');
                    trail.setAttribute('aria-hidden', 'true');
                    trail.classList.add('chibi-trail');
                    document.body.appendChild(trail);
                    
                    setTimeout(() => trail.remove(), 200);
                }
            };

            const performHop = () => {
                console.log('performHop called - starting hop animation, current state:', currentState);
                console.log('Current position before hop:', pos.x, pos.y);
                // Start anticipation phase
                setAnimationState('ANTICIPATE');
                console.log('State set to ANTICIPATE, new state:', currentState);
                
                // Give the chibi strong initial velocity to start moving
                vel.x = (Math.random() - 0.5) * 20; // Strong random horizontal velocity
                vel.y = -15; // Strong upward velocity to start movement
                console.log('Strong initial velocity set:', vel.x, vel.y);
                
                // Force immediate movement
                pos.x += vel.x;
                pos.y += vel.y;
                chibi.style.transform = `translate(${pos.x}px, ${pos.y}px)`;
                console.log('Immediate position update:', pos.x, pos.y);
                console.log('Transform after immediate update:', chibi.style.transform);
                
                // Create motion trail for fast movement
                createMotionTrail();
                
                // Cycle through effects after a short delay
                setTimeout(() => {
                    console.log('performThrowEffect called from performHop');
                    performThrowEffect();
                }, 150);
            };

            // Create a container for all the items the chibi throws
            const createItemContainer = () => {
                itemContainer = document.createElement('div');
                // Ensure particles render above the UI and don't capture clicks
                itemContainer.style.position = 'fixed';
                itemContainer.style.top = '0';
                itemContainer.style.left = '0';
                itemContainer.style.width = '100vw';
                itemContainer.style.height = '100vh';
                itemContainer.style.pointerEvents = 'none';
                itemContainer.style.zIndex = '12000';
                document.body.appendChild(itemContainer);
            };

            // Ensure container for helper clones
            const ensureCloneContainer = () => {
                if (cloneContainer && cloneContainer.isConnected) return;
                cloneContainer = document.createElement('div');
                cloneContainer.style.position = 'fixed';
                cloneContainer.style.top = '0';
                cloneContainer.style.left = '0';
                cloneContainer.style.width = '100vw';
                cloneContainer.style.height = '100vh';
                cloneContainer.style.pointerEvents = 'none';
                cloneContainer.style.zIndex = '13000';
                document.body.appendChild(cloneContainer);
            };

            const getRemainingUnclaimedItems = () => {
                if (!itemContainer) return [];
                return Array.from(itemContainer.children).filter(el => !el.dataset.claimed && el.isConnected);
            };

            const maybeDespawnClones = () => {
                const remaining = getRemainingUnclaimedItems().length;
                if (remaining <= DESPAWN_THRESHOLD && chibiClones.length > 0) {
                    // Poof all clones
                    for (const clone of [...chibiClones]) {
                        poofClone(clone);
                    }
                }
            };

            const poofClone = (clone) => {
                if (!clone || !clone.isConnected) return;
                // Jump up a bit and wiggle
                const rect = clone.getBoundingClientRect();
                const startX = rect.left;
                const startY = rect.top;
                clone.style.transition = 'transform 200ms ease-out, opacity 300ms ease-in';
                clone.classList.add('chibi-wiggle');
                clone.style.transform = `translate(${startX}px, ${Math.max(0, startY - 60)}px)`;
                // Clouds
                for (let i = 0; i < 5; i++) {
                    const cloud = document.createElement('div');
                    cloud.className = 'poof-cloud';
                    const angle = (Math.PI * 2 * i) / 5;
                    const radius = 10 + Math.random() * 10;
                    cloud.style.left = `${startX + CLONE_SIZE / 2 + Math.cos(angle) * 8}px`;
                    cloud.style.top = `${startY + CLONE_SIZE / 2 + Math.sin(angle) * 8}px`;
                    cloneContainer.appendChild(cloud);
                    setTimeout(() => cloud.remove(), 600);
                }
                setTimeout(() => {
                    clone.style.opacity = '0';
                    setTimeout(() => {
                        if (clone.parentNode) clone.parentNode.removeChild(clone);
                        const idx = chibiClones.indexOf(clone);
                        if (idx >= 0) chibiClones.splice(idx, 1);
                    }, 220);
                }, 200);
            };

            const moveTowards = (clone, targetX, targetY, speed = 24) => {
                const rect = clone.getBoundingClientRect();
                const dx = targetX - rect.left;
                const dy = targetY - rect.top;
                const dist = Math.hypot(dx, dy);
                if (dist < 8) return true;
                const vx = (dx / dist) * speed;
                const vy = (dy / dist) * speed;
                clone.style.transform = `translate(${rect.left + vx}px, ${rect.top + vy}px)`;
                return false;
            };

            const collectItemByClone = (clone, item) => {
                if (!item || item.dataset.claimed) return;
                item.dataset.claimed = 'true';
                item.style.transition = 'transform 150ms ease-in, opacity 150ms ease-in';
                item.style.transform = 'scale(0)';
                item.style.opacity = '0';
                setTimeout(() => {
                    if (item.parentNode) item.parentNode.removeChild(item);
                    if (item.classList.contains('chibi-coin')) {
                        coinsOnScreenCounter--;
                    } else if (item.classList.contains('chibi-confetti')) {
                        confettiOnScreenCounter--;
                    } else if (item.classList.contains('chibi-diamond')) {
                        diamondsOnScreenCounter--;
                    }
                    updateCounterDisplay();
                    maybeDespawnClones();
                }, 160);
            };

            const assistCleanupLoop = (clone) => {
                if (!hyperSpeedCleanup) return; // stop if mode off
                const items = getRemainingUnclaimedItems();
                if (items.length === 0) {
                    poofClone(clone);
                    return;
                }
                // Find nearest
                const rect = clone.getBoundingClientRect();
                let best = null, bestDist = Infinity;
                for (const it of items) {
                    const r = it.getBoundingClientRect();
                    const cx = r.left + r.width / 2;
                    const cy = r.top + r.height / 2;
                    const d = Math.hypot(cx - rect.left, cy - rect.top);
                    if (d < bestDist) { bestDist = d; best = { it, cx, cy }; }
                }
                if (!best) { poofClone(clone); return; }
                const reached = moveTowards(clone,
                    Math.max(0, Math.min(best.cx - CLONE_SIZE / 2, window.innerWidth - CLONE_SIZE)),
                    Math.max(0, Math.min(best.cy - CLONE_SIZE / 2, window.innerHeight - CLONE_SIZE)),
                    28 // faster chase
                );
                if (reached) {
                    collectItemByClone(clone, best.it);
                    setTimeout(() => assistCleanupLoop(clone), 10);
                } else {
                    requestAnimationFrame(() => assistCleanupLoop(clone));
                }
            };

            const spawnChibiClone = () => {
                if (!hyperSpeedCleanup || !itemContainer) return;
                const now = Date.now();
                if (now - lastCloneSpawnTs < CLONE_SPAWN_THROTTLE_MS) return;
                lastCloneSpawnTs = now;
                if (chibiClones.length >= CLONE_MAX) return;
                ensureCloneContainer();
                const img = document.createElement('img');
                img.src = chibi.src;
                img.className = 'chibi-clone';
                img.style.position = 'fixed';
                img.style.top = '0px';
                img.style.left = '0px';
                img.style.width = `${CLONE_SIZE}px`;
                img.style.height = `${CLONE_SIZE}px`;
                img.style.pointerEvents = 'none';
                img.style.zIndex = '13001';
                const startX = Math.random() * (window.innerWidth - CLONE_SIZE);
                img.style.transform = `translate(${startX}px, -${CLONE_SIZE}px)`;
                cloneContainer.appendChild(img);
                chibiClones.push(img);
                // Drop from sky
                setTimeout(() => {
                    const landY = Math.max(0, window.innerHeight - CLONE_SIZE - 6);
                    img.style.transition = 'transform 180ms cubic-bezier(0.2, 0.8, 0.2, 1)';
                    img.style.transform = `translate(${startX + (Math.random()*20-10)}px, ${landY}px)`;
                    setTimeout(() => {
                        img.style.transition = 'transform 80ms linear';
                        assistCleanupLoop(img);
                    }, 190);
                }, 10);
            };

            const activateHyperSpawnControls = () => {
                if (cloneClickSpawnHandler || cloneKeySpawnHandler) return;
                cloneClickSpawnHandler = (e) => {
                    if (!hyperSpeedCleanup) return;
                    if (e.target.closest && e.target.closest('button, a, input, select, textarea, #chibi-logo')) return;
                    spawnChibiClone();
                };
                cloneKeySpawnHandler = (e) => {
                    if (!hyperSpeedCleanup) return;
                    if (e.code !== 'Space') return;
                    if (document.activeElement && document.activeElement.matches('input, textarea, select')) return;
                    e.preventDefault();
                    spawnChibiClone();
                };
                document.addEventListener('click', cloneClickSpawnHandler, true);
                document.addEventListener('keydown', cloneKeySpawnHandler);
            };

            const deactivateHyperSpawnControls = () => {
                if (cloneClickSpawnHandler) {
                    document.removeEventListener('click', cloneClickSpawnHandler, true);
                    cloneClickSpawnHandler = null;
                }
                if (cloneKeySpawnHandler) {
                    document.removeEventListener('keydown', cloneKeySpawnHandler);
                    cloneKeySpawnHandler = null;
                }
            };


            // NEW: Function to handle the immediate click effect for throwing items.
            const handleClickThrow = (e) => {
                // Don't count clicks if the animation isn't active or if clicking on an interactive element.
                if (!isAnimated || e.target.closest('button, a, input, select, textarea, #chibi-logo')) {
                    return;
                }
                
                logChibiAction('Screen click detected. Incrementing coin counter.');
                
                // Increment the coin counter and update the display
                coinClickCounter++;
                updateCounterDisplay();
                // Immediately throw accumulated loot
                if (throwCoinsAndLootImpl) {
                    throwCoinsAndLootImpl();
                }
            };

            // NEW: Function to handle spacebar key presses for throwing items.
            const handleKeyThrow = (e) => {
                // Only respond to spacebar
                if (e.code !== 'Space') return;
                
                // Don't count spacebar if the animation isn't active or if focused on an interactive element
                if (!isAnimated || document.activeElement && document.activeElement.matches('input, textarea, select')) {
                    return;
                }
                
                // Prevent default spacebar behavior (scrolling)
                e.preventDefault();
                
                logChibiAction('Spacebar pressed. Incrementing coin counter.');
                
                // Increment the coin counter and update the display
                coinClickCounter++;
                updateCounterDisplay();
                // Immediately throw accumulated loot
                if (throwCoinsAndLootImpl) {
                    throwCoinsAndLootImpl();
                }
            };

            // NEW: Function to update the counter display
            const updateCounterDisplay = () => {
                if (!counterDisplayElement) return;
                const coinsOnScreenSpan = counterDisplayElement.querySelector('#chibi-coins-on-screen-count');
                const confettiSpan = counterDisplayElement.querySelector('#chibi-confetti-count');
                const diamondSpan = counterDisplayElement.querySelector('#chibi-diamond-count');
                // Live on-screen counts (source of truth = DOM)
                const domCoins = itemContainer ? itemContainer.querySelectorAll('.chibi-coin').length : 0;
                const domConfetti = itemContainer ? itemContainer.querySelectorAll('.chibi-confetti').length : 0;
                const domDiamonds = itemContainer ? itemContainer.querySelectorAll('.chibi-diamond, .chibi-super-diamond').length : 0;
                if (coinsOnScreenSpan) coinsOnScreenSpan.textContent = domCoins;
                if (confettiSpan) confettiSpan.textContent = domConfetti;
                if (diamondSpan) diamondSpan.textContent = domDiamonds;
            };

            // MODIFIED: This function no longer instantly throws an item on click.
            // It now only increments the coin counter. The throw logic is handled in `throwCoin`.
            const oldHandleClickThrow = (e) => {
                if (!isAnimated || e.target.closest('button, a, input, select, textarea, #chibi-logo')) {
                    return;
                }
                coinClickCounter++;
                
                // Reset the regular hop interval so it doesn't interrupt rapid clicks.
                // The regular hop will resume after the specified delay.
                clearTimeout(chibiAnimationState.hopInterval);
                chibiAnimationState.hopInterval = setTimeout(performHop, 2500);
            };

            const createEffortMarks = () => {
                if (!itemContainer) return; // Don't create marks if container doesn't exist
                // Create sweat drops or effort marks
                for (let i = 0; i < 3; i++) {
                    const mark = document.createElement('div');
                    mark.classList.add('chibi-effort-mark');
                    mark.style.left = `${pos.x + chibiSize - 10 + Math.random() * 20}px`;
                    mark.style.top = `${pos.y + 10 + Math.random() * 20}px`;
                    itemContainer.appendChild(mark);
                    
                    setTimeout(() => mark.remove(), 1000);
                }
            };
            
            const createActionLines = () => {
                if (!itemContainer) return; // Don't create lines if container doesn't exist
                // Create manga-style action lines
                for (let i = 0; i < 5; i++) {
                    const line = document.createElement('div');
                    line.classList.add('chibi-action-line');
                    const angle = (Math.random() - 0.5) * 60; // 30 degrees
                    const length = 30 + Math.random() * 20;
                    const x = pos.x + chibiSize / 2 + (Math.random() - 0.5) * 40;
                    const y = pos.y + chibiSize / 2 + (Math.random() - 0.5) * 40;
                    
                    line.style.left = `${x}px`;
                    line.style.top = `${y}px`;
                    line.style.width = `${length}px`;
                    line.style.transform = `rotate(${angle}deg)`;
                    itemContainer.appendChild(line);
                    
                    setTimeout(() => line.remove(), 300);
                }
            };

            const throwConfetti = () => {
                if (!itemContainer) return; // Don't throw if container doesn't exist
                for (let i = 0; i < 25; i++) { // Increased confetti count
                    const confetti = document.createElement('div');
                    confettiOnScreenCounter++; // NEW: Increment confetti counter

                    confetti.classList.add('chibi-confetti');
                    confetti.style.backgroundColor = `hsl(${Math.random() * 360}, 100%, 70%)`;
                    if (itemContainer) itemContainer.appendChild(confetti);

                    let cPos = { x: pos.x + chibiSize / 2, y: pos.y + chibiSize / 2 };
                    let cVel = { x: (Math.random() - 0.5) * 25, y: -10 - Math.random() * 10 };
                    let rot = 0;
                    let rotSpeed = (Math.random() - 0.5) * 20;
                    const confettiGravity = 0.4;
                    const bounce = 0.4;

                    const confettiLoop = () => {
                        cVel.y += confettiGravity;
                        cPos.x += cVel.x;
                        cPos.y += cVel.y;
                        rot += rotSpeed;

                        if (cPos.x <= 0 || cPos.x >= window.innerWidth - 10) cVel.x *= -0.8;

                        if (cPos.y >= window.innerHeight - 10) {
                            cPos.y = window.innerHeight - 10;
                            cVel.y *= -bounce;
                            cVel.x *= 0.7;
                            rotSpeed *= 0.7;
                            if (Math.abs(cVel.y) < 1) cVel.y = 0;
                        }

                        confetti.style.transform = `translate(${cPos.x}px, ${cPos.y}px) rotate(${rot}deg)`;
                        if (Math.abs(cVel.x) > 0.1 || Math.abs(cVel.y) > 0.1 || cPos.y < window.innerHeight - 11) requestAnimationFrame(confettiLoop);
                    };
                    confettiLoop();
                }
                logChibiAction('Threw confetti.');
            };

                const throwCoin = () => {
                    if (!itemContainer) return; // Don't throw if container doesn't exist
                    const coinsToThrow = Math.max(2, coinClickCounter); // at least 2 for visibility
                logChibiAction(`Throwing ${coinsToThrow} coin(s).`);
                
                for (let i = 0; i < coinsToThrow; i++) {
                    const coin = document.createElement('div');
                    coinsOnScreenCounter++;
                    coin.classList.add('chibi-coin');
                    coin.textContent = '';
                    if (itemContainer) itemContainer.appendChild(coin);

                    let cPos = { x: pos.x + chibiSize / 2, y: pos.y + chibiSize / 2 };
                    let cVel = { x: (Math.random() - 0.5) * 20, y: -10 - Math.random() * 5 };
                    const coinGravity = 0.4;

                    const coinLoop = () => {
                        cVel.y += coinGravity;
                        cPos.x += cVel.x;
                        cPos.y += cVel.y;

                        if (cPos.x <= 0 || cPos.x >= window.innerWidth - 20) cVel.x *= -0.8;
                        if (cPos.y >= window.innerHeight - 20) {
                            cPos.y = window.innerHeight - 20;
                            cVel.y *= -0.6;
                            cVel.x *= 0.8;
                            if (Math.abs(cVel.y) < 1) return;
                        }

                        coin.style.transform = `translate(${cPos.x}px, ${cPos.y}px)`;
                        if (Math.abs(cVel.x) > 0.05 || Math.abs(cVel.y) > 0.05 || cPos.y < window.innerHeight - 21) requestAnimationFrame(coinLoop);
                    };
                    coinLoop();
                }
                
                coinClickCounter = 0;
                updateCounterDisplay();
            };

                const throwTrapCard = async () => {
                if (!itemContainer) return; // Don't throw if container doesn't exist
                try {
                    // Use custom easter egg card pool instead of API
                    if (easterEggCardPool.length === 0) {
                        loadEasterEggCardPool(); // Load from localStorage if not already loaded
                    }
                    
                    let selectedCard;
                    if (easterEggCardPool.length > 0) {
                        // Use custom pool
                        selectedCard = easterEggCardPool[Math.floor(Math.random() * easterEggCardPool.length)];
                    } else {
                        // Fallback to default trap cards
                        selectedCard = { id: 4206964, name: "Trap Hole" };
                    }
                    
                    const card = document.createElement('img');
                    card.src = `https://images.ygoprodeck.com/images/cards_small/${selectedCard.id}.jpg`;
                    card.classList.add('chibi-trap');
                    if (itemContainer) itemContainer.appendChild(card);

                    let cPos = { x: pos.x + chibiSize / 2, y: pos.y + chibiSize / 2 };
                    let cVel = { x: (Math.random() - 0.5) * 15, y: -8 - Math.random() * 4 };
                    const cardGravity = 0.3;

                    const cardLoop = () => {
                        cVel.y += cardGravity;
                        cPos.x += cVel.x;
                        cPos.y += cVel.y;

                        if (cPos.x <= 0 || cPos.x >= window.innerWidth - 60) cVel.x *= -0.8;
                        if (cPos.y >= window.innerHeight - 86) {
                            cPos.y = window.innerHeight - 86;
                            cVel.y = 0;
                            cVel.x = 0;
                        }
                        card.style.transform = `translate(${cPos.x}px, ${cPos.y}px) rotate(${cVel.x * 1.5}deg)`;

                        if (cVel.y !== 0 || cVel.x !== 0) {
                            requestAnimationFrame(cardLoop);
                        }
                    };
                    cardLoop();
                } catch (e) {
                    logChibiAction(`<span class="text-red-400">Error fetching trap card: ${e.message}</span>`);
                    console.error("Failed to fetch trap card for easter egg:", e);
                }
            };

            const performThrowEffect = () => {
                // Add wind-up animation before throwing
                const originalScale = chibi.style.transform;
                const windUpScale = `translate(${pos.x}px, ${pos.y}px) scale(0.9, 1.1) rotate(-5deg)`;
                const recoilScale = `translate(${pos.x}px, ${pos.y}px) scale(1.1, 0.9) rotate(5deg)`;
                
                // Wind-up phase
                chibi.style.transform = windUpScale;
                
                setTimeout(() => {
                    // Recoil phase
                    chibi.style.transform = recoilScale;
                    
                    // Weighted random effects for more variety
                    const r = Math.random();
                    if (r < 0.35) {
                        throwConfetti();
                    } else if (r < 0.7) {
                        throwCoin();
                    } else {
                        // Drop multiple random cards for variety
                        throwTrapCard();
                        setTimeout(() => throwTrapCard(), 150);
                    }
                    effectCycle++;
                    logChibiAction(`Performed throw effect #${effectCycle}.`);
                    updateCounterDisplay();
                    
                    // Add effort marks during throw
                    createEffortMarks();
                    
                    // Add action lines for manga-style effect
                    createActionLines();
                    
                    // Return to normal after recoil
                    setTimeout(() => {
                        chibi.style.transform = originalScale;
                    }, 100);
                }, 80);
            };

            const startAnimation = () => {
                console.log('startAnimation called, isAnimated:', isAnimated, 'animationStarting:', animationStarting);
                // Prevent multiple animations from running simultaneously
                if (isAnimated || animationStarting) {
                    console.log('Animation already running or starting, ignoring startAnimation call');
                    return;
                }
                
                // Set both flags immediately to prevent race conditions
                animationStarting = true;
                isAnimated = true;
                
                // Show the easter egg edit button
                document.body.classList.add('easter-egg-active');
                
                // NEW: Ensure any leftover cleanup listeners from a previous animation are removed.
                if (cleanupClickListener) {
                    document.removeEventListener('click', cleanupClickListener);
                    cleanupClickListener = null;
                }
                const originalRect = chibi.getBoundingClientRect();
                pos = { x: originalRect.left, y: originalRect.top };
                console.log('Original chibi position:', originalRect.left, originalRect.top);
                console.log('Set pos to:', pos.x, pos.y);

                chibi.style.width = `${chibiSize}px`;
                chibi.style.height = `${chibiSize}px`;
                chibi.style.top = '0px';
                chibi.style.left = '0px';
                chibi.style.position = 'fixed';
                chibi.style.zIndex = '1000';
                // Set initial transform to maintain the original position
                chibi.style.transform = `translate(${pos.x}px, ${pos.y}px)`;
                console.log('Set initial transform to:', chibi.style.transform);
                // Override any conflicting CSS
                chibi.style.maxWidth = 'none';
                chibi.style.maxHeight = 'none';
                chibi.style.minWidth = '0';
                chibi.style.minHeight = '0';


                // NEW: Show tooltip for easter egg mode
                const showTooltip = (message, duration = 3000) => {
                    const tooltip = document.createElement('div');
                    tooltip.style.cssText = `
                        position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                        z-index: 2000; background-color: rgba(0, 0, 0, 0.9);
                        color: white; padding: 16px 24px; border-radius: 12px;
                        font-family: 'Inter', sans-serif; font-size: 16px; font-weight: 500;
                        text-align: center; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
                        border: 2px solid rgba(255, 255, 255, 0.2);
                        animation: tooltip-fade-in 0.3s ease-out, tooltip-fade-out 0.3s ease-in ${duration - 300}ms forwards;
                    `;
                    tooltip.textContent = message;
                    document.body.appendChild(tooltip);
                    
                    setTimeout(() => {
                        if (tooltip.parentNode) {
                            tooltip.remove();
                        }
                    }, duration);
                };

                showTooltip('Press the space bar or click to generate coins and loot!');

                // NEW: Create and display the counters
                // Remove any existing counter to prevent duplicates
                if (counterDisplayElement && counterDisplayElement.parentNode) {
                    counterDisplayElement.remove();
                }
                counterDisplayElement = document.createElement('div');
                counterDisplayElement.style.cssText = `
                    position: fixed; top: 10px; left: 10px; z-index: 1001;
                    background-color: rgba(42, 43, 45, 0.8); color: white;
                    padding: 8px 12px; border-radius: 8px; font-family: 'Inter', sans-serif;
                    font-size: 14px; display: flex; align-items: center; gap: 16px;
                    border: 1px solid var(--color-border);
                `;
                counterDisplayElement.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 6px;" title="Coins on Screen"><span style="font-size: 18px;"></span> <span id="chibi-coins-on-screen-count">0</span></div>
                    <div style="display: flex; align-items: center; gap: 6px;" title="Confetti on Screen"><span style="font-size: 18px;"></span> <span id="chibi-confetti-count">0</span></div>
                    <div style="display: flex; align-items: center; gap: 6px;" title="Diamonds on Screen"><span style="font-size: 18px;"></span> <span id="chibi-diamond-count">0</span></div>
                `;
                document.body.appendChild(counterDisplayElement);
                // Initial refresh
                updateCounterDisplay();

            // Ensure a single itemContainer exists
                if (itemContainer && itemContainer.parentNode) {
                    itemContainer.remove();
                    itemContainer = null;
                }
                createItemContainer(); // Always create a fresh container on start
                // Attach listeners once per animation start
                document.addEventListener('click', handleClickThrow, true); // Use capture to decide early if we should throw
                document.addEventListener('keydown', handleKeyThrow);


                // MODIFIED: This function now throws multiple coins based on the counter.
                const throwCoin = () => {
                    const coinsToThrow = Math.max(1, coinClickCounter); // Throw at least one coin
                    logChibiAction(`Throwing ${coinsToThrow} coin(s).`);
            
                    for (let i = 0; i < coinsToThrow; i++) {
                        // NEW: Add a rare chance to spawn a diamond instead of a coin
                        const isDiamond = Math.random() < 0.05; // 5% chance for a diamond
                        setTimeout(() => {
                        if (isDiamond) {
                            createSingleDiamond();
                        } else {
                            createSingleCoin();
                        }
                        }, i * 50); // Stagger the throws slightly
                    }
            
                    coinClickCounter = 0; // Reset the counter
                    updateCounterDisplay(); // Update display after spending clicks
                };

                // Expose a single throw entry for click/space handlers
                throwCoinsAndLootImpl = () => {
                    const r = Math.random();
                    if (r < 0.6) {
                        throwCoin();
                    } else if (r < 0.85) {
                        throwConfetti();
                    } else {
                        throwTrapCard();
                    }
                };

                // NEW: Function to apply force field effect from diamonds
                const applyDiamondForceField = (itemPos) => {
                    let force = { x: 0, y: 0 };
                    const forceRadius = 150; // The range of the force field
                    const maxForce = 2.5;    // The strength of the push

                    activeDiamonds.forEach(diamondState => {
                        const dx = itemPos.x - diamondState.pos.x;
                        const dy = itemPos.y - diamondState.pos.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < forceRadius && distance > 0) {
                            const falloff = 1 - (distance / forceRadius);
                            const pushForce = falloff * maxForce;
                            force.x += (dx / distance) * pushForce;
                            force.y += (dy / distance) * pushForce;
                        }
                    });

                    return force;
                };

                const createSingleCoin = () => {
                    // Check for SUPER diamond chance (1%)
                    const isSuperDiamond = Math.random() < 0.01;
                    
                    const coin = document.createElement('div');
                    coinsOnScreenCounter++; // NEW: Increment coin counter
                    
                    if (isSuperDiamond) {
                        coin.classList.add('chibi-super-diamond');
                        coin.textContent = ''; // Use same diamond emoji as regular diamonds
                    } else {
                        coin.classList.add('chibi-coin');
                    }
                    
                    itemContainer.appendChild(coin);

                    let cPos = { x: pos.x + chibiSize / 2, y: pos.y + chibiSize / 2 }; // Start from chibi's center
                    let cVel = { x: (Math.random() - 0.5) * 20, y: -10 - Math.random() * 5 };
                    let bounce = 0.6;
                    const coinGravity = 0.4;
                    let hasSettled = false; // Track if SUPER diamond has settled
                    let settleTime = 0; // Time when it settled
                    let ambientDirection = { x: (Math.random() - 0.5) * 0.5, y: (Math.random() - 0.5) * 0.5 }; // Ambient movement direction

                    const coinLoop = () => {
                        // NEW: Apply force from diamonds
                        const force = applyDiamondForceField(cPos);
                        cVel.x += force.x;
                        cVel.y += force.y;

                        if (isSuperDiamond) {
                            // SUPER diamonds have magical floating physics
                            cVel.y += coinGravity * 0.3; // Much lighter gravity
                            cVel.y -= 0.02; // Magical upward force
                            cVel.x *= 0.998; // Less friction for more magical movement
                            cVel.y *= 0.998;
                        } else {
                            cVel.y += coinGravity;
                        }
                        
                        cPos.x += cVel.x;
                        cPos.y += cVel.y;

                        // NEW: Bounce off side walls
                        if (cPos.x <= 0 || cPos.x >= window.innerWidth - 20) {
                            cVel.x *= -0.8;
                        }

                        if (cPos.y >= window.innerHeight - 20) {
                            cPos.y = window.innerHeight - 20;
                            cVel.y *= -bounce;
                            cVel.x *= 0.8;
                            if (Math.abs(cVel.y) < 1 && cPos.y >= window.innerHeight - 21) { // Let it rest
                        if (isSuperDiamond && !hasSettled) {
                                    hasSettled = true;
                                    settleTime = performance.now();
                                    logChibiAction('SUPER Diamond has settled and is now floating ambiently!');
                                } else if (!isSuperDiamond) {
                                    coin.style.animation = 'none'; // Stop spinning for regular coins
                                    // Keep it visible on the floor without exiting loop immediately
                                    cVel.x *= 0.9;
                                    cVel.y = 0;
                                }
                            }
                        }
                        
                        // Ambient floating for SUPER diamonds after settling
                        if (isSuperDiamond && hasSettled) {
                            const time = performance.now() - settleTime;
                            const ambientSpeed = 0.0008; // Slower, more stable movement
                            const ambientRadius = 30; // Smaller drift radius for stability
                            
                            // Smooth, stable ambient movement using multiple sine waves
                            const wave1 = Math.sin(time * ambientSpeed) * 0.3;
                            const wave2 = Math.sin(time * ambientSpeed * 0.6) * 0.2;
                            const wave3 = Math.cos(time * ambientSpeed * 0.4) * 0.1;
                            
                            // Apply gentle, stable movement
                            cPos.x += (wave1 + wave2) * ambientDirection.x;
                            cPos.y += (wave2 + wave3) * ambientDirection.y;
                            
                            // Keep within screen bounds with gentle bouncing
                            if (cPos.x < 0 || cPos.x > window.innerWidth - 200) {
                                ambientDirection.x *= -0.8; // Gentle direction change
                                cPos.x = Math.max(0, Math.min(window.innerWidth - 200, cPos.x));
                            }
                            if (cPos.y < 0 || cPos.y > window.innerHeight - 200) {
                                ambientDirection.y *= -0.8; // Gentle direction change
                                cPos.y = Math.max(0, Math.min(window.innerHeight - 200, cPos.y));
                            }
                        }
                        coin.style.left = `${cPos.x}px`;
                        coin.style.top = `${cPos.y}px`;
                        requestAnimationFrame(coinLoop);
                    };
                    coinLoop();
                };

                // NEW: Function to create a diamond
                const createSingleDiamond = () => {
                    const diamondId = `diamond-${Date.now()}-${Math.random()}`;
                    const diamond = document.createElement('div');
                    diamond.id = diamondId;
                    diamondsOnScreenCounter++; // NEW: Increment diamond counter
                    diamond.classList.add('chibi-diamond');
                    diamond.textContent = ''; // Use emoji for the diamond
                    
                    itemContainer.appendChild(diamond);
                
                    // Get actual chibi position from DOM element
                    const chibiRect = chibi.getBoundingClientRect();
                    const chibiCenterX = chibiRect.left + chibiRect.width / 2;
                    const chibiCenterY = chibiRect.top + chibiRect.height / 2;
                
                    // Spawn particle effect
                    for (let i = 0; i < 15; i++) {
                        const sparkle = document.createElement('div');
                        sparkle.classList.add('chibi-sparkle');
                        const angle = Math.random() * 2 * Math.PI;
                        const radius = Math.random() * 40;
                        const startX = chibiCenterX + 15;
                        const startY = chibiCenterY + 15;
                        sparkle.style.left = `${startX}px`;
                        sparkle.style.top = `${startY}px`;
                        sparkle.style.animationDelay = `${Math.random() * 0.2}s`;
                        itemContainer.appendChild(sparkle);
                        setTimeout(() => sparkle.remove(), 1200); // Correctly remove the sparkle
                    }
                    logChibiAction('Dropped a rare diamond!');
                    
                    // Create unique position for this diamond based on actual chibi position
                    let cPos = { 
                        x: chibiCenterX + (Math.random() - 0.5) * 30, 
                        y: chibiCenterY + (Math.random() - 0.5) * 30 
                    };
                    console.log('Diamond created:', diamondId, 'at position:', cPos, 'chibi at:', chibiCenterX, chibiCenterY);
                    
                    // Set initial position like coins do
                    diamond.style.left = `${cPos.x}px`;
                    diamond.style.top = `${cPos.y}px`;
                    let cVel = { x: (Math.random() - 0.5) * 8, y: -8 - Math.random() * 4 }; // Gentler initial velocity
                    let rot = 0;
                    let rotSpeed = (Math.random() - 0.5) * 8; // Slower rotation
                    const diamondGravity = 0.15; // Much lighter gravity
                    let hasSettled = false;
                    let settleTime = 0;
                    const bobbleSpeed = 0.03; // Slower, more elegant bob
                    const bobbleAmount = 8; // More pronounced floating
                    const magicFloat = 0.02; // Magical floating force
                
                    const diamondState = { id: diamondId, pos: cPos };
                    activeDiamonds.push(diamondState);
                
                    // Sparkle effect
                    const sparkleInterval = setInterval(() => {
                        if (!hasSettled || !document.getElementById(diamondId)) return;
                        const sparkle = document.createElement('div');
                        sparkle.classList.add('chibi-sparkle');
                        const angle = Math.random() * 2 * Math.PI;
                        const radius = 15 + Math.random() * 20;
                        sparkle.style.left = `${cPos.x + 15 + Math.cos(angle) * radius}px`;
                        sparkle.style.top = `${cPos.y + 15 + Math.sin(angle) * radius}px`;
                        if (itemContainer) itemContainer.appendChild(sparkle);
                        setTimeout(() => sparkle.remove(), 1000);
                    }, 200);
                
                    const diamondLoop = () => {
                        if (!hasSettled) {
                            // Apply lighter gravity and magical floating
                            cVel.y += diamondGravity;
                            cVel.y -= magicFloat; // Magical upward force
                            cPos.x += cVel.x;
                            cPos.y += cVel.y;
                            rot += rotSpeed;
                
                            // Gentler dampening for more magical feel
                            cVel.x *= 0.995;
                            cVel.y *= 0.995;
                            rotSpeed *= 0.99;
                
                            // Prevent going off-screen with softer boundaries
                            cPos.x = Math.max(40, Math.min(window.innerWidth - 80, cPos.x));
                            cPos.y = Math.max(40, Math.min(window.innerHeight - 80, cPos.y));
                
                            if (Math.abs(cVel.x) < 0.05 && Math.abs(cVel.y) < 0.05) {
                                hasSettled = true;
                                settleTime = performance.now();
                                logChibiAction('Diamond has settled and is now floating magically.');
                            }
                        } else {
                            // Magical floating animation - more complex than coins
                            const time = performance.now() - settleTime;
                            const floatX = Math.sin(time * bobbleSpeed * 0.7) * bobbleAmount * 0.3;
                            const floatY = Math.sin(time * bobbleSpeed) * bobbleAmount;
                            const gentleRotation = Math.sin(time * bobbleSpeed * 0.5) * 2;
                            
                            cPos.x += floatX * 0.01;
                            cPos.y += floatY * 0.01;
                            rot += rotSpeed + gentleRotation; // More dynamic rotation
                        }
                
                        diamond.style.left = `${cPos.x}px`;
                        diamond.style.top = `${cPos.y}px`;
                        diamond.style.transform = `rotate(${rot}deg)`;
                        
                        // Keep animating as long as the element exists
                        if (document.getElementById(diamondId)) {
                            requestAnimationFrame(diamondLoop);
                        } else {
                            clearInterval(sparkleInterval); // Cleanup sparkles
                            activeDiamonds = activeDiamonds.filter(d => d.id !== diamondId); // Cleanup force field
                        }
                    };
                    diamondLoop();
                };

                const throwTrapCard = async () => {
                    try {
                        // Use custom easter egg card pool instead of API
                        if (easterEggCardPool.length === 0) {
                            loadEasterEggCardPool(); // Load from localStorage if not already loaded
                        }
                        
                        let selectedCard;
                        if (easterEggCardPool.length > 0) {
                            // Use custom pool
                            selectedCard = easterEggCardPool[Math.floor(Math.random() * easterEggCardPool.length)];
                        } else {
                            // Fallback to default trap cards
                            selectedCard = { id: 4206964, name: "Trap Hole" };
                        }

                        const card = document.createElement('img');
                        card.src = `https://images.ygoprodeck.com/images/cards_small/${selectedCard.id}.jpg`;
                        card.classList.add('chibi-trap');
                        itemContainer.appendChild(card);

                        let cPos = { x: pos.x + chibiSize / 2, y: pos.y + chibiSize / 2 }; // Start from chibi's center
                        let cVel = { x: (Math.random() - 0.5) * 15, y: -8 - Math.random() * 4 };
                        const cardGravity = 0.3;

                        const cardLoop = () => {
                            cVel.y += cardGravity;
                            cPos.x += cVel.x;
                            cPos.y += cVel.y;

                            // NEW: Bounce off side walls
                            if (cPos.x <= 0 || cPos.x >= window.innerWidth - 60) { // 60px is the card width
                                cVel.x *= -0.8;
                            }

                            if (cPos.y >= window.innerHeight - 86) { // 86px is the small card height
                                cPos.y = window.innerHeight - 86;
                                cVel.y = 0;
                                cVel.x = 0;
                            }
                            card.style.transform = `translate(${cPos.x}px, ${cPos.y}px) rotate(${cVel.x * 1.5}deg)`;

                            if (cVel.y !== 0 || cVel.x !== 0) { // Keep looping until it rests
                                requestAnimationFrame(cardLoop);
                            }
                        };
                        cardLoop();
                    } catch (e) {
                        logChibiAction(`<span class="text-red-400">Error fetching trap card: ${e.message}</span>`);
                        console.error("Failed to fetch trap card for easter egg:", e);
                    }
                };

                



                setTimeout(() => {
                    // Use absolute positioning for the physics simulation
                    console.log('In setTimeout callback, pos is:', pos.x, pos.y);
                    // Remove any conflicting classes first
                    chibi.className = chibi.className.replace('chibi-animated', '').trim();
                    chibi.style.position = 'fixed';
                    chibi.style.top = '0px';
                    chibi.style.left = '0px';
                    chibi.style.zIndex = '1000';
                    chibi.style.transform = `translate(${pos.x}px, ${pos.y}px)`;
                    chibi.style.cursor = 'pointer';
                    chibi.style.willChange = 'transform';
                    chibi.style.transformStyle = 'preserve-3d';
                    chibi.style.backfaceVisibility = 'hidden';
                    console.log('Set transform in setTimeout to:', chibi.style.transform);
                    
                    // Add the class back after setting all styles
                    chibi.classList.add('chibi-animated');

                    // Start the animation loop
                    console.log('Starting animation loop');
                    animationLoop();
                    
                    // Clear the starting flag now that animation is running
                    animationStarting = false;
                    
                    // Start the first hop
                    console.log('Starting first hop');
                    performHop();
                    
                    // Set up dynamic hop timing with variation
                    const scheduleNextHop = () => {
                        const baseDelay = 2500;
                        const variation = (Math.random() - 0.5) * 400; // 200ms variation
                        const delay = Math.max(1000, baseDelay + variation);
                        
                        chibiAnimationState.hopInterval = setTimeout(() => {
                            if (isAnimated && currentState === 'IDLE') {
                                performHop();
                            }
                            // Always reschedule to avoid stalling while mid-animation
                            if (isAnimated) scheduleNextHop();
                        }, delay);
                    };
                    
                    // Expose the function globally for pause/resume
                    window.chibiAnimationFunctions = { startHopping: scheduleNextHop, startPhysics: null };
                    
                    scheduleNextHop();
                }, 500); // Wait for initial transition
            };

            const stopAnimation = async () => {
                isAnimated = false;
                animationStarting = false; // Reset the starting flag
                
                // Hide the easter egg edit button
                document.body.classList.remove('easter-egg-active');
                clearTimeout(chibiAnimationState.hopInterval);
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                chibiAnimationState.hopInterval = null;
                activeDiamonds = []; // NEW: Clear active diamonds on stop
                coinClickCounter = 0; // Reset click counter immediately
                updateCounterDisplay(); // Update display to show 0 clicks
                hyperSpeedCleanup = false; // Reset flag
                cleanupClickListener = () => {
                    cleanupClickCount++;
                    if (cleanupClickCount === 1) {
                        cleanupClickTimer = setTimeout(() => {
                            cleanupClickCount = 0;
                        }, 500); // 500ms window for triple click
                    } else if (cleanupClickCount >= 3) {
                        clearTimeout(cleanupClickTimer);
                        cleanupClickCount = 0;
                        hyperSpeedCleanup = true;
                        logChibiAction('<span class="text-yellow-300">HYPER SPEED CLEANUP ACTIVATED!</span>');
                        // Switch controls: enable clone spawning on click/space
                        activateHyperSpawnControls();
                        const tip = document.createElement('div');
                        tip.style.cssText = 'position:fixed;top:12%;left:50%;transform:translateX(-50%);z-index:2000;background:rgba(0,0,0,.85);color:#fff;padding:10px 14px;border-radius:10px;font-size:14px;border:1px solid rgba(255,255,255,.2)';
                        tip.textContent = 'Click or press Space to call helper chibis!';
                        document.body.appendChild(tip);
                        setTimeout(() => tip.remove(), 1600);
                    }
                };
                document.addEventListener('click', cleanupClickListener);
                
                document.removeEventListener('click', handleClickThrow, true);
                document.removeEventListener('keydown', handleKeyThrow);

                logChibiAction('Stop sequence initiated. Cleaning up...');
                
                // Show tooltip for cleanup mode
                const showTooltip = (message, duration = 3000) => {
                    const tooltip = document.createElement('div');
                    tooltip.style.cssText = `
                        position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                        z-index: 2000; background-color: rgba(0, 0, 0, 0.9);
                        color: white; padding: 16px 24px; border-radius: 12px;
                        font-family: 'Inter', sans-serif; font-size: 16px; font-weight: 500;
                        text-align: center; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
                        border: 2px solid rgba(255, 255, 255, 0.2);
                        animation: tooltip-fade-in 0.3s ease-out, tooltip-fade-out 0.3s ease-in ${duration - 300}ms forwards;
                    `;
                    tooltip.textContent = message;
                    document.body.appendChild(tooltip);
                    
                    setTimeout(() => {
                        if (tooltip.parentNode) {
                            tooltip.remove();
                        }
                    }, duration);
                };

                showTooltip('Triple-click to enter HYPER speed!');
                
                chibi.style.transition = 'transform 0.1s ease-out'; // Fast transition for teleport

                // NEW: Function to get delay based on hyper speed mode
                const getDelay = (normal) => hyperSpeedCleanup ? normal / 10 : normal;
                const getTransitionDuration = (normal) => hyperSpeedCleanup ? normal / 10 : normal;

                if (itemContainer) {
                    const items = Array.from(itemContainer.children);
                    logChibiAction(`Found ${items.length} items to clean up.`);

                    for (const item of items) {
                        if (!item.isConnected || item.dataset.claimed) { continue; }
                        const itemRect = item.getBoundingClientRect();
                        // Teleport to the item's location
                        let targetX = itemRect.left - chibiSize / 4;
                        let targetY = itemRect.top - chibiSize / 4;
                        pos.x = Math.max(0, Math.min(targetX, window.innerWidth - chibiSize)); // MODIFIED: Clamp X position
                        pos.y = Math.max(0, Math.min(targetY, window.innerHeight - chibiSize)); // MODIFIED: Clamp Y position
                        chibi.style.transform = `translate(${pos.x}px, ${pos.y}px)`;

                        // Wait a moment, then "collect" the item
                        await new Promise(resolve => setTimeout(resolve, getDelay(150)));
                        item.style.transition = 'transform 0.2s ease-in, opacity 0.2s ease-in';
                        item.style.transform = 'scale(0)';
                        item.style.opacity = '0';

                        // Wait for the item to disappear before moving to the next one
                        await new Promise(resolve => setTimeout(resolve, getDelay(200)));
                        if (item.parentNode) item.parentNode.removeChild(item);
                        
                        // MODIFIED: Decrement the correct particle counter based on the item's class
                        if (item.classList.contains('chibi-coin')) {
                            coinsOnScreenCounter--;
                        } else if (item.classList.contains('chibi-confetti')) {
                            confettiOnScreenCounter--;
                        } else if (item.classList.contains('chibi-diamond')) {
                            diamondsOnScreenCounter--;
                        }
                        updateCounterDisplay();
                        maybeDespawnClones();
                    }
                    itemContainer.remove();
                    logChibiAction('All items cleaned up.');
                    itemContainer = null;
                }

                // 1. Create and drop the rope
                const rope = document.createElement('div');
                const moveTransitionDuration = getTransitionDuration(1);
                chibi.style.transition = `transform ${moveTransitionDuration}s ease-in-out`;
                rope.style.position = 'fixed';
                rope.style.top = '0';
                rope.style.left = '15px'; // Position rope slightly off the edge
                rope.style.width = '5px';
                rope.style.height = '0';
                rope.style.backgroundColor = '#8B4513'; // SaddleBrown color for rope
                rope.style.zIndex = '999';
                const ropeDropDuration = getTransitionDuration(1);
                rope.style.transition = `height ${ropeDropDuration}s ease-in`;
                document.body.appendChild(rope);

                // Animate rope dropping
                setTimeout(() => {
                    rope.style.height = '100vh';
                }, getDelay(100));
                logChibiAction('Dropped the escape rope.');

                const resetChibi = (ropeElement) => {
                    // NEW: Clean up the cleanup listener
                    if (cleanupClickListener) {
                        document.removeEventListener('click', cleanupClickListener);
                        cleanupClickListener = null;
                    }
                    // NEW: Final cleanup of the counter display
                    if (counterDisplayElement) {
                        counterDisplayElement.remove();
                        counterDisplayElement = null;
                    }
                    // Remove hyper spawn controls and clones
                    deactivateHyperSpawnControls();
                    for (const clone of [...chibiClones]) {
                        if (clone.parentNode) clone.parentNode.removeChild(clone);
                    }
                    chibiClones = [];
                    if (cloneContainer && cloneContainer.parentNode) {
                        cloneContainer.parentNode.removeChild(cloneContainer);
                        cloneContainer = null;
                    }
                    // Remove any stray itemContainer
                    if (itemContainer && itemContainer.parentNode) {
                        itemContainer.remove();
                        itemContainer = null;
                    }
                coinsOnScreenCounter = 0;
                confettiOnScreenCounter = 0;
                diamondsOnScreenCounter = 0;


                    chibi.classList.remove('chibi-animated');
                    chibi.style.position = '';
                    chibi.style.width = '';
                    chibi.style.height = '';
                    chibi.style.top = '';
                    chibi.style.left = '';
                    chibi.style.transform = '';
                    chibi.style.transition = '';
                    ropeElement.remove(); // Clean up the rope

                    chibi.classList.add('chibi-wiggle');
                    setTimeout(() => chibi.classList.remove('chibi-wiggle'), 1000);
                    logChibiAction('Chibi has returned to its post. Animation finished.');
                };

                // 2. After a delay, move chibi to the bottom of the screen
                setTimeout(() => {
                    const bottomY = window.innerHeight - chibiSize;
                    chibi.style.transform = `translate(${pos.x}px, ${bottomY}px)`;
                    pos.y = bottomY;
                    logChibiAction('Moving to the bottom of the screen.');
                }, getDelay(100)); // Start moving down sooner after cleanup

                // 3. After reaching the bottom, walk to the wall (rope)
                setTimeout(() => {
                    const ropeX = 0; // Align with the rope's general area
                    chibi.style.transform = `translate(${ropeX}px, ${pos.y}px)`;
                    logChibiAction('Walking over to the rope.');
                    pos.x = ropeX;
                }, getDelay(100) + (moveTransitionDuration * 1000) + getDelay(100));

                // 4. After reaching the wall, start climbing
                setTimeout(() => {
                    chibi.style.transition = ''; // Switch to manual animation for climbing
                    hyperSpeedCleanup = false; // NEW: Ensure climb speed is normal
                    logChibiAction('Starting the climb!');
                    const climbUp = () => {
                        const climbSpeed = 3; // Adjust climb speed
                        pos.y -= climbSpeed;

                        // Add a slight wobble to the climb
                        pos.x = Math.sin(pos.y * 0.05) * 10;

                        chibi.style.transform = `translate(${pos.x}px, ${pos.y}px)`;

                        if (pos.y > -chibiSize) { // Allow chibi to climb completely off-screen
                            requestAnimationFrame(climbUp);
                        } else {
                            // Animation finished, reset everything
                            resetChibi(rope);
                        }
                    };
                    climbUp();
                }, getDelay(100) + (moveTransitionDuration * 1000) + getDelay(100) + (moveTransitionDuration * 1000) + getDelay(100));
            };

            // Before attaching, remove any previous handler by cloning and replacing the node
            const originalChibi = document.getElementById('chibi-logo');
            const chibiClone = originalChibi.cloneNode(true);
            originalChibi.parentNode.replaceChild(chibiClone, originalChibi);
            chibi = chibiClone;
            chibi.addEventListener('click', () => {
                const now = Date.now();
            // Debounce clicks - ignore if clicked within 80ms
            if (now - lastClickTime < 80) {
                    console.log('Click debounced, ignoring');
                    return;
                }
                lastClickTime = now;
                
                console.log('Chibi clicked! isAnimated:', isAnimated, 'clickCount:', clickCount, 'animationStarting:', animationStarting);
                if (isAnimated) {
                    console.log('Stopping animation');
                    stopAnimation();
                } else {
                    // Additional check to prevent multiple starts
                    if (animationStarting) {
                        console.log('Animation already starting, ignoring click');
                        return;
                    }
                    
                    clickCount++;
                    console.log('Click count incremented to:', clickCount);
                    if (clickCount >= 3) {
                        console.log('3 clicks reached, starting animation');
                        clickCount = 0;
                        startAnimation();
                    }
                }
            });

        }

        // --- GEMINI API INTEGRATION ---
        function parseSimpleMarkdown(text) {
            if (!text) return '';
            return text
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') // Bold
                .replace(/\*(.*?)\*/g, '<em>$1</em>')       // Italics
                .replace(/^### (.*$)/gim, '<h3>$1</h3>')    // H3
                .replace(/^## (.*$)/gim, '<h2>$1</h2>')      // H2
                .replace(/^# (.*$)/gim, '<h1>$1</h1>')        // H1
                .replace(/\n/g, '<br>');                      // Newlines
        }

        let apiKeyPromiseResolver = null;
        function saveApiKeyFromModal() {
            const key = UI.apiKeyInput.value.trim();
            if (key && apiKeyPromiseResolver) {
                geminiApiKey = key;
                apiKeyPromiseResolver(key);
                apiKeyPromiseResolver = null;
                UI.apiKeyModal.classList.add('hidden');
            } else {
                showMessage("Please enter a valid API key.");
            }
        }

        async function callGemini(prompt) {
            if (!geminiApiKey) {
                UI.apiKeyModal.classList.remove('hidden');
                const key = await new Promise(resolve => {
                    apiKeyPromiseResolver = resolve;
                });
                if (!key) {
                    showMessage("API key is required for AI features.");
                    return null;
                }
            }

            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${geminiApiKey}`;
             const payload = { contents: [{ role: "user", parts: [{ text: prompt }] }] };
            
             try {
                 const response = await fetch(apiUrl, {
                     method: 'POST',
                     headers: { 'Content-Type': 'application/json' },
                     body: JSON.stringify(payload)
                 });
                 if (!response.ok) {
                     const errorData = await response.text();
                     throw new Error(`API call failed: ${response.status}. ${errorData}`);
                 }
                 const result = await response.json();
                 if (result.candidates && result.candidates.length > 0 && result.candidates[0].content?.parts?.[0]?.text) {
                     return result.candidates[0].content.parts[0].text;
                 }
                  throw new Error("Invalid response structure from API.");
             } catch (error) {
                 console.error("Gemini API call error:", error);
                 showMessage(`An error occurred while communicating with the AI. Please check the console for details.`);
                 return null;
             }
        }

        function summarizeSimulationData(simulationData, cardDatabase) {
            if (!simulationData || !simulationData.results || !simulationData.baseDeckData) {
                return { notesSummary: "Not enough data to summarize." };
            }
            const { results, baseDeckData } = simulationData; 
            const getCardName = (id) => cardDatabase.find(c => c.id === id)?.name || `Unknown (${id})`;

            const noteKeywords = {};
            const allNotes = results.map(r => r.notes).filter(Boolean).join(' ');

            if (allNotes) {
                const words = allNotes.match(/([a-zA-Z0-9]+(?:-[a-zA-Z0-9]+)*)/g) || [];
                if (!baseDeckData.main) return { notesSummary: "Deck data is missing." }; 
                const deckCardNames = new Set(baseDeckData.main.map(getCardName));
                
                words.forEach(word => {
                    deckCardNames.forEach(cardName => {
                        if (cardName.toLowerCase().includes(word.toLowerCase()) && word.length > 3) {
                             noteKeywords[cardName] = (noteKeywords[cardName] || 0) + 1;
                        }
                    });
                });
            }

            const sortedKeywords = Object.entries(noteKeywords).sort((a, b) => b[1] - a[1]);
            const topKeywords = sortedKeywords.slice(0, 5).map(([card, count]) => `${card} (mentioned ${count} times)`);
            
            let notesSummary = "No specific patterns found in notes.";
            if (topKeywords.length > 0) {
                notesSummary = `Key cards/themes mentioned in notes: ${topKeywords.join(', ')}.`;
            }

            return { notesSummary };
        }

        async function handleAiReportAnalysis() {
            UI.aiReportAnalysisContent.innerHTML = '<p class="text-blue-300"> Preparing data for analysis...</p>';
            
            const { notesSummary } = summarizeSimulationData(lastSimulationSettings, cardDatabase);
            
            UI.aiReportAnalysisContent.innerHTML = '<p class="text-blue-300"> Data prepared. Sending to Gemini AI for analysis... This may take a moment.</p>';

            const reportData = UI.reportContent.innerText;
            const getCardName = (id) => cardDatabase.find(c => c.id === id)?.name || `Unknown (${id})`;
            const deckListString = lastSimulationSettings.baseDeckData.main.map(getCardName).join('\n');
            
            const prompt = `
                You are an expert Yu-Gi-Oh! player and deck building analyst. 
                I have run a simulation. Your task is to provide a deep and insightful summary based on the provided decklist and the summarized results and notes.

                **Decklist Under Test:**
                \`\`\`
                ${deckListString}
                \`\`\`

                **Summarized Simulation Results:**
                ${reportData}

                **Summarized User Notes:**
                ${notesSummary}

                ---

                **Your Task:**
                Based on all the information provided (decklist, summarized results, and summarized notes), please provide a comprehensive analysis. Structure your response with the following clear headings using markdown:

                ### Strategic Summary
                - What appears to be the core gameplan of this deck?
                - Based on the summarized notes, what are the key decision points or combos I was focusing on?

                ### Synergy & Anti-Synergy Analysis
                - What strong synergies do the results and notes highlight? 
                - Did the notes reveal any anti-synergies or awkward interactions between cards?

                ### Decklist Suggestions
                - Based on the analysis, what specific changes could improve the deck?
                - Are there any cards that seem to be underperforming based on both the stats and summarized notes?

                ### Questions for Deeper Understanding
                - Ask me 2-3 insightful questions that will help me think more critically about my deck and its strategy, based on the patterns you observed.
            `;
            
            const analysis = await callGemini(prompt);
            
            if (analysis) {
                 UI.aiReportAnalysisContent.innerHTML = parseSimpleMarkdown(analysis);
            } else {
                 UI.aiReportAnalysisContent.innerHTML = '<p class="text-red-400">Failed to get analysis. Check the console for more details.</p>';
            }
        }

        // --- AI TRAINING MODE LOGIC ---

        async function generateAiEvaluator() {
            UI.aiReportAnalysisContent.innerHTML = '<p class="text-purple-300"> Synthesizing your notes and results into an AI algorithm...</p>';

            const getCardName = (id) => cardDatabase.find(c => c.id === id)?.name || `Unknown (${id})`;
            const deckListString = lastSimulationSettings.baseDeckData.main.map(getCardName).join('\n');
            
            const { notesSummary } = summarizeSimulationData(lastSimulationSettings, cardDatabase);
            const reportData = UI.reportContent.innerText;


            const prompt = `
                Based on the following decklist, simulation results, and user notes summary, create a JSON object representing an "AI Card Evaluation Algorithm". This algorithm should capture the core principles and heuristics the user applied.

                **Decklist:**
                \`\`\`
                ${deckListString}
                \`\`\`

                **Summarized Simulation Results:**
                ${reportData}
                
                **Summarized User Notes:**
                ${notesSummary}

                **Instructions:**
                Analyze the data to infer the user's strategy. Identify key cards, synergistic combos, and general evaluation rules. Your output MUST be a JSON object with the following structure:
                {
                  "name": "AI Evaluator based on ${lastSimulationSettings.baseDeckData.name}",
                  "core_principles": [
                    "A summary of the deck's main goal.",
                    "A summary of the user's evaluation criteria based on their notes."
                  ],
                  "key_cards": {
                    "cardName1": { "priority": "high/medium/low", "reason": "Why this card is important based on notes/results." },
                    "cardName2": { "priority": "high/medium/low", "reason": "..." }
                  },
                  "synergies": [
                    { "cards": ["Card A", "Card B"], "evaluation_bonus": 10, "reason": "Note from Trial X shows these work well." },
                    { "cards": ["Card C", "Card D"], "evaluation_bonus": 15, "reason": "These cards enable the core gameplan." }
                  ],
                  "heuristics": [
                    "General rule inferred from the data (e.g., 'Prefer hands with at least one monster and one spell.')",
                    "Another rule (e.g., 'A hand with Card X is always better than a hand without it.')"
                  ]
                }
                If you do not have enough information to create a meaningful algorithm, return a JSON object with a single key: {"error": "Insufficient data. Please run more detailed simulation trials."}
            `;

            UI.aiReportAnalysisContent.innerHTML = '<p class="text-purple-300"> Sending data to Gemini AI for algorithm creation...</p>';
            const response = await callGemini(prompt);
            
            try {
                // FIX: Clean the response from the AI before parsing it as JSON.
                let cleanedResponse = response.replace(/^```json\s*/, '').replace(/\s*```\s*$/, '');
                const evaluatorJson = JSON.parse(cleanedResponse);
                
                if (evaluatorJson.error) {
                    showMessage(evaluatorJson.error);
                    UI.aiReportAnalysisContent.innerHTML = `<p class="text-red-400">Error: ${evaluatorJson.error}</p>`;
                } else {
                    const blob = new Blob([JSON.stringify(evaluatorJson, null, 2)], { type: 'application/json' });
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = `ai_evaluator_${lastSimulationSettings.baseDeckData.name.replace(/\s/g, '_')}.json`;
                    a.click();
                    URL.revokeObjectURL(a.href);
                    UI.aiReportAnalysisContent.innerHTML = `<p class="text-green-400">AI Evaluator generated and downloaded successfully!</p>`;
                }
            } catch (e) {
                UI.aiReportAnalysisContent.innerHTML = '<p class="text-red-400">Failed to generate a valid AI Evaluator. The response was not valid JSON.</p>';
                console.error("AI Evaluator Generation Error:", e, "Response:", response);
            }
        }

        // --- OFFLINE PROMPT GENERATION FUNCTIONS ---
        
        function generateStandardSimPrompt() {
            const { notesSummary } = summarizeSimulationData(lastSimulationSettings, cardDatabase);
            const reportData = UI.reportContent.innerText;
            const getCardName = (id) => cardDatabase.find(c => c.id === id)?.name || `Unknown (${id})`;
            const deckListString = lastSimulationSettings.baseDeckData.main.map(getCardName).join('\n');
            
            const prompt = `You are an expert Yu-Gi-Oh! player and deck building analyst. 
I have run a simulation. Your task is to provide a deep and insightful summary based on the provided decklist and the summarized results and notes.

**Decklist Under Test:**
\`\`\`
${deckListString}
\`\`\`

**Summarized Simulation Results:**
${reportData}

**Summarized User Notes:**
${notesSummary}

---

**Your Task:**
Based on all the information provided (decklist, summarized results, and summarized notes), please provide a comprehensive analysis. Structure your response with the following clear headings using markdown:

### Strategic Summary
- What appears to be the core gameplan of this deck?
- Based on the summarized notes, what are the key decision points or combos I was focusing on?

### Synergy & Anti-Synergy Analysis
- What strong synergies do the results and notes highlight? 
- Did the notes reveal any anti-synergies or awkward interactions between cards?

### Decklist Suggestions
- Based on the analysis, what specific changes could improve the deck?
- Are there any cards that seem to be underperforming based on both the stats and summarized notes?

### Questions for Deeper Understanding
- Ask me 2-3 insightful questions that will help me think more critically about my deck and its strategy, based on the patterns you observed.`;

            showPromptModal(prompt, 'simulation-analysis-prompt.txt');
        }

        function generateAiEvaluatorPrompt() {
            const getCardName = (id) => cardDatabase.find(c => c.id === id)?.name || `Unknown (${id})`;
            const deckListString = lastSimulationSettings.baseDeckData.main.map(getCardName).join('\n');
            const { notesSummary } = summarizeSimulationData(lastSimulationSettings, cardDatabase);
            const reportData = UI.reportContent.innerText;

            const prompt = `Based on the following decklist, simulation results, and user notes summary, create a JSON object representing an "AI Card Evaluation Algorithm". This algorithm should capture the core principles and heuristics the user applied.

**Decklist:**
\`\`\`
${deckListString}
\`\`\`

**Summarized Simulation Results:**
${reportData}

**Summarized User Notes:**
${notesSummary}

**Instructions:**
Analyze the data to infer the user's strategy. Identify key cards, synergistic combos, and general evaluation rules. Your output MUST be a JSON object with the following structure:
{
  "name": "AI Evaluator based on ${lastSimulationSettings.baseDeckData.name}",
  "core_principles": [
    "A summary of the deck's main goal.",
    "A summary of the user's evaluation criteria based on their notes."
  ],
  "key_cards": {
    "cardName1": { "priority": "high/medium/low", "reason": "Why this card is important based on notes/results." },
    "cardName2": { "priority": "high/medium/low", "reason": "..." }
  },
  "synergies": [
    { "cards": ["Card A", "Card B"], "evaluation_bonus": 10, "reason": "Note from Trial X shows these work well." },
    { "cards": ["Card C", "Card D"], "evaluation_bonus": 15, "reason": "These cards enable the core gameplan." }
  ],
  "heuristics": [
    "General rule inferred from the data (e.g., 'Prefer hands with at least one monster and one spell.')",
    "Another rule (e.g., 'A hand with Card X is always better than a hand without it.')"
  ]
}

If you do not have enough information to create a meaningful algorithm, return a JSON object with a single key: {"error": "Insufficient data. Please run more detailed simulation trials."}`;

            showPromptModal(prompt, 'ai-evaluator-prompt.txt');
        }

        function generateShootoutPrompt() {
            const summaryPrompt = ShootoutManager.state.results.map(r => {
                return `Trial ${r.trial}: User won=${r.winner === 'user'}. Notes: "${r.notes || 'N/A'}"`;
            }).join('\n');
            
            const prompt = `You are a Yu-Gi-Oh! expert. Analyze the following shootout session data between two decks and provide insights.

**User Deck: ${ShootoutManager.state.userDeckData.name}**
**Opponent Deck: ${ShootoutManager.state.opponentDeckData.name}**

**Session Data Summary:**
- Total Trials: ${ShootoutManager.state.results.length}
- User Wins: ${ShootoutManager.state.results.filter(r=>r.winner==='user').length}
- Opponent Wins: ${ShootoutManager.state.results.filter(r=>r.winner==='opponent').length}

**User Trial-by-Trial Notes & Results:**
${summaryPrompt}

Please provide a comprehensive analysis with the following structure using markdown:

### Key Cards
- **Most Valuable Player (MVP):** Identify the single card that appeared to contribute most to wins, based on the notes and hand data.
- **Most Problematic Card:** Identify a card that frequently appeared in losing hands or was mentioned negatively in notes.

### Key Patterns from Notes
- Analyze the user's notes. What recurring themes, combos, or problem cards are mentioned?

### Actionable Suggestions
- Based on the analysis, provide 2-3 specific, actionable suggestions for the user to improve their deck or strategy for this specific matchup.`;

            showPromptModal(prompt, 'shootout-analysis-prompt.txt');
        }

        function showPromptModal(promptText, defaultFilename) {
            UI.promptModalTextarea.value = promptText;
            UI.promptModalTextarea.dataset.filename = defaultFilename;
            UI.promptModal.classList.remove('hidden');
        }

        function copyPromptToClipboard() {
            const promptText = UI.promptModalTextarea.value;
            navigator.clipboard.writeText(promptText).then(() => {
                showMessage('Prompt copied to clipboard! You can now paste it into any AI model.');
                const originalText = UI.copyPromptBtn.innerHTML;
                UI.copyPromptBtn.innerHTML = ' Copied!';
                setTimeout(() => {
                    UI.copyPromptBtn.innerHTML = originalText;
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy:', err);
                showMessage('Failed to copy to clipboard. Please manually select and copy the text.');
            });
        }

        function downloadPrompt() {
            const promptText = UI.promptModalTextarea.value;
            const filename = UI.promptModalTextarea.dataset.filename || 'ai-prompt.txt';
            const blob = new Blob([promptText], { type: 'text/plain;charset=utf-8' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = filename;
            a.click();
            URL.revokeObjectURL(a.href);
            showMessage('Prompt downloaded successfully!');
        }
        
        function populateAiTrainingView() {
            const currentDeckVal = UI.aiTrainingDeckSelector.value;
            UI.aiTrainingDeckSelector.innerHTML = '<option value="">-- Select Deck for AI Training --</option>';
            deckLists.forEach(deck => UI.aiTrainingDeckSelector.add(new Option(deck.name, deck.id)));
            UI.aiTrainingDeckSelector.value = currentDeckVal;
        }

        function handleAiEvaluatorImport(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    aiEvaluator = JSON.parse(e.target.result);
                    showMessage(`Successfully imported AI Evaluator: ${aiEvaluator.name}`);
                } catch (err) {
                    showMessage("Invalid AI Evaluator file. Please ensure it is a valid JSON file.");
                    aiEvaluator = null;
                }
            };
            reader.readAsText(file);
            event.target.value = null; // Reset input
        }

        async function startAiTrainingSimulation() {
            const deckId = UI.aiTrainingDeckSelector.value;
            if (!deckId) { showMessage("Please select a deck to run the AI training on."); return; }
            if (!aiEvaluator) { showMessage("Please import an AI Evaluator file first."); return; }

            const deckData = deckLists.find(d => d.id === deckId);
            const trials = parseInt(UI.aiTrainingTrialsInput.value);
            const userInstructions = UI.aiTrainingInstructions.value.trim();

            UI.loadingOverlay.classList.remove('hidden');
            showMessage("AI is conducting the simulation... This may take some time.");
            
            const trialHands = [];
            for (let i = 0; i < trials; i++) {
                const shuffledA = shuffleArray([...deckData.main]);
                const shuffledB = shuffleArray([...deckData.main]);
                trialHands.push({
                    trial: i + 1,
                    handA: shuffledA.slice(0, 5),
                    handB: shuffledB.slice(0, 5)
                });
            }

            const getCardName = (id) => cardDatabase.find(c => c.id === id)?.name || `Unknown (${id})`;
            const trialHandsAsText = trialHands.map(t => 
                `Trial ${t.trial}: Hand A = [${t.handA.map(getCardName).join(', ')}], Hand B = [${t.handB.map(getCardName).join(', ')}]`
            ).join('\n');

            const prompt = `
                You are a Card Evaluation AI. Your task is to evaluate pairs of hands based on a provided algorithm and user instructions.

                **Your Algorithm (Your Core Programming):**
                \`\`\`json
                ${JSON.stringify(aiEvaluator, null, 2)}
                \`\`\`

                **User's High-Level Goal for this Session:**
                "${userInstructions || 'No specific goal provided. Use your core algorithm.'}"

                **Trials to Evaluate:**
                ${trialHandsAsText}

                **Instructions:**
                For each trial, compare Hand A and Hand B. Use your core algorithm and the user's high-level goal to decide a winner ('A', 'B', or 'TIE'). Provide a brief note explaining your reasoning based on your algorithm (e.g., "Hand A has more key cards like Card X and sets up the combo defined in synergy #1."). Your output MUST be a valid JSON array of objects, one for each trial, with this structure:
                [
                  { "trial": 1, "choice": "A", "notes": "Reasoning..." },
                  { "trial": 2, "choice": "B", "notes": "Reasoning..." }
                ]
            `;

            const response = await callGemini(prompt);
            UI.loadingOverlay.classList.add('hidden');

            try {
                const results = JSON.parse(response);
                displayAiTrainingResults(trialHands, results);
            } catch (e) {
                showMessage("The AI returned invalid data. Could not display results.");
                console.error("AI Training Error:", e, "Response:", response);
            }
        }

        function displayAiTrainingResults(trialHands, results) {
            UI.aiTrainingResultsView.innerHTML = '<h2 class="text-2xl font-bold mb-4 text-white">AI Training Results</h2>';
            
            for (const result of results) {
                const trialData = trialHands.find(t => t.trial === result.trial);
                if (!trialData) continue;

                const trialEl = document.createElement('div');
                trialEl.className = 'bg-slate-800 p-4 rounded-lg mb-4';
                
                let winnerText;
                if(result.choice === 'A') winnerText = `<span class="font-bold text-green-400">Hand A Wins</span>`;
                else if (result.choice === 'B') winnerText = `<span class="font-bold text-green-400">Hand B Wins</span>`;
                else winnerText = `<span class="font-bold text-yellow-400">Tie</span>`;

                const getCardImg = (id) => {
                    const card = cardDatabase.find(c => c.id === id);
                    return `<img src="${card?.imageUrl || ''}" class="w-16 rounded-md" title="${card?.name || 'Unknown'}" onerror="this.onerror=null;this.src='https://placehold.co/64x93/2d3748/e2e8f0?text=?';">`;
                };

                trialEl.innerHTML = `
                    <h3 class="text-lg font-semibold mb-2">Trial #${result.trial} - ${winnerText}</h3>
                    <div class="grid grid-cols-2 gap-4 mb-2">
                        <div>
                            <p class="font-semibold">Hand A:</p>
                            <div class="flex flex-wrap gap-1">${trialData.handA.map(getCardImg).join('')}</div>
                        </div>
                        <div>
                            <p class="font-semibold">Hand B:</p>
                             <div class="flex flex-wrap gap-1">${trialData.handB.map(getCardImg).join('')}</div>
                        </div>
                    </div>
                    <p class="text-sm text-slate-300"><strong class="text-slate-400">AI Notes:</strong> ${result.notes}</p>
                `;
                UI.aiTrainingResultsView.appendChild(trialEl);
            }
            showView('aiTrainingView');
            UI.aiTrainingResultsView.classList.remove('hidden');
        }

        // --- PDF MANAGER ---
        const PDFManager = {
            _proxyAndBase64Images: async function(container) {
                const images = Array.from(container.getElementsByTagName('img'));
                const corsProxy = 'https://corsproxy.io/?';

                const promises = images.map(async (img) => {
                    const originalSrc = img.src;
                    // Skip already-processed or placeholder images
                    if (!originalSrc || originalSrc.startsWith('data:') || !originalSrc.startsWith('http')) {
                        return;
                    }

                    try {
                        const response = await fetch(corsProxy + encodeURIComponent(originalSrc));
                        if (!response.ok) throw new Error(`Failed to fetch image: ${response.statusText}`);
                        const blob = await response.blob();
                        const reader = new FileReader();
                        await new Promise((resolve, reject) => {
                            reader.onloadend = () => resolve(reader.result);
                            reader.onerror = reject;
                            reader.readAsDataURL(blob);
                        });
                        img.src = reader.result;
                    } catch (error) {
                        console.warn(`Could not proxy/load image: ${originalSrc}`, error);
                        // Let the onerror attribute in the HTML handle the visual fallback
                    }
                });

                await Promise.all(promises);
            },

            generateFromHTML: async function(element, fileName) {
                UI.loadingOverlay.classList.remove('hidden');
                showMessage(`Generating ${fileName}... This may take a moment.`);
                
                try {
                    await this._proxyAndBase64Images(element);

                    const { jsPDF } = window.jspdf;
                    const canvas = await html2canvas(element, { scale: 2, useCORS: true });
                    const imgData = canvas.toDataURL('image/png');
                    
                    const pdf = new jsPDF({
                        orientation: 'p',
                        unit: 'px',
                        format: 'a4'
                    });

                    const pdfWidth = pdf.internal.pageSize.getWidth();
                    const pdfHeight = pdf.internal.pageSize.getHeight();
                    const canvasWidth = canvas.width;
                    const canvasHeight = canvas.height;
                    const canvasAspectRatio = canvasWidth / canvasHeight;
                    const pdfAspectRatio = pdfWidth / pdfHeight;

                    let renderWidth = pdfWidth;
                    let renderHeight = pdfWidth / canvasAspectRatio;

                    if (renderHeight > pdfHeight) {
                        renderHeight = pdfHeight;
                        renderWidth = pdfHeight * canvasAspectRatio;
                    }

                    let y = 0;
                    let heightLeft = canvasHeight;
                    
                    while (heightLeft > 0) {
                        pdf.addImage(imgData, 'PNG', 0, y, renderWidth, renderHeight);
                        heightLeft -= canvasHeight;
                        if (heightLeft > 0) {
                            pdf.addPage();
                            y = -renderHeight * (pdf.internal.getNumberOfPages() - 1);
                        }
                    }

                    pdf.save(fileName);
                } catch (error) {
                    console.error("PDF Generation Error:", error);
                    showMessage("Failed to generate PDF. Check console for details.");
                } finally {
                    // Don't clean up the element, as the user might want to re-download without regenerating
                    UI.loadingOverlay.classList.add('hidden');
                }
            }
        };

        // --- SHOOTOUT MANAGER ---
        const ShootoutManager = {
            state: {},
            opponent: { main: [], side: [], name: 'Opponent Deck' }, // MODIFIED
            cardCache: [], // MODIFIED
            sidingState: {
                user: { out: [], in: [] },
                opponent: { out: [], in: [] }
            },
            trialHistory: [], // NEW: For undo functionality

            getCardFromCache: function(id) {
                return this.cardCache.find(c => String(c.id) === String(id));
            },

            populateSetup: function() {
                const currentDeckVal = UI.shootoutUserDeckSelector.value;
                UI.shootoutUserDeckSelector.innerHTML = ''; // Clear it
                if (isOffline) {
                    UI.shootoutUserDeckSelector.innerHTML = '<option value="offline-deck" selected>Using Deck from Deckbuilder</option>';
                    UI.shootoutUserDeckSelector.disabled = true;
                } else {
                    UI.shootoutUserDeckSelector.innerHTML = '<option value="">-- Select Your Deck --</option>';
                    deckLists.forEach(deck => UI.shootoutUserDeckSelector.add(new Option(deck.name, deck.id)));
                    UI.shootoutUserDeckSelector.value = currentDeckVal;
                    UI.shootoutUserDeckSelector.disabled = false;
                }
                // Reset opponent deck state on setup
                this.opponent = { main: [], side: [], name: 'Opponent Deck' };
                UI.shootoutOpponentDeckInput.value = '';
                UI.shootoutOpponentDeckName.textContent = 'No opponent deck loaded.';
                UI.shootoutOpponentDeckName.classList.add('text-red-400');
            },

            handleOpponentDeckYdk: async function(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                UI.loadingOverlay.classList.remove('hidden'); // MODIFIED
                showMessage('Parsing opponent deck...');
                
                const reader = new FileReader();
                reader.onload = async (e) => {
                    const content = e.target.result;
                    const lines = content.split('\n').map(l => l.trim()).filter(Boolean);
                    let currentSection = '';
                    const importedDeck = { main: [], side: [] };

                    for(const line of lines) {
                        if (line === '#main') { currentSection = 'main'; continue; }
                        if (line === '!side') { currentSection = 'side'; continue; }
                        if (line === '#extra') { currentSection = 'extra'; continue; } // ignore extra deck
                        if ((currentSection === 'main' || currentSection === 'side') && !isNaN(parseInt(line))) {
                            importedDeck[currentSection].push(line);
                        }
                    }
                    
                    this.opponent.main = importedDeck.main;
                    this.opponent.side = importedDeck.side;
                    this.opponent.name = file.name.replace('.ydk', '');
                    
                    UI.shootoutOpponentDeckName.textContent = `${this.opponent.name} (Main: ${this.opponent.main.length}, Side: ${this.opponent.side.length})`;
                    UI.shootoutOpponentDeckName.classList.remove('text-red-400');
                    UI.shootoutOpponentDeckName.classList.add('text-green-400');
                    showMessage(`Opponent deck "${this.opponent.name}" loaded. Ready to start.`); // MODIFIED
                    UI.loadingOverlay.classList.add('hidden');
                };
                reader.readAsText(file);
            },

            start: async function() {
                const userDeckId = isOffline ? 'offline-deck' : UI.shootoutUserDeckSelector.value;
                const shootoutMode = document.querySelector('input[name="shootout-mode"]:checked').value;
                const trials = parseInt(UI.shootoutTrialsInput.value);

                if (!userDeckId) { showMessage("Please select your deck."); return; }
                if (this.opponent.main.length === 0) { showMessage("Please load an opponent's deck."); return; }
                if (!shootoutMode) { showMessage("Please select a shootout mode."); return; }
                if (!trials || trials < 1) { showMessage("Please enter a valid number of trials."); return; }
                
                UI.loadingOverlay.classList.remove('hidden');
                
                let userDeckData;
                if (isOffline) {
                    userDeckData = { name: UI.deckNameInput.value || 'Imported Deck', main: currentDeck.main, side: currentDeck.side, extra: currentDeck.extra || [] };
                } else {
                    userDeckData = deckLists.find(d => d.id === userDeckId);
                }
                
                this.state = {
                    userDeckData,
                    opponentDeckData: this.opponent,
                    mode: shootoutMode,
                    totalTrials: trials,
                    currentTrial: 0, // MODIFIED
                    results: [],
                    trialHistory: [], // Reset history
                };

                // Centralized card cache creation
                this.cardCache = [...cardDatabase];
                const allOpponentIds = [...new Set([...this.opponent.main, ...this.opponent.side])];
                const missingCardIds = allOpponentIds.filter(id => !this.cardCache.some(c => c.id === id));
                
                if (missingCardIds.length > 0) {
                    showMessage(`Fetching data for ${missingCardIds.length} new opponent card(s)...`);
                    for (const id of missingCardIds) {
                        try {
                            const response = await fetch(`https://db.ygoprodeck.com/api/v7/cardinfo.php?id=${id}`);
                            const data = await response.json();
                            if (data.data && data.data[0]) {
                                const cardData = data.data[0];
                                this.cardCache.push({
                                    id: cardData.id.toString(),
                                    name: cardData.name,
                                    type: cardData.type,
                                    imageUrl: cardData.card_images[0].image_url
                                });
                            } else {
                                 if (!this.cardCache.some(c => String(c.id) === String(id))) { // MODIFIED
                                    this.cardCache.push({ id, name: `Unknown ID: ${id}`, imageUrl: `https://placehold.co/100x140/2d3748/e2e8f0?text=${id}` });
                                 }
                            }
                        } catch (e) {
                            console.warn(`Could not fetch opponent card ID ${id}`, e);
                             if (!this.cardCache.some(c => String(c.id) === String(id))) { // MODIFIED
                                 this.cardCache.push({ id, name: `Unknown ID: ${id}`, imageUrl: `https://placehold.co/100x140/2d3748/e2e8f0?text=${id}` });
                             }
                        }
                    }
                }
                
                UI.loadingOverlay.classList.add('hidden');

                if (shootoutMode.includes('post-side')) {
                    this.renderSiding();
                    showView('shootoutSidingView');
                } else {
                    this.state.userDeckFinal = [...userDeckData.main];
                    this.state.opponentDeckFinal = [...this.opponent.main];
                    this.startEvaluationPhase();
                }
            },

            renderSiding: function() {
                UI.shootoutSidingViewTitle.textContent = `Siding for: ${this.state.mode}`;
                this.sidingState = { user: { out: [], in: [] }, opponent: { out: [], in: [] } }; // Reset state

                const createSidingCard = (cardId, player, part) => {
                    const sourceDeck = (part === 'main') ? this.state[player + 'DeckData'].main : this.state[player + 'DeckData'].side;
                    const count = sourceDeck.filter(id => id === cardId).length;
                    const card = this.getCardFromCache(cardId);

                    const el = document.createElement('div');
                    el.className = "relative aspect-[2.5/3.5] rounded-md overflow-hidden shadow-lg cursor-pointer transition-all duration-150";
                    el.dataset.id = cardId;
                    el.dataset.player = player;
                    el.dataset.part = part;
                    el.dataset.count = count; // Store total count
                    el.innerHTML = `
                        <img src="${card?.imageUrl}" class="w-full h-full object-cover" title="${card?.name}" onerror="this.onerror=null;this.src='https://placehold.co/100x140/2d3748/e2e8f0?text=?';">
                        <div class="absolute top-1 right-1 w-5 h-5 bg-slate-900/80 text-white text-xs font-bold rounded-full flex items-center justify-center pointer-events-none">x${count}</div>
                        <div class="siding-overlay absolute inset-0 bg-black/70 opacity-0 flex items-center justify-center font-bold text-4xl text-amber-300 pointer-events-none transition-opacity"></div>
                    `;
                    
                    el.addEventListener('click', () => this.handleSidingClick(el));
                    el.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        const destination = (part === 'main') ? 'out' : 'in';
                        this.sidingState[player][destination] = this.sidingState[player][destination].filter(id => id !== cardId); // Remove all instances
                        this.updateSidingVisuals();
                    });

                    return el;
                };

                const populateGrid = (gridEl, deck, player, part) => {
                    gridEl.innerHTML = '';
                    const cardCounts = deck.reduce((acc, id) => { acc[id] = (acc[id] || 0) + 1; return acc; }, {});
                    // Use the deck's order of unique cards to maintain some consistency
                    [...new Set(deck)].forEach(cardId => {
                        gridEl.appendChild(createSidingCard(cardId, player, part));
                    });
                };

                populateGrid(UI.shootoutSidingUserMain, this.state.userDeckData.main, 'user', 'main');
                populateGrid(UI.shootoutSidingUserSide, this.state.userDeckData.side, 'user', 'side');
                populateGrid(UI.shootoutSidingOpponentMain, this.state.opponentDeckData.main, 'opponent', 'main');
                populateGrid(UI.shootoutSidingOpponentSide, this.state.opponentDeckData.side, 'opponent', 'side');
                
                this.updateSidingVisuals();
            },

            handleSidingClick: function(cardElement) {
                const { id: cardId, player, part, count: totalAvailableStr } = cardElement.dataset;
                const totalAvailable = parseInt(totalAvailableStr, 10);
                const state = this.sidingState[player];
                const destination = (part === 'main') ? 'out' : 'in';
                
                let currentlySelected = state[destination].filter(id => id === cardId).length;

                if (currentlySelected < totalAvailable) {
                    state[destination].push(cardId);
                } else {
                    // Reset to 0 by removing all instances
                    this.sidingState[player][destination] = state[destination].filter(id => id !== cardId);
                }
                this.updateSidingVisuals();
            },

            updateSidingVisuals: function() {
                ['user', 'opponent'].forEach(player => {
                    const state = this.sidingState[player];
                    const infoEl = UI[`shootoutSiding${player.charAt(0).toUpperCase() + player.slice(1)}Info`];
                    infoEl.textContent = `Siding Out: ${state.out.length} | Siding In: ${state.in.length}`;
                    infoEl.classList.remove('text-green-400', 'text-amber-400', 'text-red-400');
                    if (state.out.length === state.in.length) {
                        infoEl.classList.add(state.out.length > 0 ? 'text-green-400' : 'text-amber-400');
                    } else {
                        infoEl.classList.add('text-red-400');
                    }

                    ['main', 'side'].forEach(part => {
                        const destination = (part === 'main') ? 'out' : 'in';
                        const grid = UI[`shootoutSiding${player.charAt(0).toUpperCase() + player.slice(1)}${part.charAt(0).toUpperCase() + part.slice(1)}`]; // e.g., UI.shootoutSidingUserMain
                        
                        const selectionTally = state[destination].reduce((acc, id) => { acc[id] = (acc[id] || 0) + 1; return acc; }, {});

                        if (grid) {
                            grid.querySelectorAll('[data-id]').forEach(cardElement => {
                                const cardId = cardElement.dataset.id;
                                const selectedCount = selectionTally[cardId] || 0;
                                const overlay = cardElement.querySelector('.siding-overlay');
                                
                                overlay.textContent = selectedCount > 0 ? selectedCount : '';
                                overlay.classList.toggle('opacity-0', selectedCount === 0);
                                cardElement.classList.toggle('ring-2', selectedCount > 0);
                                cardElement.classList.toggle('ring-amber-400', selectedCount > 0);
                            });
                        }
                    });
                });
            },

            finalizeSiding: function() {
                const userSiding = this.sidingState.user;
                const oppSiding = this.sidingState.opponent;

                if (userSiding.out.length !== userSiding.in.length) {
                    showMessage("Your siding is uneven. The number of cards sided in and out must be equal.");
                    return;
                }
                if (oppSiding.out.length !== oppSiding.in.length) {
                    showMessage("The opponent's siding is uneven. The number of cards sided in and out must be equal.");
                    return;
                }

                const applySiding = (mainDeck, sidingActions) => {
                    let newMain = [...mainDeck];
                    let cardsToSideOut = [...sidingActions.out];

                    newMain = newMain.filter(cardId => {
                        const index = cardsToSideOut.indexOf(cardId);
                        if (index > -1) {
                            cardsToSideOut.splice(index, 1);
                            return false;
                        }
                        return true;
                    });
                    
                    newMain.push(...sidingActions.in);
                    return newMain;
                };
                
                this.state.userDeckFinal = applySiding(this.state.userDeckData.main, userSiding);
                this.state.opponentDeckFinal = applySiding(this.state.opponentDeckData.main, oppSiding);

                showMessage("Siding complete! Starting simulator.");
                this.startEvaluationPhase();
            },

            startEvaluationPhase: function() {
                showView('shootoutSimulatorView');
                this.nextTrial();
            },

            nextTrial: function() {
                // Save current state to history before proceeding
                if (this.state.currentTrial > 0) {
                    this.trialHistory.push({
                        userHand: [...this.state.currentUserHand],
                        opponentHand: [...this.state.currentOpponentHand],
                        userDeck: [...this.state.currentUserDeck],
                        opponentDeck: [...this.state.currentOpponentDeck],
                    });
                }
                if (this.state.currentTrial >= this.state.totalTrials) {
                    this.end();
                    return;
                }
                this.state.currentTrial++;
                
                this.state.currentUserDeck = shuffleArray([...this.state.userDeckFinal]);
                this.state.currentOpponentDeck = shuffleArray([...this.state.opponentDeckFinal]);
                
                this.state.currentUserHand = this.state.currentUserDeck.splice(0, 5);
                this.state.currentOpponentHand = this.state.currentOpponentDeck.splice(0, 5);
                
                this.renderTrial();
            },

            renderTrial: function() {
                const cardMapper = (cardId, player) => {
                     const card = this.getCardFromCache(cardId);
                     const el = document.createElement('div');
                     el.className = "relative";
                     el.dataset.id = cardId;

                    el.draggable = true;
                    el.classList.add('cursor-grab');
                    el.addEventListener('dragstart', (e) => {
                        e.dataTransfer.setData('text/plain', cardId);
                        e.dataTransfer.setData('text/player', player);
                        e.dataTransfer.effectAllowed = 'move';
                    });

                     el.innerHTML = `
                        <img src="${card?.imageUrl}" class="w-full rounded-lg shadow-lg" title="${card?.name}" onerror="this.onerror=null;this.src='https://placehold.co/120x175/2d3748/e2e8f0?text=?';">
                     `;

                     return el;
                };

                UI.shootoutSimUserHand.innerHTML = '';
                this.state.currentUserHand.forEach(id => UI.shootoutSimUserHand.appendChild(cardMapper(id, 'user')));
                
                UI.shootoutSimOpponentHand.innerHTML = '';
                this.state.currentOpponentHand.forEach(id => UI.shootoutSimOpponentHand.appendChild(cardMapper(id, 'opponent')));
                
                UI.shootoutSimUserDeckCount.textContent = `Deck: ${this.state.currentUserDeck.length}`;
                UI.shootoutSimOpponentDeckCount.textContent = `Deck: ${this.state.currentOpponentDeck.length}`;
                UI.shootoutNotes.value = '';

                const scenarioText = this.state.mode.includes('first') ? 'Going First' : 'Going Second';
                const scenarioEl = UI.shootoutSimScenarioIndicator;
                scenarioEl.textContent = scenarioText;
                scenarioEl.classList.remove('hidden');

                // Populate deck views
                const simpleCardMapper = (id) => {
                     const card = this.getCardFromCache(id);
                     if (!card) return `<div class="w-full aspect-[2.5/3.5] rounded-lg shadow-lg bg-slate-700 flex items-center justify-center text-xs text-center p-1">Unknown ID: ${id}</div>`;
                     return `<img src="${card.imageUrl}" class="w-full rounded-lg shadow-lg" title="${card.name}" onerror="this.onerror=null;this.src='https://placehold.co/120x175/2d3748/e2e8f0?text=?';">`;
                }
                document.getElementById('userFullDeck').innerHTML = this.state.currentUserDeck.map(simpleCardMapper).join('');
                document.getElementById('opponentFullDeck').innerHTML = this.state.currentOpponentDeck.map(simpleCardMapper).join('');
            },

            moveCard: function(cardId, player, action) {
                const hand = player === 'user' ? this.state.currentUserHand : this.state.currentOpponentHand;
                const deck = player === 'user' ? this.state.currentUserDeck : this.state.currentOpponentDeck;

                const handIndex = hand.findIndex(id => id === cardId);
                if (handIndex === -1) return;

                hand.splice(handIndex, 1);

                if (action === 'top') deck.unshift(cardId);
                else if (action === 'bottom') deck.push(cardId);
                else if (action === 'shuffle') {
                    deck.push(cardId);
                    if (player === 'user') this.state.currentUserDeck = shuffleArray(deck);
                    else this.state.currentOpponentDeck = shuffleArray(deck);
                }

                this.renderTrial();
            },

            drawCard: function(player = 'user') {
                const deck = player === 'user' ? this.state.currentUserDeck : this.state.currentOpponentDeck;
                const hand = player === 'user' ? this.state.currentUserHand : this.state.currentOpponentHand;

                if (deck.length > 0) {
                    const drawnCard = deck.shift();
                    hand.push(drawnCard);
                    this.renderTrial();
                } else {
                    showMessage(`No cards left in ${player}'s deck to draw.`);
                }
            },

            openSearchDeckModal: function(player = 'user') {
                UI.searchDeckModalList.innerHTML = '';
                const deck = player === 'user' ? this.state.currentUserDeck : this.state.currentOpponentDeck;

                // Change modal title based on player
                const modalTitle = document.querySelector('#searchDeckModal h3');
                if (modalTitle) {
                    modalTitle.textContent = player === 'user' ? 'Search Your Deck' : "Search Opponent's Deck";
                }

                if (deck.length === 0) {
                    UI.searchDeckModalList.innerHTML = `<p class="text-slate-400 text-center">Deck is empty.</p>`; // MODIFIED
                } else {
                    const sortedDeck = [...new Set(deck)].map(id => this.getCardFromCache(id)).filter(Boolean).sort((a, b) => a.name.localeCompare(b.name));
                    sortedDeck.forEach(card => {
                        const cardEl = document.createElement('div');
                        cardEl.className = 'p-2 flex items-center justify-between bg-slate-700/50 rounded-lg cursor-pointer hover:bg-blue-600/50';
                        cardEl.innerHTML = `
                            <div class="flex items-center gap-3 overflow-hidden">
                                <img src="${card.imageUrl}" class="w-10 h-auto rounded-md flex-shrink-0" onerror="this.onerror=null;this.src='https://placehold.co/40x58/2d3748/e2e8f0?text=?';">
                                <span class="text-sm font-medium">${card.name}</span>
                            </div>
                        `;
                        cardEl.addEventListener('click', () => this.selectCardFromSearch(card.id, player));
                        UI.searchDeckModalList.appendChild(cardEl);
                    });
                }
                UI.searchDeckModal.classList.remove('hidden');
            },

            selectCardFromSearch: function(cardId, player) {
                const deck = player === 'user' ? this.state.currentUserDeck : this.state.currentOpponentDeck;
                const hand = player === 'user' ? this.state.currentUserHand : this.state.currentOpponentHand;

                const deckIndex = deck.indexOf(cardId);
                if (deckIndex > -1) {
                    deck.splice(deckIndex, 1);
                    if (player === 'user') this.state.currentUserDeck = shuffleArray(deck);
                    else this.state.currentOpponentDeck = shuffleArray(deck);
                    hand.push(cardId);
                    UI.searchDeckModal.classList.add('hidden');
                    this.renderTrial();
                }
            },

            handleJudgment: function(winner) {
                const notes = UI.shootoutNotes.value.trim();
                this.state.results.push({
                    trial: this.state.currentTrial,
                    userHand: [...this.state.currentUserHand],
                    opponentHand: [...this.state.currentOpponentHand],
                    winner,
                    notes
                });
                this.nextTrial();
            },

            undo: function() {
                if (this.state.results.length === 0) {
                    showMessage("No judgment to undo.");
                    return;
                }
                this.state.results.pop();
                const lastState = this.trialHistory.pop();
                if (lastState) {
                    this.state.currentTrial--;
                    this.state.currentUserHand = lastState.userHand;
                    this.state.currentOpponentHand = lastState.opponentHand;
                    this.state.currentUserDeck = lastState.userDeck;
                    this.state.currentOpponentDeck = lastState.opponentDeck;
                    this.renderTrial();
                }
            },

            end: function() {
                showMessage("Shootout complete!");
                showView('shootoutReportView');
                const userWins = this.state.results.filter(r => r.winner === 'user').length;
                const opponentWins = this.state.results.filter(r => r.winner === 'opponent').length;
                const ties = this.state.results.filter(r => r.winner === 'tie').length;
                UI.shootoutReportContent.innerHTML = `<h2 class="text-2xl font-bold mb-4 text-white">Shootout Report</h2>
                    <p><strong>Total Trials:</strong> ${this.state.results.length}</p>
                    <p class="text-green-400"><strong>User Wins:</strong> ${userWins}</p>
                    <p class="text-red-400"><strong>Opponent Wins:</strong> ${opponentWins}</p>
                    <p class="text-yellow-400"><strong>Ties:</strong> ${ties}</p>
                    <p class="mt-4">Select an option below to analyze the data.</p>`;
                
                // Show appropriate AI button based on API key availability
                if (geminiApiKey) {
                    UI.shootoutReportAiBtn.classList.remove('hidden');
                    UI.shootoutGeneratePromptBtn.classList.add('hidden');
                } else {
                    UI.shootoutReportAiBtn.classList.add('hidden');
                    UI.shootoutGeneratePromptBtn.classList.remove('hidden');
                }
            },

            showContinueForm: function() {
                document.getElementById('shootoutReportContinueBtn').classList.add('hidden');
                document.getElementById('continueShootoutForm').classList.remove('hidden');
            },

            continue: function(confirmed = false) {
                if (confirmed) {
                    const additionalTrialsInput = document.getElementById('additionalTrialsInput');
                    const additionalTrials = parseInt(additionalTrialsInput.value, 10);
                    if (additionalTrials && additionalTrials > 0) {
                        this.state.totalTrials += additionalTrials;
                        showView('shootoutSimulatorView');
                        this.nextTrial();
                        document.getElementById('shootoutReportContinueBtn').classList.remove('hidden');
                        document.getElementById('continueShootoutForm').classList.add('hidden');
                    }
                } else {
                    this.showContinueForm();
                }
            },

            _openPreviewModal: function(htmlContent, fileName) {
                const previewContent = document.getElementById('reportPreviewContent');
                previewContent.innerHTML = htmlContent;
                document.getElementById('reportPreviewTitle').textContent = fileName;

                // Update the download button to generate the correct file
                const downloadBtn = document.getElementById('reportPreviewDownload');
                downloadBtn.onclick = () => {
                    PDFManager.generateFromHTML(previewContent, fileName);
                };

                UI.reportPreviewModal.classList.remove('hidden');
                showMessage("Report preview generated. You can now download it as a PDF.");
            },

            handleAnalysisPDF: async function() {
                const cardStats = {};
                this.state.results.forEach(result => {
                    [...new Set(result.userHand)].forEach(cardId => {
                        if (!cardStats[cardId]) {
                            const cardData = this.getCardFromCache(cardId);
                            cardStats[cardId] = { name: cardData?.name || `ID: ${cardId}`, imageUrl: cardData?.imageUrl, wins: 0, losses: 0, total: 0 };
                        }
                        cardStats[cardId].total++;
                        if (result.winner === 'user') cardStats[cardId].wins++;
                        else cardStats[cardId].losses++;
                    });
                });

                const totalWins = this.state.results.filter(r => r.winner === 'user').length;
                const overallWinRate = this.state.results.length > 0 ? (totalWins / this.state.results.length) : 0;

                const allStats = Object.values(cardStats).map(s => ({...s, winRate: s.total > 0 ? s.wins / s.total : 0 }));
                const topPerformers = allStats.filter(s => s.winRate > overallWinRate + 0.05).sort((a, b) => b.winRate - a.winRate || b.wins - a.wins);
                const underPerformers = allStats.filter(s => s.winRate < overallWinRate - 0.05).sort((a, b) => a.winRate - b.winRate || b.losses - a.losses);
                const neutralPerformers = allStats.filter(s => !topPerformers.includes(s) && !underPerformers.includes(s)).sort((a, b) => b.total - a.total);

                const createCardStatHTML = (stat) => {
                    const winRatePercent = (stat.winRate * 100).toFixed(0);
                    return `
                        <div style="display: flex; align-items: center; gap: 16px; padding: 12px; border-bottom: 1px solid #eee; page-break-inside: avoid;">
                            <img src="${stat.imageUrl}" style="width: 80px; height: auto; border-radius: 4px;" onerror="this.style.display='none'"/>
                            <div style="flex-grow: 1;">
                                <p style="font-weight: bold; font-size: 14px; margin: 0 0 8px 0;">${stat.name}</p>
                                <div style="background-color: #e2e8f0; border-radius: 4px; overflow: hidden; margin-bottom: 4px;">
                                    <div style="width: ${winRatePercent}%; background-color: #48bb78; color: white; text-align: center; font-size: 12px; padding: 2px 0;">${winRatePercent}%</div>
                                </div>
                                <p style="font-size: 12px; color: #555; margin: 0;">Seen in <strong>${stat.total}</strong> hands (${stat.wins}W / ${stat.losses}L)</p>
                            </div>
                        </div>
                    `;
                };

                let htmlContent = `
                    <h1 style="font-size: 24px; font-weight: bold; margin-bottom: 8px; text-align: center;">Shootout Hand Analysis</h1>
                    <p style="text-align: center; font-size: 14px; color: #555; margin-bottom: 16px;">
                        ${this.state.userDeckData.name} vs ${this.state.opponentDeckData.name} | <strong>Overall Win Rate: ${ (overallWinRate * 100).toFixed(1) }%</strong> (${totalWins}W / ${this.state.results.length - totalWins}L)
                    </p>
                `;

                if (topPerformers.length > 0) {
                    htmlContent += `<h2 style="font-size: 18px; font-weight: bold; margin: 24px 0 12px 0; padding-bottom: 4px; border-bottom: 2px solid #48bb78;">Top Performers</h2>`;
                    htmlContent += topPerformers.map(createCardStatHTML).join('');
                }
                if (underPerformers.length > 0) {
                    htmlContent += `<h2 style="font-size: 18px; font-weight: bold; margin: 24px 0 12px 0; padding-bottom: 4px; border-bottom: 2px solid #f56565;">Underperformers</h2>`;
                    htmlContent += underPerformers.map(createCardStatHTML).join('');
                }
                if (neutralPerformers.length > 0) {
                    htmlContent += `<h2 style="font-size: 18px; font-weight: bold; margin: 24px 0 12px 0; padding-bottom: 4px; border-bottom: 2px solid #a0aec0;">Other Cards</h2>`;
                    htmlContent += neutralPerformers.map(createCardStatHTML).join('');
                }

                this._openPreviewModal(htmlContent, 'shootout-hand-analysis.pdf');
            },

            handleExportPDF: async function() {
                let htmlContent = `
                    <style>
                        .trial { page-break-inside: avoid; padding: 12px; margin-bottom: 16px; border-radius: 8px; }
                        .hand-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 8px; margin-bottom: 8px; }
                        .card-img { width: 100%; border-radius: 4px; }
                        .notes { background-color: #f7f7f7; border-left: 3px solid #ccc; padding: 8px; font-style: italic; font-size: 14px; margin-top: 8px; }
                    </style>
                    <h1 style="font-size: 24px; font-weight: bold; margin-bottom: 16px; text-align: center;">Shootout Export</h1>
                    <h2 style="font-size: 16px; margin-bottom: 16px; color: #555;">User: ${this.state.userDeckData.name} vs Opponent: ${this.state.opponentDeckData.name}</h2>
                `;
                this.state.results.forEach(result => {
                    const winnerClass = result.winner === 'user' ? 'style="color: #2f855a;"' : 'style="color: #c53030;"';
                    const winnerText = result.winner === 'user' ? 'User Win' : 'Opponent Win';
                    const trialBg = result.winner === 'user' ? 'style="background-color: #f0fff4;"' : 'style="background-color: #fff5f5;"';
                    htmlContent += `
                        <div class="trial" ${trialBg}>
                            <h3 style="font-size: 18px; font-weight: bold; margin-bottom: 12px;">Trial #${result.trial} - <span ${winnerClass}>${winnerText}</span></h3>
                            <h4 style="font-weight: bold; margin-bottom: 4px;">Your Hand:</h4>
                            <div class="hand-grid">
                                ${result.userHand.map(id => `<img class="card-img" src="${this.getCardFromCache(id)?.imageUrl}" onerror="this.outerHTML = '<div style=\\'border:1px dashed #999; color:#555; padding:4px; height:100%; font-size:8px; display:flex; align-items:center; justify-content:center; text-align:center;\\'>${this.getCardFromCache(id)?.name || 'Fail' }</div>'"/>`).join('')}
                            </div>
                            <h4 style="font-weight: bold; margin-bottom: 4px;">Opponent's Hand:</h4>
                            <div class="hand-grid">
                                ${result.opponentHand.map(id => `<img class="card-img" src="${this.getCardFromCache(id)?.imageUrl}" onerror="this.outerHTML = '<div style=\\'border:1px dashed #999; color:#555; padding:4px; height:100%; font-size:8px; display:flex; align-items:center; justify-content:center; text-align:center;\\'>${this.getCardFromCache(id)?.name || 'Fail' }</div>'"/>`).join('')}
                            </div>
                            ${result.notes ? `<div class="notes">${result.notes.replace(/\n/g, '<br>')}</div>` : ''}
                        </div>
                    `;
                });
                this._openPreviewModal(htmlContent, 'shootout-hands-and-notes.pdf');
            },

            handleAIAnalysis: async function() { // MODIFIED
                // Check if API key is available
                if (!geminiApiKey) {
                    showMessage("No API key configured. Generating prompt instead...");
                    generateShootoutPrompt();
                    return;
                }
                
                showMessage("Sending data to Gemini for analysis...");

                const summaryPrompt = this.state.results.map(r => {
                    return `Trial ${r.trial}: User won=${r.winner === 'user'}. Notes: "${r.notes || 'N/A'}"`
                }).join('\n');
                
                const prompt = `
                    You are a Yu-Gi-Oh! expert. Analyze the following shootout session data between two decks and provide insights.

                    **User Deck: ${this.state.userDeckData.name}**
                    **Opponent Deck: ${this.state.opponentDeckData.name}**
                    
                    **Session Data Summary:**
                    - Total Trials: ${this.state.results.length}
                    - User Wins: ${this.state.results.filter(r=>r.winner==='user').length}
                    - Opponent Wins: ${this.state.results.filter(r=>r.winner==='opponent').length}

                    **User Trial-by-Trial Notes & Results:**
                    ${summaryPrompt}

                    Please provide a comprehensive analysis with the following structure using markdown:
                    ### Key Cards
                    - **Most Valuable Player (MVP):** Identify the single card that appeared to contribute most to wins, based on the notes and hand data.
                    - **Most Problematic Card:** Identify a card that frequently appeared in losing hands or was mentioned negatively in notes.

                    ### Key Patterns from Notes
                    - Analyze the user's notes. What recurring themes, combos, or problem cards are mentioned?

                    ### Actionable Suggestions
                    - Based on the analysis, provide 2-3 specific, actionable suggestions for the user to improve their deck or strategy for this specific matchup.
                `;
                const analysis = await callGemini(prompt);
                if (analysis) {
                    UI.shootoutReportContent.innerHTML += `<div class="mt-4 p-4 bg-slate-800 rounded-lg text-left">${parseSimpleMarkdown(analysis)}</div>`;
                } else {
                    showMessage("Failed to get AI analysis.");
                }
            }
        }; // MODIFIED
        
        // --- IMMERSION MODE FUNCTIONS ---
        function captureLayoutConfiguration() {
            const config = {
                // Capture visibility states
                databaseVisible: databaseVisible,
                sideDeckVisible: sideDeckVisible,
                extraDeckVisible: extraDeckVisible,
                
                // Capture cards per row settings
                mainCardsPerRow: parseInt(localStorage.getItem('mainDeckCardsPerRow')) || 8,
                sideCardsPerRow: parseInt(localStorage.getItem('sideDeckCardsPerRow')) || 3,
                extraCardsPerRow: parseInt(localStorage.getItem('extraDeckCardsPerRow')) || 3,
                dbCardsPerRow: parseInt(localStorage.getItem('dbDeckCardsPerRow')) || 8,
                
                // Capture width proportions
                proportions: {}
            };
            
            // Calculate width proportions relative to their parent containers
            if (UI.deckBuilderContainer) {
                const containerWidth = UI.deckBuilderContainer.offsetWidth;
                
                // Database section proportion
                if (UI.cardDatabaseSection && databaseVisible) {
                    config.proportions.database = (UI.cardDatabaseSection.offsetWidth / containerWidth) * 100;
                }
                
                // Deck grid container proportion (for main/side/extra decks)
                if (UI.deckGridContainer) {
                    const deckContainerWidth = UI.deckGridContainer.offsetWidth;
                    const deckContainerProportion = (deckContainerWidth / containerWidth) * 100;
                    
                    // Main deck proportion within deck container
                    if (UI.mainDeckSection) {
                        config.proportions.main = (UI.mainDeckSection.offsetWidth / deckContainerWidth) * deckContainerProportion;
                    }
                    
                    // Side deck proportion within deck container
                    if (UI.sideDeckSection && sideDeckVisible) {
                        config.proportions.side = (UI.sideDeckSection.offsetWidth / deckContainerWidth) * deckContainerProportion;
                    }
                    
                    // Extra deck proportion within deck container
                    if (UI.extraDeckSection && extraDeckVisible) {
                        config.proportions.extra = (UI.extraDeckSection.offsetWidth / deckContainerWidth) * deckContainerProportion;
                    }
                }
            }
            
            // Store in immersion mode state
            immersionMode.layoutConfig = config;
            
            console.log('[IMMERSION LAYOUT] Captured configuration:', config);
            return config;
        }
        
        function toggleImmersionMode() {
            // Immersion mode is currently under construction
            showMessage("Immersion Mode is currently under construction. Coming soon!");
        }
        
        function updateImmersionModeButton() {
            const btn = document.getElementById('immersionModeBtn');
            if (!btn) return;
            
            if (immersionMode.active) {
                btn.classList.remove('bg-slate-700', 'hover:bg-slate-600');
                btn.classList.add('bg-yellow-600', 'hover:bg-yellow-700', 'active');
            } else {
                btn.classList.remove('bg-yellow-600', 'hover:bg-yellow-700', 'active');
                btn.classList.add('bg-slate-700', 'hover:bg-slate-600');
            }
        }
        
        function enterImmersionMode() {
            // Only allow immersion mode from deck builder view
            if (!UI.deckBuilderView || UI.deckBuilderView.classList.contains('hidden')) {
                showMessage("Immersion Mode is only available in the Deck Builder view.");
                return;
            }
            
            // Check if there are any cards to display
            const hasCards = currentDeck.main.length > 0 || 
                            (sideDeckVisible && currentDeck.side.length > 0) || 
                            (extraDeckVisible && currentDeck.extra.length > 0) ||
                            (databaseVisible && cardDatabase.length > 0);
            
            if (!hasCards) {
                showMessage("No cards to display. Please add some cards to your deck first.");
                return;
            }
            
            // Capture the current layout configuration
            const layoutConfig = captureLayoutConfiguration();
            
            immersionMode.active = true;
            
            // Create overlay structure with layout config
            createImmersionOverlay(layoutConfig);
            
            // Start mouse tracking
            document.addEventListener('mousemove', updateImmersionMouseTracking);
            
            // Add keyboard listener for ESC key
            document.addEventListener('keydown', handleImmersionKeydown);
            
            // Activate overlay
            setTimeout(() => {
                if (immersionMode.overlay) {
                    immersionMode.overlay.classList.add('active');
                    
                    // Show instructions tooltip
                    showImmersionInstructions();
                }
            }, 50);
        }
        
        function showImmersionInstructions() {
            const instructions = document.createElement('div');
            instructions.style.cssText = `
                position: fixed;
                bottom: 40px;
                left: 50%;
                transform: translateX(-50%);
                z-index: 10002;
                background: rgba(0, 0, 0, 0.85);
                color: white;
                padding: 16px 32px;
                border-radius: 12px;
                font-family: 'Inter', sans-serif;
                font-size: 14px;
                text-align: center;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
                border: 2px solid rgba(212, 175, 55, 0.4);
                opacity: 0;
                transition: opacity 0.5s ease;
            `;
            instructions.innerHTML = `
                <div style="margin-bottom: 8px; font-weight: 600; color: #D4AF37;"> Immersion Mode Active </div>
                <div style="font-size: 12px; color: rgba(255, 255, 255, 0.9);">
                    <kbd style="background: rgba(255,255,255,0.1); padding: 2px 6px; border-radius: 4px; font-family: monospace;">Drag</kbd> to reorder cards 
                    <kbd style="background: rgba(255,255,255,0.1); padding: 2px 6px; border-radius: 4px; font-family: monospace;">Right-click</kbd> to remove 
                    <kbd style="background: rgba(255,255,255,0.1); padding: 2px 6px; border-radius: 4px; font-family: monospace;">ESC</kbd> to exit
                </div>
            `;
            
            immersionMode.overlay.appendChild(instructions);
            
            // Fade in slowly
            setTimeout(() => {
                instructions.style.opacity = '1';
            }, 200);
            
            // Fade out after 6 seconds
            setTimeout(() => {
                instructions.style.opacity = '0';
                setTimeout(() => {
                    if (instructions.parentNode) {
                        instructions.parentNode.removeChild(instructions);
                    }
                }, 800);
            }, 6000);
        }
        
        function handleImmersionKeydown(e) {
            if (!immersionMode.active) return;
            
            if (e.key === 'Escape') {
                e.preventDefault();
                exitImmersionMode();
            }
        }
        
        function handleImmersionCardRightClick(e) {
            e.preventDefault();
            
            const cardEl = e.currentTarget;
            const cardId = cardEl.dataset.cardId;
            const sectionName = cardEl.dataset.sectionName;
            
            // Determine which deck part to remove from
            let deckPart = 'main';
            if (sectionName === 'Side Deck') deckPart = 'side';
            else if (sectionName === 'Extra Deck') deckPart = 'extra';
            
            // Remove card with smooth animation
            cardEl.style.transition = 'transform 0.6s cubic-bezier(0.16, 1, 0.3, 1), opacity 0.6s ease';
            cardEl.style.transform = 'scale(0) rotate(90deg) translateZ(-100px)';
            cardEl.style.opacity = '0';
            
            setTimeout(() => {
                // Remove from deck data
                removeCardFromDeck(cardId, deckPart);
                
                // Remove from immersion view
                if (cardEl.parentNode) {
                    cardEl.parentNode.removeChild(cardEl);
                }
                
                // Remove from cards array
                const index = immersionMode.cards.indexOf(cardEl);
                if (index > -1) {
                    immersionMode.cards.splice(index, 1);
                }
                
                showTooltip('Card removed');
            }, 600);
        }
        
        function createImmersionOverlay(layoutConfig) {
            // Create main overlay
            const overlay = document.createElement('div');
            overlay.id = 'immersionModeOverlay';
            // Using exact homepage card sizes - no custom scaling
            immersionMode.overlay = overlay;
            
            // Dim layer
            const dim = document.createElement('div');
            dim.className = 'immersion-dim';
            overlay.appendChild(dim);
            
            // Aurora layers
            const aurora1 = document.createElement('div');
            aurora1.className = 'immersion-aurora-bg';
            overlay.appendChild(aurora1);
            
            const aurora2 = document.createElement('div');
            aurora2.className = 'immersion-aurora-bg-2';
            overlay.appendChild(aurora2);
            
            // Create main container that mimics the deck builder layout
            const mainContainer = document.createElement('div');
            mainContainer.className = 'immersion-main-container';
            mainContainer.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                display: flex;
                justify-content: center;
                align-items: center;
                padding: 2rem;
                gap: 2rem;
                perspective: 2000px;
            `;
            
            // Create database section if visible (left side) - matches homepage layout exactly
            if (layoutConfig.databaseVisible && cardDatabase.length > 0) {
                const dbSection = createImmersionSection('Card Database', cardDatabase.map(c => c.id), 'database', 0, layoutConfig.dbCardsPerRow);
                // Use captured proportion or fallback to 33.333%
                const dbWidth = layoutConfig.proportions.database || 33.333;
                dbSection.style.width = `${dbWidth}%`;
                dbSection.style.flex = `0 0 ${dbWidth}%`;
                dbSection.style.minWidth = '280px';
                mainContainer.appendChild(dbSection);
            }
            
            // Create deck sections container (right side or full width if no database) - matches homepage layout
            const deckContainer = document.createElement('div');
            deckContainer.style.cssText = `
                flex: 1;
                display: flex;
                justify-content: center;
                align-items: center;
                gap: 16px;
                min-width: 0;
                padding: 12px;
            `;
            
            let spiralIndexCounter = layoutConfig.databaseVisible ? cardDatabase.length : 0;
            
            // Add main deck (always present) - matches homepage layout exactly
            if (currentDeck.main.length > 0) {
                const mainSection = createImmersionSection('Main Deck', currentDeck.main, 'deck', spiralIndexCounter, layoutConfig.mainCardsPerRow);
                // Use captured proportion or fallback to flex: 1
                if (layoutConfig.proportions.main) {
                    mainSection.style.width = `${layoutConfig.proportions.main}%`;
                    mainSection.style.flex = `0 0 ${layoutConfig.proportions.main}%`;
                } else {
                    mainSection.style.flex = '1';
                }
                mainSection.style.minWidth = '300px';
                deckContainer.appendChild(mainSection);
                spiralIndexCounter += currentDeck.main.length;
            }
            
            // Add side deck if visible - matches homepage layout exactly
            if (layoutConfig.sideDeckVisible && currentDeck.side.length > 0) {
                const sideSection = createImmersionSection('Side Deck', currentDeck.side, 'deck', spiralIndexCounter, layoutConfig.sideCardsPerRow);
                // Use captured proportion or fallback to 280px
                if (layoutConfig.proportions.side) {
                    sideSection.style.width = `${layoutConfig.proportions.side}%`;
                    sideSection.style.flex = `0 0 ${layoutConfig.proportions.side}%`;
                } else {
                    sideSection.style.width = '280px';
                }
                sideSection.style.minWidth = '200px';
                deckContainer.appendChild(sideSection);
                spiralIndexCounter += currentDeck.side.length;
            }
            
            // Add extra deck if visible - matches homepage layout exactly
            if (layoutConfig.extraDeckVisible && currentDeck.extra.length > 0) {
                const extraSection = createImmersionSection('Extra Deck', currentDeck.extra, 'deck', spiralIndexCounter, layoutConfig.extraCardsPerRow);
                // Use captured proportion or fallback to 280px
                if (layoutConfig.proportions.extra) {
                    extraSection.style.width = `${layoutConfig.proportions.extra}%`;
                    extraSection.style.flex = `0 0 ${layoutConfig.proportions.extra}%`;
                } else {
                    extraSection.style.width = '280px';
                }
                extraSection.style.minWidth = '200px';
                deckContainer.appendChild(extraSection);
                spiralIndexCounter += currentDeck.extra.length;
            }
            
            // Dynamically adjust centering based on visible sections
            const visibleSections = deckContainer.children.length;
            if (visibleSections === 1) {
                // Only main deck visible - center it perfectly
                deckContainer.style.justifyContent = 'center';
            } else if (visibleSections === 2) {
                // Main deck + one other section - center the pair
                deckContainer.style.justifyContent = 'center';
            } else {
                // Multiple sections - use normal flex layout
                deckContainer.style.justifyContent = 'flex-start';
            }
            
            mainContainer.appendChild(deckContainer);
            overlay.appendChild(mainContainer);
            
            // Create exit hitbox and button
            createImmersionExitButton(overlay);
            
            // Scale slider removed - using exact homepage card sizes
            
            // Append to body
            document.body.appendChild(overlay);
            
            // Start spiral emergence animation
            setTimeout(() => animateCardEmergence(), 100);
            
            // Assign sections to planes
            assignImmersionPlanes();

            // Start 3D mouse tracking
            startImmersion3DTracking();
        }
        
        function createImmersionSection(sectionName, cardIds, sectionType, startSpiralIndex, cardsPerRow) {
            const sectionDiv = document.createElement('div');
            sectionDiv.className = 'immersion-deck-section';
            sectionDiv.dataset.sectionType = sectionType;
            sectionDiv.dataset.sectionName = sectionName;


            sectionDiv.style.cssText = `
                position: relative;
                display: grid;
                gap: ${sectionType === 'database' ? '0px' : '4px'};
                align-content: start;
                padding: 12px;
                overflow-y: auto;
                overflow-x: hidden;
                border-radius: 8px;
                background-color: transparent;
            `;
            
            // Use captured cards-per-row setting for exact layout matching
            if (cardsPerRow && cardsPerRow > 0) {
                sectionDiv.style.gridTemplateColumns = `repeat(${cardsPerRow}, minmax(0, 1fr))`;
            } else {
                // Fallback to original behavior if no cardsPerRow provided
                if (sectionName === 'Main Deck') {
                    sectionDiv.style.gridTemplateColumns = `repeat(auto-fill, minmax(var(--main-deck-size), 1fr))`;
                } else if (sectionName === 'Side Deck') {
                    sectionDiv.style.gridTemplateColumns = `repeat(auto-fill, minmax(var(--side-deck-size), 1fr))`;
                } else if (sectionName === 'Extra Deck') {
                    sectionDiv.style.gridTemplateColumns = `repeat(auto-fill, minmax(var(--extra-deck-size), 1fr))`;
                } else if (sectionName === 'Card Database') {
                    sectionDiv.style.gridTemplateColumns = `repeat(auto-fill, minmax(var(--db-card-size, 80px), 1fr))`;
                }
            }
            
            // Section labels removed for cleaner immersion mode
            
            // Add cards
            cardIds.forEach((cardId, idx) => {
                const card = cardDatabase.find(c => c.id === cardId);
                if (!card) return;
                
                const cardEl = document.createElement('div');
                cardEl.className = 'immersion-card';
                if (sectionType === 'database') {
                    cardEl.classList.add('database-card');
                }
                
                // Set card size based on section type to match homepage exactly
                if (sectionName === 'Main Deck') {
                    cardEl.style.width = 'var(--main-deck-size, 68px)';
                    cardEl.style.height = 'calc(var(--main-deck-size, 68px) * 1.4)';
                } else if (sectionName === 'Side Deck') {
                    cardEl.style.width = 'var(--side-deck-size, 68px)';
                    cardEl.style.height = 'calc(var(--side-deck-size, 68px) * 1.4)';
                } else if (sectionName === 'Extra Deck') {
                    cardEl.style.width = 'var(--extra-deck-size, 68px)';
                    cardEl.style.height = 'calc(var(--extra-deck-size, 68px) * 1.4)';
                } else if (sectionName === 'Card Database') {
                    cardEl.style.width = 'var(--db-card-size, 80px)';
                    cardEl.style.height = 'calc(var(--db-card-size, 80px) * 1.4)';
                }
                cardEl.dataset.cardId = cardId;
                cardEl.dataset.sectionType = sectionType;
                cardEl.dataset.sectionName = sectionName;
                cardEl.dataset.spiralIndex = startSpiralIndex + idx;
                
                // Remove individual card floating animations - now handled by section
                
                const img = document.createElement('img');
                img.src = card.imageUrl;
                img.alt = card.name;
                img.title = card.name;
                img.draggable = false;
                img.onerror = function() { 
                    this.src = 'https://placehold.co/120x168/2d3748/e2e8f0?text=?'; 
                };
                
                cardEl.appendChild(img);
                
                // Add drag and click listeners
                if (sectionType === 'deck') {
                    cardEl.draggable = true;
                    cardEl.addEventListener('dragstart', handleImmersionDragStart);
                    cardEl.addEventListener('dragend', handleImmersionDragEnd);
                    cardEl.addEventListener('contextmenu', handleImmersionCardRightClick);
                } else {
                    // Database cards
                    cardEl.draggable = true;
                    cardEl.addEventListener('dragstart', handleImmersionDatabaseDragStart);
                    cardEl.addEventListener('click', handleImmersionDatabaseClick);
                    cardEl.addEventListener('contextmenu', handleImmersionDatabaseRightClick);
                    
                    // Also add context menu handler to the image to prevent browser context menu
                    img.addEventListener('contextmenu', handleImmersionDatabaseRightClick);
                }
                
                sectionDiv.appendChild(cardEl);
                immersionMode.cards.push(cardEl);
            });
            
            // Add drop listeners for deck sections
            if (sectionType === 'deck') {
                sectionDiv.addEventListener('dragover', handleImmersionDragOver);
                sectionDiv.addEventListener('drop', handleImmersionDrop);
                sectionDiv.addEventListener('dragleave', handleImmersionDragLeave);
            }
            
            // Track section for plane management
            immersionMode.sections.push(sectionDiv);

            return sectionDiv;
        }
        
        function animateCardEmergence() {
            const cards = immersionMode.cards;
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            
            // Calculate spiral pattern
            const spiralCards = cards.map((card, index) => {
                const spiralIndex = parseInt(card.dataset.spiralIndex);
                const angle = spiralIndex * 0.5; // Golden angle-ish spiral
                const radius = Math.sqrt(spiralIndex) * 30;
                
                return { card, spiralIndex, angle, radius };
            });
            
            // Sort by spiral index for staggered animation
            spiralCards.sort((a, b) => a.spiralIndex - b.spiralIndex);
            
            // Animate each card with delay
            spiralCards.forEach(({ card, spiralIndex, angle, radius }, idx) => {
                setTimeout(() => {
                    // Calculate spiral position for emergence
                    const spiralX = Math.cos(angle) * radius;
                    const spiralY = Math.sin(angle) * radius;
                    
                    // Set initial transform from spiral center
                    card.style.transformOrigin = 'center center';
                    card.style.transform = `translate(${spiralX}px, ${spiralY}px) scale(0.3) rotate(${angle * 20}deg)`;
                    
                    // Trigger emergence
                    requestAnimationFrame(() => {
                        card.classList.add('emerged');
                        
                        // Create sparkle particles during emergence
                        createEmergenceSparkles(card);
                        
                        // Start floating after emergence (longer delay for smooth transition)
                        setTimeout(() => {
                            card.classList.add('floating');
                        }, 800);
                    });
                }, idx * 80); // 80ms delay between each card for smoother stagger
            });
        }
        
        function createEmergenceSparkles(cardEl) {
            const rect = cardEl.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            // Create 8 sparkles around the card
            for (let i = 0; i < 8; i++) {
                const sparkle = document.createElement('div');
                sparkle.style.cssText = `
                    position: fixed;
                    width: 6px;
                    height: 6px;
                    background: white;
                    border-radius: 50%;
                    z-index: 10001;
                    pointer-events: none;
                    box-shadow: 0 0 8px rgba(255, 255, 255, 0.8);
                `;
                
                const angle = (Math.PI * 2 * i) / 8;
                const radius = 40 + Math.random() * 20;
                const startX = centerX;
                const startY = centerY;
                const endX = centerX + Math.cos(angle) * radius;
                const endY = centerY + Math.sin(angle) * radius;
                
                sparkle.style.left = `${startX}px`;
                sparkle.style.top = `${startY}px`;
                sparkle.style.opacity = '0.8';
                sparkle.style.transition = 'all 1.2s cubic-bezier(0.16, 1, 0.3, 1)';
                
                document.body.appendChild(sparkle);
                
                requestAnimationFrame(() => {
                    sparkle.style.left = `${endX}px`;
                    sparkle.style.top = `${endY}px`;
                    sparkle.style.opacity = '0';
                    sparkle.style.transform = 'scale(0.2)';
                });
                
                setTimeout(() => {
                    if (sparkle.parentNode) {
                        sparkle.parentNode.removeChild(sparkle);
                    }
                }, 1200);
            }
        }
        
        function startImmersion3DTracking() {
            // Store previous transforms for smooth interpolation
            const cardTransforms = new Map();
            
            const update3DEffects = () => {
                if (!immersionMode.active) return;
                
                const mouseX = immersionMode.mousePos.x;
                const mouseY = immersionMode.mousePos.y;
                
                immersionMode.cards.forEach(cardEl => {
                    const rect = cardEl.getBoundingClientRect();
                    const cardCenterX = rect.left + rect.width / 2;
                    const cardCenterY = rect.top + rect.height / 2;
                    
                    // Calculate distance and angle from mouse to card
                    const deltaX = mouseX - cardCenterX;
                    const deltaY = mouseY - cardCenterY;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    const maxDistance = 500; // Max distance for effect
                    
                    // Calculate tilt based on mouse position relative to card (much more subtle)
                    const maxTilt = 8; // Reduced for subtle effect
                    const tiltX = (deltaY / rect.height) * maxTilt;
                    const tiltY = -(deltaX / rect.width) * maxTilt;
                    
                    // Calculate lift based on proximity with easing (much more subtle)
                    const proximity = Math.max(0, 1 - (distance / maxDistance));
                    const easedProximity = proximity * proximity * proximity; // Cubic easing for even smoother falloff
                    const lift = easedProximity * 20; // Reduced from 50px to 20px
                    
                    // Apply 3D transform (only if not being hovered or dragged)
                    if (!cardEl.matches(':hover') && !cardEl.classList.contains('dragging')) {
                        // Very smooth interpolation for natural movement
                        const dampening = 0.08; // Reduced for much smoother movement
                        
                        const prevTransform = cardTransforms.get(cardEl) || { tiltX: 0, tiltY: 0, lift: 0 };
                        const newTiltX = prevTransform.tiltX + (tiltX * easedProximity - prevTransform.tiltX) * dampening;
                        const newTiltY = prevTransform.tiltY + (tiltY * easedProximity - prevTransform.tiltY) * dampening;
                        const newLift = prevTransform.lift + (lift - prevTransform.lift) * dampening;
                        
                        cardTransforms.set(cardEl, { tiltX: newTiltX, tiltY: newTiltY, lift: newLift });

                        cardEl.style.transform = `perspective(1200px) rotateX(${newTiltX}deg) rotateY(${newTiltY}deg) translateZ(${newLift}px)`;
                    }
                });

                // Update dynamic section planes for immersive 3D depth
                updateImmersionDynamicPlanes();

                // Update aurora position based on mouse
                const overlay = immersionMode.overlay;
                if (overlay) {
                    const xPercent = (mouseX / window.innerWidth) * 100;
                    const yPercent = (mouseY / window.innerHeight) * 100;
                    overlay.style.setProperty('--aurora-x', `${xPercent}%`);
                    overlay.style.setProperty('--aurora-y', `${yPercent}%`);
                }

                immersionMode.animationFrame = requestAnimationFrame(update3DEffects);
            };
            
            update3DEffects();
        }
        
        function assignImmersionPlanes() {
            // Initialize all sections with default depth values
            immersionMode.sections.forEach(section => {
                section.depthData = {
                    baseDepth: -50, // Base depth in 3D space
                    currentDepth: -50,
                    scale: 0.95,
                    opacity: 0.8,
                    influence: 0 // How much the mouse is influencing this section (0-1)
                };
            });

            // Apply initial positioning
            updateImmersionDynamicPlanes();
        }

        function updateImmersionDynamicPlanes() {
            const mouseX = immersionMode.mousePos.x;
            const mouseY = immersionMode.mousePos.y;

            immersionMode.sections.forEach((section, index) => {
                const rect = section.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                // Calculate distance from mouse to section center
                const deltaX = mouseX - centerX;
                const deltaY = mouseY - centerY;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

                // Calculate influence based on proximity (inverse distance)
                const maxInfluenceDistance = 400; // Distance at which influence starts
                const influence = Math.max(0, 1 - (distance / maxInfluenceDistance));

                // Apply smooth interpolation
                const currentInfluence = section.depthData.influence;
                const smoothedInfluence = currentInfluence + (influence - currentInfluence) * 0.1;

                section.depthData.influence = smoothedInfluence;

                // Calculate depth based on influence and add subtle floating
                const time = performance.now() * 0.001; // Convert to seconds
                const floatOffset = Math.sin(time * 0.5 + index * 0.7) * 8 + Math.cos(time * 0.3 + index * 1.3) * 5;

                // Depth ranges from -80 (back) to +20 (front) based on influence
                const targetDepth = -50 + (smoothedInfluence * 70) + floatOffset;
                const currentDepth = section.depthData.currentDepth;
                section.depthData.currentDepth = currentDepth + (targetDepth - currentDepth) * 0.08;

                // Scale and opacity based on depth
                const depthRatio = (section.depthData.currentDepth + 80) / 100; // 0 to 1 scale
                const targetScale = 0.9 + (depthRatio * 0.15); // 0.9 to 1.05
                const targetOpacity = 0.7 + (depthRatio * 0.3); // 0.7 to 1.0

                section.depthData.scale = section.depthData.scale + (targetScale - section.depthData.scale) * 0.08;
                section.depthData.opacity = section.depthData.opacity + (targetOpacity - section.depthData.opacity) * 0.08;

                // Apply transforms with subtle 3D rotation based on mouse position
                const tiltX = (deltaY / distance) * smoothedInfluence * 8;
                const tiltY = -(deltaX / distance) * smoothedInfluence * 8;

                section.style.transform = `
                    translateZ(${section.depthData.currentDepth}px)
                    scale(${section.depthData.scale})
                    rotateX(${tiltX}deg)
                    rotateY(${tiltY}deg)
                `;
                section.style.opacity = section.depthData.opacity;

                // Dynamic z-index based on depth
                section.style.zIndex = Math.floor(10 + section.depthData.currentDepth);
            });
        }

        function updateImmersionMouseTracking(e) {
            immersionMode.mousePos.x = e.clientX;
            immersionMode.mousePos.y = e.clientY;

            // Update dynamic planes based on mouse proximity
            updateImmersionDynamicPlanes();
        }
        
        function createImmersionExitButton(overlay) {
            // Create invisible hitbox
            const hitbox = document.createElement('div');
            hitbox.className = 'immersion-exit-hitbox';
            immersionMode.exitHitbox = hitbox;
            
            // Create exit button
            const exitBtn = document.createElement('div');
            exitBtn.className = 'immersion-exit-btn';
            exitBtn.innerHTML = `
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12"/>
                </svg>
            `;
            
            // Show button on hitbox hover
            hitbox.addEventListener('mouseenter', () => {
                exitBtn.classList.add('visible');
            });
            
            hitbox.addEventListener('mouseleave', () => {
                exitBtn.classList.remove('visible');
            });
            
            // Exit on button click
            exitBtn.addEventListener('click', exitImmersionMode);
            
            overlay.appendChild(hitbox);
            overlay.appendChild(exitBtn);
        }
        
        // Scale slider function removed - using exact homepage card sizes
        
        function exitImmersionMode() {
            if (!immersionMode.active) return;
            
            immersionMode.active = false;
            
            // Stop 3D tracking
            if (immersionMode.animationFrame) {
                cancelAnimationFrame(immersionMode.animationFrame);
                immersionMode.animationFrame = null;
            }
            
            // Remove event listeners
            document.removeEventListener('mousemove', updateImmersionMouseTracking);
            document.removeEventListener('keydown', handleImmersionKeydown);
            
            // Reverse spiral animation
            const cards = immersionMode.cards;
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            
            cards.forEach((card, idx) => {
                const spiralIndex = parseInt(card.dataset.spiralIndex);
                const angle = spiralIndex * 0.5;
                const radius = Math.sqrt(spiralIndex) * 30;
                
                setTimeout(() => {
                    card.classList.remove('emerged', 'floating');
                    
                    // Create exit sparkles (fewer and more subtle)
                    const rect = card.getBoundingClientRect();
                    for (let i = 0; i < 3; i++) {
                        const sparkle = document.createElement('div');
                        sparkle.style.cssText = `
                            position: fixed;
                            width: 3px;
                            height: 3px;
                            background: white;
                            border-radius: 50%;
                            z-index: 10001;
                            pointer-events: none;
                            box-shadow: 0 0 4px rgba(255, 255, 255, 0.6);
                            left: ${rect.left + rect.width / 2}px;
                            top: ${rect.top + rect.height / 2}px;
                            opacity: 0.7;
                            transition: all 0.8s ease-out;
                        `;
                        
                        const sparkleAngle = (Math.PI * 2 * i) / 3;
                        const sparkleRadius = 15;
                        
                        document.body.appendChild(sparkle);
                        
                        requestAnimationFrame(() => {
                            sparkle.style.left = `${rect.left + rect.width / 2 + Math.cos(sparkleAngle) * sparkleRadius}px`;
                            sparkle.style.top = `${rect.top + rect.height / 2 + Math.sin(sparkleAngle) * sparkleRadius}px`;
                            sparkle.style.opacity = '0';
                        });
                        
                        setTimeout(() => {
                            if (sparkle.parentNode) sparkle.parentNode.removeChild(sparkle);
                        }, 800);
                    }
                    
                    // Spiral back to center with slower animation
                    card.style.transition = 'transform 1s cubic-bezier(0.16, 1, 0.3, 1), opacity 1s ease';
                    const spiralX = Math.cos(angle) * radius;
                    const spiralY = Math.sin(angle) * radius;
                    card.style.transform = `translate(${spiralX}px, ${spiralY}px) scale(0.2) rotate(${angle * 15}deg)`;
                    card.style.opacity = '0';
                }, idx * 40); // Slower, smoother exit
            });
            
            // Remove overlay after animation completes (accounting for slower exit)
            setTimeout(() => {
                if (immersionMode.overlay && immersionMode.overlay.parentNode) {
                    immersionMode.overlay.classList.remove('active');
                    
                    setTimeout(() => {
                        if (immersionMode.overlay && immersionMode.overlay.parentNode) {
                            immersionMode.overlay.parentNode.removeChild(immersionMode.overlay);
                        }
                        immersionMode.overlay = null;
                        immersionMode.cards = [];
                    }, 1200);
                }
            }, cards.length * 40 + 600);
        }
        
        // Drag and drop handlers for deck cards (reordering)
        let immersionDraggedCard = null;
        let immersionDraggedCardOriginalParent = null;
        let immersionPlaceholder = null;
        let immersionDragTargetSection = null;
        
        function handleImmersionDragStart(e) {
            immersionDraggedCard = e.currentTarget;
            immersionDraggedCardOriginalParent = immersionDraggedCard.parentNode;
            
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', immersionDraggedCard.dataset.cardId);
            
            // Create placeholder
            immersionPlaceholder = document.createElement('div');
            immersionPlaceholder.className = 'immersion-card immersion-placeholder';
            
            setTimeout(() => {
                if (immersionDraggedCard) {
                    immersionDraggedCard.classList.add('dragging');
                    immersionDraggedCard.style.opacity = '0.5';
                    immersionDraggedCard.style.filter = 'brightness(1.3)';
                }
            }, 0);
        }
        
        function handleImmersionDragEnd(e) {
            if (immersionDraggedCard) {
                immersionDraggedCard.classList.remove('dragging');
                immersionDraggedCard.style.opacity = '';
                immersionDraggedCard.style.filter = '';

                // Remove size transition after drag ends
                setTimeout(() => {
                    if (immersionDraggedCard) {
                        immersionDraggedCard.style.transition = '';
                    }
                }, 300);
            }

            if (immersionPlaceholder && immersionPlaceholder.parentNode) {
                immersionPlaceholder.parentNode.removeChild(immersionPlaceholder);
            }

            immersionDraggedCard = null;
            immersionDraggedCardOriginalParent = null;
            immersionPlaceholder = null;
            immersionDragTargetSection = null;
        }
        
        function updateImmersionCardSizeForSection(cardEl, targetSection) {
            if (!cardEl || !targetSection) return;

            const sectionName = targetSection.dataset.sectionName;

            // Apply size based on target section
            if (sectionName === 'Main Deck') {
                cardEl.style.width = 'var(--main-deck-size, 68px)';
                cardEl.style.height = 'calc(var(--main-deck-size, 68px) * 1.4)';
            } else if (sectionName === 'Side Deck') {
                cardEl.style.width = 'var(--side-deck-size, 68px)';
                cardEl.style.height = 'calc(var(--side-deck-size, 68px) * 1.4)';
            } else if (sectionName === 'Extra Deck') {
                cardEl.style.width = 'var(--extra-deck-size, 68px)';
                cardEl.style.height = 'calc(var(--extra-deck-size, 68px) * 1.4)';
            } else if (sectionName === 'Card Database') {
                cardEl.style.width = 'var(--db-card-size, 80px)';
                cardEl.style.height = 'calc(var(--db-card-size, 80px) * 1.4)';
            }

            // Add smooth transition for size changes
            cardEl.style.transition = 'width 0.3s ease, height 0.3s ease';
        }

        function handleImmersionDragOver(e) {
            e.preventDefault();

            const sectionDiv = e.currentTarget;
            const isDatabaseCard = e.dataTransfer.getData('text/database') === 'true';

            if (isDatabaseCard) {
                // Handle database card dragging - update size in real-time
                if (immersionDragTargetSection !== sectionDiv) {
                    immersionDragTargetSection = sectionDiv;
                    // For database cards, we need to find the dragged element
                    // Since it's not stored in immersionDraggedCard, we'll update size on dragover
                    const draggedCardId = e.dataTransfer.getData('text/plain');
                    const draggedCard = immersionMode.cards.find(card => card.dataset.cardId === draggedCardId);
                    if (draggedCard) {
                        updateImmersionCardSizeForSection(draggedCard, sectionDiv);
                    }
                }
                return; // Database cards don't use placeholder system
            }

            if (!immersionDraggedCard || !immersionPlaceholder) return;

            // Update card size if target section changed
            if (immersionDragTargetSection !== sectionDiv) {
                immersionDragTargetSection = sectionDiv;
                updateImmersionCardSizeForSection(immersionDraggedCard, sectionDiv);
            }
            const cards = Array.from(sectionDiv.querySelectorAll('.immersion-card:not(.database-card)'));
            
            // Find insertion point
            const afterElement = getImmersionDragAfterElement(sectionDiv, e.clientX, e.clientY);
            
            const oldPlaceholderParent = immersionPlaceholder.parentNode;
            const oldNextSibling = immersionPlaceholder.nextElementSibling;
            
            if (afterElement == null) {
                sectionDiv.appendChild(immersionPlaceholder);
            } else {
                sectionDiv.insertBefore(immersionPlaceholder, afterElement);
            }
            
            // Animate cards shifting to make room (only if placeholder moved)
            if (oldPlaceholderParent !== immersionPlaceholder.parentNode || 
                oldNextSibling !== immersionPlaceholder.nextElementSibling) {
                cards.forEach(card => {
                    if (card !== immersionDraggedCard && !card.style.transition) {
                        card.style.transition = 'transform 0.5s cubic-bezier(0.16, 1, 0.3, 1)';
                    }
                });
            }
            
            // Highlight drop zone
            sectionDiv.classList.add('drop-target');
        }
        
        function handleImmersionDragLeave(e) {
            if (e.currentTarget.contains(e.relatedTarget)) return;
            e.currentTarget.classList.remove('drop-target');
        }
        
        function handleImmersionDrop(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('drop-target');
            
            const sectionDiv = e.currentTarget;
            const sectionName = sectionDiv.dataset.sectionName;
            
            // Check if this is a database card being added
            const isFromDatabase = e.dataTransfer.getData('text/database') === 'true';
            
            if (isFromDatabase) {
                // Database card dropped on deck section
                const cardId = e.dataTransfer.getData('text/plain');
                
                // Determine which deck to add to
                let deckPart = 'main';
                if (sectionName === 'Side Deck') deckPart = 'side';
                else if (sectionName === 'Extra Deck') deckPart = 'extra';
                
                // Add card to deck
                addCardToDeck(cardId, deckPart);
                
                // Visual feedback
                showTooltip(`Added to ${sectionName}`);
                
                // Refresh immersion view
                setTimeout(() => refreshImmersionMode(), 100);
            } else if (immersionDraggedCard && immersionPlaceholder) {
                // Regular deck card reordering
                // Replace placeholder with actual card
                if (immersionPlaceholder.parentNode) {
                    immersionPlaceholder.parentNode.replaceChild(immersionDraggedCard, immersionPlaceholder);
                }
                
                // Update deck order in the underlying data
                updateDeckOrderFromImmersion();
                
                // Smooth reposition animation
                animateCardReposition(immersionDraggedCard);
            }
        }
        
        function getImmersionDragAfterElement(container, x, y) {
            const draggableElements = Array.from(container.querySelectorAll('.immersion-card:not(.database-card)'))
                .filter(el => el !== immersionDraggedCard && el !== immersionPlaceholder);
            
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const centerX = box.left + box.width / 2;
                const centerY = box.top + box.height / 2;
                const distance = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
                
                if (distance < closest.distance) {
                    const isBefore = x < centerX;
                    return { distance, element: isBefore ? child : child.nextElementSibling };
                } else {
                    return closest;
                }
            }, { distance: Number.POSITIVE_INFINITY, element: null }).element;
        }
        
        function updateDeckOrderFromImmersion() {
            // Find all deck sections
            const sections = immersionMode.overlay.querySelectorAll('.immersion-deck-section[data-section-type="deck"]');
            
            sections.forEach(section => {
                const sectionName = section.dataset.sectionName;
                const cards = Array.from(section.querySelectorAll('.immersion-card:not(.database-card)'));
                const cardIds = cards.map(card => card.dataset.cardId);
                
                // Update the corresponding deck
                if (sectionName === 'Main Deck') {
                    currentDeck.main = cardIds;
                } else if (sectionName === 'Side Deck') {
                    currentDeck.side = cardIds;
                } else if (sectionName === 'Extra Deck') {
                    currentDeck.extra = cardIds;
                }
            });
            
            // Update the main deck builder view (will be visible when exiting)
            renderCurrentDeck();
        }
        
        function animateCardReposition(cardEl) {
            // Add a smooth "settle" animation
            cardEl.style.transition = 'transform 0.6s cubic-bezier(0.16, 1, 0.3, 1)';
            cardEl.style.transform = `scale(1.08)`;
            
            setTimeout(() => {
                cardEl.style.transform = '';
                setTimeout(() => {
                    cardEl.style.transition = '';
                }, 600);
            }, 150);
        }
        
        // Database card handlers
        function handleImmersionDatabaseDragStart(e) {
            e.dataTransfer.effectAllowed = 'copy';
            e.dataTransfer.setData('text/plain', e.currentTarget.dataset.cardId);
            e.dataTransfer.setData('text/database', 'true');

            e.currentTarget.style.opacity = '0.6';

            // Reset opacity and transition on drag end
            e.currentTarget.addEventListener('dragend', function resetOpacity() {
                e.currentTarget.style.opacity = '';
                // Remove size transition after drag ends
                setTimeout(() => {
                    e.currentTarget.style.transition = '';
                }, 300);
                e.currentTarget.removeEventListener('dragend', resetOpacity);
            });
        }
        
        function handleImmersionDatabaseClick(e) {
            const cardId = e.currentTarget.dataset.cardId;
            
            // Auto-add to main deck
            addCardToDeck(cardId, 'main');
            
            // Show visual feedback
            showTooltip('Added to Main Deck');
            
            // Create ripple effect at click position
            createImmersionRipple(e.clientX, e.clientY);
            
            // Create a copy animation
            const cardEl = e.currentTarget;
            const clone = cardEl.cloneNode(true);
            clone.style.position = 'fixed';
            clone.style.left = `${cardEl.getBoundingClientRect().left}px`;
            clone.style.top = `${cardEl.getBoundingClientRect().top}px`;
            clone.style.width = `${cardEl.offsetWidth}px`;
            clone.style.pointerEvents = 'none';
            clone.style.zIndex = '10002';
            clone.style.transition = 'transform 1s cubic-bezier(0.16, 1, 0.3, 1), opacity 1s ease';
            clone.style.filter = 'brightness(1.3)';
            
            document.body.appendChild(clone);
            
            // Create particle trail (fewer particles)
            createCardTrailParticles(cardEl.getBoundingClientRect());
            
            // Find main deck section
            const mainSection = immersionMode.overlay.querySelector('[data-section-name="Main Deck"]');
            if (mainSection) {
                const targetRect = mainSection.getBoundingClientRect();
                
                requestAnimationFrame(() => {
                    clone.style.transform = `translate(${targetRect.left - cardEl.getBoundingClientRect().left}px, ${targetRect.top - cardEl.getBoundingClientRect().top}px) scale(1) rotate(180deg)`;
                    clone.style.opacity = '0';
                });
                
                setTimeout(() => {
                    if (clone.parentNode) clone.parentNode.removeChild(clone);
                    
                    // Refresh immersion view to show new card
                    refreshImmersionMode();
                }, 1000);
            }
        }
        
        function handleImmersionDatabaseRightClick(e) {
            e.preventDefault();
            e.stopPropagation();
            const cardId = e.currentTarget.dataset.cardId;
            
            // Auto-add to main deck
            addCardToDeck(cardId, 'main');
            
            // Show visual feedback
            showTooltip('Added to Main Deck');
            
            // Create ripple effect at click position
            createImmersionRipple(e.clientX, e.clientY);
            
            // Create a copy animation
            const cardEl = e.currentTarget;
            const clone = cardEl.cloneNode(true);
            clone.style.position = 'fixed';
            clone.style.left = `${cardEl.getBoundingClientRect().left}px`;
            clone.style.top = `${cardEl.getBoundingClientRect().top}px`;
            clone.style.width = `${cardEl.offsetWidth}px`;
            clone.style.pointerEvents = 'none';
            clone.style.zIndex = '10002';
            clone.style.transition = 'transform 1s cubic-bezier(0.16, 1, 0.3, 1), opacity 1s ease';
            clone.style.filter = 'brightness(1.3)';
            
            document.body.appendChild(clone);
            
            // Create particle trail (fewer particles)
            createCardTrailParticles(cardEl.getBoundingClientRect());
            
            // Find main deck section
            const mainSection = immersionMode.overlay.querySelector('[data-section-name="Main Deck"]');
            if (mainSection) {
                const targetRect = mainSection.getBoundingClientRect();
                
                requestAnimationFrame(() => {
                    clone.style.transform = `translate(${targetRect.left - cardEl.getBoundingClientRect().left}px, ${targetRect.top - cardEl.getBoundingClientRect().top}px) scale(1) rotate(180deg)`;
                    clone.style.opacity = '0';
                });
                
                setTimeout(() => {
                    if (clone.parentNode) clone.parentNode.removeChild(clone);
                    
                    // Refresh immersion view to show new card
                    refreshImmersionMode();
                }, 1000);
            }
        }
        
        function createImmersionRipple(x, y) {
            const ripple = document.createElement('div');
            ripple.style.cssText = `
                position: fixed;
                left: ${x}px;
                top: ${y}px;
                width: 10px;
                height: 10px;
                border-radius: 50%;
                border: 2px solid rgba(59, 130, 246, 0.8);
                transform: translate(-50%, -50%);
                pointer-events: none;
                z-index: 10002;
                animation: ripple-expand 0.8s ease-out forwards;
            `;
            
            document.body.appendChild(ripple);
            
            setTimeout(() => {
                if (ripple.parentNode) ripple.parentNode.removeChild(ripple);
            }, 800);
        }
        
        function createCardTrailParticles(startRect) {
            const startX = startRect.left + startRect.width / 2;
            const startY = startRect.top + startRect.height / 2;
            
            for (let i = 0; i < 8; i++) {
                const particle = document.createElement('div');
                particle.style.cssText = `
                    position: fixed;
                    left: ${startX}px;
                    top: ${startY}px;
                    width: 3px;
                    height: 3px;
                    background: rgba(59, 130, 246, 0.6);
                    border-radius: 50%;
                    pointer-events: none;
                    z-index: 10001;
                    box-shadow: 0 0 4px rgba(59, 130, 246, 0.4);
                `;
                
                const angle = (Math.PI * 2 * i) / 8;
                const distance = 20 + Math.random() * 15;
                const endX = startX + Math.cos(angle) * distance;
                const endY = startY + Math.sin(angle) * distance;
                
                particle.style.transition = 'all 0.8s ease-out';
                
                document.body.appendChild(particle);
                
                requestAnimationFrame(() => {
                    particle.style.left = `${endX}px`;
                    particle.style.top = `${endY}px`;
                    particle.style.opacity = '0';
                    particle.style.transform = 'scale(0.2)';
                });
                
                setTimeout(() => {
                    if (particle.parentNode) particle.parentNode.removeChild(particle);
                }, 800);
            }
        }
        
        function refreshImmersionMode() {
            // Save current state
            const wasActive = immersionMode.active;
            if (!wasActive) return;
            
            // Remove old overlay
            if (immersionMode.overlay && immersionMode.overlay.parentNode) {
                immersionMode.overlay.parentNode.removeChild(immersionMode.overlay);
            }
            
            // Clear cards array
            immersionMode.cards = [];
            
            // Recreate overlay with updated deck
            createImmersionOverlay();
            
            // Reactivate
            setTimeout(() => {
                if (immersionMode.overlay) {
                    immersionMode.overlay.classList.add('active');
                }
                animateCardEmergence();
            }, 50);
        }
        
        // Initialize the application
        main();
    </script>
    <style>
        :root {
            --color-bg: #1b1c1d;
            --color-surface-1: #2a2b2d;
            --color-primary: #2563eb; /* blue-600 */
            --color-primary-hover: #1d4ed8; /* blue-700 */
            --color-text-base: #e2e8f0; /* slate-200 */
            --color-text-muted: #94a3b8; /* slate-400 */
            --color-border: #475569; /* slate-600 */
            --card-size: 68px;
            --main-deck-size: 68px;
            --side-deck-size: 68px;
            --extra-deck-size: 68px;
            --db-card-size: 80px;
        }
        html, body {
            background-color: var(--color-bg);
            color: var(--color-text-base);
            font-family: 'Inter', sans-serif;
        }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: var(--color-surface-1); }
        ::-webkit-scrollbar-thumb { background: var(--color-primary); border-radius: 4px; }
        .card-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 0.75rem; }
        .deck-grid { 
            display: grid; 
            grid-template-columns: repeat(auto-fill, minmax(var(--main-deck-size), 1fr)); 
            gap: 4px; 
            align-content: start;
        }
        
        /* Card Database Grid View */
        .card-db-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(var(--db-card-size, 80px), 1fr));
            gap: 8px;
            align-content: start;
        }
        
        .card-db-grid .card-item {
            aspect-ratio: 2.5/3.5;
            border-radius: 8px;
            overflow: hidden;
            cursor: grab;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            position: relative;
        }
        
        .card-db-grid .card-item.edit-mode {
            cursor: pointer;
        }
        
        .card-db-grid .card-item:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .card-db-grid .card-item:active {
            cursor: grabbing;
        }
        
        .card-db-grid .card-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .card-db-grid .card-item.dragging {
            opacity: 0.5;
            transform: rotate(5deg);
        }
        
        .card-db-grid .card-item.selected {
            border: 2px solid #3b82f6;
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.5);
        }
        
        .card-db-grid .card-item input[type="checkbox"] {
            accent-color: #3b82f6;
        }
        
        /* Advanced Search Modal Styles */
        #advancedSearchModal .grid {
            display: grid;
        }
        
        #advancedSearchModal input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            cursor: pointer;
        }
        
        #advancedSearchModal input[type="range"]::-webkit-slider-track {
            background-color: #475569;
            height: 0.5rem;
            border-radius: 0.25rem;
        }
        
        #advancedSearchModal input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            background-color: var(--color-primary);
            height: 1rem;
            width: 1rem;
            border-radius: 50%;
            margin-top: -0.25rem;
        }
        
        #advancedSearchModal input[type="range"]::-moz-range-track {
            background-color: #475569;
            height: 0.5rem;
            border-radius: 0.25rem;
        }
        
        #advancedSearchModal input[type="range"]::-moz-range-thumb {
            background-color: var(--color-primary);
            height: 1rem;
            width: 1rem;
            border-radius: 50%;
            border: none;
        }
        
        /* Scrollbar styling for advanced search */
        #advancedSearchModal ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        #advancedSearchModal ::-webkit-scrollbar-track {
            background: #1e293b;
            border-radius: 4px;
        }
        
        #advancedSearchModal ::-webkit-scrollbar-thumb {
            background: #475569;
            border-radius: 4px;
        }
        
        #advancedSearchModal ::-webkit-scrollbar-thumb:hover {
            background: #64748b;
        }
        
        .side-deck-grid { 
            display: grid; 
            grid-template-columns: repeat(auto-fill, minmax(var(--side-deck-size), 1fr)); 
            gap: 4px; 
            align-content: start;
        }
        #extraDeckList.side-deck-grid { 
            display: grid; 
            grid-template-columns: repeat(auto-fill, minmax(var(--extra-deck-size), 1fr)); 
            gap: 4px; 
            align-content: start;
        }
        .dragging { 
            opacity: 0.2;
        }
        .placeholder {
            background: rgba(71, 85, 105, 0.5); /* slate-600/50 */
            border: 2px dashed #94a3b8; /* slate-400 */
            border-radius: 0.375rem; /* Match card rounding (rounded-md) */
            width: var(--card-size);
            aspect-ratio: 2.5 / 3.5; 
        }
        details > summary { list-style: none; }
        details > summary::-webkit-details-marker { display: none; }

        /* Resize handle styles */
        #resizeHandle {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(to right, transparent 0%, var(--color-border) 50%, transparent 100%);
            transition: background-color 0.2s ease;
        }
        
        #resizeHandle:hover {
            background: linear-gradient(to right, transparent 0%, var(--color-primary) 50%, transparent 100%);
        }
        
        #resizeHandle::before {
            content: '';
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 2px;
            height: 20px;
            background: var(--color-text-muted);
            border-radius: 1px;
        }
        
        #resizeHandle:hover::before {
            background: var(--color-primary);
        }
        
        /* Ensure proper flex behavior for the container */
        #deckBuilderContainer {
            min-height: 60vh;
        }
        
        /* Ensure deck sections maintain minimum widths and don't shrink */
        #deckGridContainer {
            flex-wrap: nowrap;
            overflow-x: hidden; /* Prevent horizontal overflow - sections are constrained to fit */
            max-width: 100%; /* Prevent container from growing beyond parent */
            width: 100%; /* Take full width of parent */
            box-sizing: border-box; /* Include padding in width calculation */
            contain: layout; /* Optimize containment */
        }
        
        #mainDeckSection, #sideDeckSection, #extraDeckSection {
            box-sizing: border-box; /* Include padding in width calculation */
        }
        
        /* Main deck grows to fill available space by default */
        #mainDeckSection {
            flex-grow: 1;
            flex-shrink: 1;
            min-width: 300px;
            max-width: 100%; /* Never exceed container */
        }
        
        /* Default widths for deck sections */
        #sideDeckSection, #extraDeckSection {
            width: 280px;
            min-width: 200px;
            max-width: 100%; /* Never exceed container */
            flex-shrink: 1;
            flex-grow: 0;
        }
        
        /* When database is visible, make deck sections more compact */
        #deckBuilderContainer.database-visible #deckGridContainer {
            min-width: 0; /* Allow container to shrink */
            flex-wrap: nowrap; /* Keep sections in a single row */
            max-width: 100%; /* Prevent overflow */
        }
        
        #deckBuilderContainer.database-visible #sideDeckSection,
        #deckBuilderContainer.database-visible #extraDeckSection {
            width: 50px !important; /* Force very small width when database is visible */
            min-width: 50px !important;
            max-width: 80px !important; /* Cap maximum width */
            flex-shrink: 1; /* Allow shrinking */
        }
        
        #deckBuilderContainer.database-visible #mainDeckSection {
            min-width: 80px !important; /* Force smaller main deck when database is visible */
            max-width: 120px !important; /* Cap maximum width */
            flex-shrink: 1; /* Allow shrinking */
        }
        
        /* Ensure the main container doesn't cause page overflow */
        #deckBuilderContainer {
            max-width: 100%;
            overflow-x: hidden;
        }
        
        /* Make deck builder section more flexible */
        #deckBuilderSection {
            min-width: 0; /* Allow it to shrink */
            max-width: 100%; /* Prevent overflow beyond parent */
            overflow: visible; /* Allow content to be visible, no scrollbars */
        }
        
        /* Ensure deck sections don't cause horizontal overflow */
        #mainDeckSection, #sideDeckSection, #extraDeckSection {
            overflow-x: hidden; /* Prevent horizontal scrolling */
        }
        
        /* Toggle button styles */
        #toggleExtraDeckBtn, #toggleSideDeckBtn, #toggleDatabaseBtn {
            transition: background-color 0.2s ease, color 0.2s ease, transform 0.2s ease;
        }
        
        /* Section transition styles */
        #extraDeckSection, #sideDeckSection, #cardDatabaseSection {
            transition: opacity 0.2s ease, transform 0.2s ease; /* avoid animating width/flex to prevent jitter */
        }
        
        #extraDeckSection.hidden, #sideDeckSection.hidden, #cardDatabaseSection.hidden {
            opacity: 0;
            transform: scale(0.95);
        }
        
        /* Deck resize handle styles */
        #mainSideResizeHandle, #sideExtraResizeHandle {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(to right, transparent 0%, var(--color-border) 50%, transparent 100%);
            transition: background-color 0.2s ease;
        }
        
        #mainSideResizeHandle:hover, #sideExtraResizeHandle:hover {
            background: linear-gradient(to right, transparent 0%, var(--color-primary) 50%, transparent 100%);
        }
        
        #mainSideResizeHandle::before, #sideExtraResizeHandle::before {
            content: '';
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 2px;
            height: 20px;
            background: var(--color-text-muted);
            border-radius: 1px;
        }
        
        #mainSideResizeHandle:hover::before, #sideExtraResizeHandle:hover::before {
            background: var(--color-primary);
        }
        
        /* Responsive behavior */
        @media (max-width: 1024px) {
            #deckBuilderContainer {
                flex-direction: column;
            }
            
            #resizeHandle {
                width: 100%;
                height: 8px;
                cursor: row-resize;
                background: linear-gradient(to bottom, transparent 0%, var(--color-border) 50%, transparent 100%);
            }
            
            #resizeHandle::before {
                width: 20px;
                height: 2px;
            }
            
            #cardDatabaseSection {
                width: 100% !important;
                min-height: 40vh;
            }
        }

        @keyframes pop {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(0.9); }
        }
        .animate-pop {
            animation: pop 0.2s ease-in-out;
        }
        
        /* Aurora glow animation */
        @keyframes auroraGlow {
            0%, 100% {
                box-shadow: 
                    0 0 20px rgba(59, 130, 246, 0.4),
                    0 0 40px rgba(59, 130, 246, 0.3),
                    0 0 60px rgba(59, 130, 246, 0.2),
                    0 0 80px rgba(59, 130, 246, 0.1);
            }
            25% {
                box-shadow: 
                    0 0 25px rgba(96, 165, 250, 0.5),
                    0 0 50px rgba(59, 130, 246, 0.4),
                    0 0 75px rgba(37, 99, 235, 0.3),
                    0 0 100px rgba(29, 78, 216, 0.2);
            }
            50% {
                box-shadow: 
                    0 0 30px rgba(147, 197, 253, 0.6),
                    0 0 60px rgba(96, 165, 250, 0.5),
                    0 0 90px rgba(59, 130, 246, 0.4),
                    0 0 120px rgba(37, 99, 235, 0.3);
            }
            75% {
                box-shadow: 
                    0 0 25px rgba(96, 165, 250, 0.5),
                    0 0 50px rgba(59, 130, 246, 0.4),
                    0 0 75px rgba(37, 99, 235, 0.3),
                    0 0 100px rgba(29, 78, 216, 0.2);
            }
        }
        
        /* Focus mode overlay */
        .selection-focus-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(8px);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }
        
        .selection-focus-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }
        
        .selection-focus-container {
            display: flex;
            flex-direction: column;
            gap: 2rem;
            justify-content: center;
            align-items: center;
            max-width: 90vw;
            max-height: 90vh;
            padding: 2rem;
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }
        
        .selection-focus-overlay.active .selection-focus-container {
            transform: scale(1);
        }
        
        .focus-mode-instructions {
            text-align: center;
            color: #94a3b8;
            font-size: 0.85rem;
            margin-top: 1.5rem;
            opacity: 0.6;
            transition: opacity 0.2s ease;
        }
        
        .focus-mode-instructions:hover {
            opacity: 1;
        }
        
        .focus-mode-instructions p {
            margin: 0;
        }
        
        .focus-mode-instructions kbd {
            display: inline-block;
            padding: 0.2rem 0.4rem;
            background: rgba(71, 85, 105, 0.3);
            border: 1px solid rgba(100, 116, 139, 0.4);
            border-radius: 0.25rem;
            font-family: monospace;
            font-size: 0.75rem;
            font-weight: normal;
            color: #cbd5e1;
        }
        
        .focus-mode-cards-wrapper {
            display: flex;
            gap: 2rem;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            max-width: 100%;
        }
        
        .focus-mode-card {
            width: 300px !important;
            height: auto !important;
            aspect-ratio: 2.5 / 3.5 !important;
            border-radius: 1rem !important;
            overflow: hidden !important;
            box-shadow: 
                0 0 40px rgba(59, 130, 246, 0.6),
                0 0 80px rgba(59, 130, 246, 0.4),
                0 20px 60px rgba(0, 0, 0, 0.5) !important;
            animation: focusCardGlow 3s ease-in-out infinite;
            transition: transform 0.2s ease;
        }
        
        .focus-mode-card:hover {
            transform: scale(1.05);
        }
        
        @keyframes focusCardGlow {
            0%, 100% {
                box-shadow: 
                    0 0 40px rgba(59, 130, 246, 0.6),
                    0 0 80px rgba(59, 130, 246, 0.4),
                    0 20px 60px rgba(0, 0, 0, 0.5);
            }
            50% {
                box-shadow: 
                    0 0 50px rgba(147, 197, 253, 0.8),
                    0 0 100px rgba(96, 165, 250, 0.6),
                    0 20px 60px rgba(0, 0, 0, 0.5);
            }
        }
        
        /* Card selection styles */
        .deck-grid > div, .side-deck-grid > div {
            position: relative;
            transition: transform 0.2s ease, z-index 0s 0s;
        }
        
        .deck-grid > div.card-selected, .side-deck-grid > div.card-selected {
            transform: scale(1.1) translateY(-4px);
            z-index: 10;
            transition: transform 0.2s ease, z-index 0s 0s;
            animation: auroraGlow 3s ease-in-out infinite;
        }
        
        .deck-grid > div.card-selected::before, .side-deck-grid > div.card-selected::before {
            content: '';
            position: absolute;
            inset: -4px;
            border: 3px solid #3b82f6;
            border-radius: 0.5rem;
            pointer-events: none;
            box-shadow: 
                0 0 20px rgba(59, 130, 246, 0.5), 
                0 4px 12px rgba(0, 0, 0, 0.3),
                inset 0 0 15px rgba(147, 197, 253, 0.3);
        }
        
        .deck-grid > div.card-selected::after, .side-deck-grid > div.card-selected::after {
            content: '';
            position: absolute;
            inset: -6px;
            border: 2px solid transparent;
            border-radius: 0.5rem;
            background: 
                linear-gradient(135deg, #3b82f6 0%, #3b82f6 25%, transparent 25%, transparent 75%, #3b82f6 75%, #3b82f6 100%),
                linear-gradient(45deg, #3b82f6 0%, #3b82f6 25%, transparent 25%, transparent 75%, #3b82f6 75%, #3b82f6 100%);
            background-size: 8px 8px;
            background-position: 0 0, 0 4px;
            -webkit-mask: 
                linear-gradient(#fff 0 0) content-box, 
                linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask: 
                linear-gradient(#fff 0 0) content-box, 
                linear-gradient(#fff 0 0);
            mask-composite: exclude;
            pointer-events: none;
            opacity: 0.6;
        }
        
        /* Siding selection overlay */
        .siding-selection-overlay {
            position: absolute;
            top: 4px;
            right: 4px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
        }
        /* Chibi Animation Styles */
        .chibi-animated {
            position: fixed;
            z-index: 1000;
            cursor: pointer;
            will-change: transform;
            transform-style: preserve-3d;
            backface-visibility: hidden;
            transition: opacity 0.5s ease-in-out;
        }
        .chibi-animated:hover {
            filter: brightness(1.05);
        }
        
        /* Dust cloud particles */
        .chibi-dust {
            position: fixed;
            z-index: 998;
            width: 4px;
            height: 4px;
            background-color: rgba(139, 69, 19, 0.6);
            border-radius: 50%;
            pointer-events: none;
            animation: dust-fade 1s ease-out forwards;
        }
        
        @keyframes dust-fade {
            0% {
                opacity: 1;
                transform: scale(1);
            }
            100% {
                opacity: 0;
                transform: scale(0.3);
            }
        }
        
        /* Breathing idle animation - avoid transform to not override JS */
        @keyframes chibi-breathe {
            0%, 100% {
                filter: brightness(1);
            }
            50% {
                filter: brightness(1.05);
            }
        }
        
        .chibi-idle {
            animation: chibi-breathe 3s ease-in-out infinite;
        }
        
        /* Effort marks (sweat drops) */
        .chibi-effort-mark {
            position: fixed;
            z-index: 999;
            width: 6px;
            height: 8px;
            background: linear-gradient(45deg, rgba(135, 206, 235, 0.8), rgba(70, 130, 180, 0.6));
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
            pointer-events: none;
            animation: effort-drop 1s ease-out forwards;
        }
        
        @keyframes effort-drop {
            0% {
                opacity: 1;
                transform: scale(0.5) translateY(0);
            }
            100% {
                opacity: 0;
                transform: scale(1) translateY(20px);
            }
        }
        
        /* Action lines for manga-style effect */
        .chibi-action-line {
            position: fixed;
            z-index: 999;
            height: 2px;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.8), transparent);
            pointer-events: none;
            animation: action-line-flash 0.3s ease-out forwards;
        }
        
        @keyframes action-line-flash {
            0% {
                opacity: 0;
                transform: scaleX(0);
            }
            50% {
                opacity: 1;
                transform: scaleX(1);
            }
            100% {
                opacity: 0;
                transform: scaleX(0);
            }
        }
        .chibi-heart {
            position: fixed;
            z-index: 999;
            width: 10px;
            height: 10px;
            opacity: 0;
            pointer-events: none;
            animation: fall-and-sparkle 4s ease-out forwards;
        }
        .chibi-confetti {
            position: fixed;
            z-index: 1600;
            top: 0;
            left: 0;
            pointer-events: none;
            width: 10px;
            height: 10px;
        }
        .chibi-coin {
            position: fixed;
            z-index: 1600;
            pointer-events: none;
            width: 20px;
            height: 20px;
            background-color: #FFD700;
            border: 2px solid #DAA520;
            border-radius: 50%;
        }
        .chibi-diamond {
            position: fixed;
            z-index: 1601; /* Ensure it's on top */
            pointer-events: none;
            width: 35px;
            height: 35px;
            font-size: 28px;
            text-align: center;
            line-height: 35px;
            animation: diamond-glow 2s infinite alternate, diamond-float 3s ease-in-out infinite;
            will-change: transform; /* Performance boost */
            filter: drop-shadow(0 0 8px rgba(0, 255, 255, 0.6));
        }
        @keyframes diamond-glow {
            from {
                filter: drop-shadow(0 0 5px rgba(0, 255, 255, 0.5));
            }
            to {
                filter: drop-shadow(0 0 15px rgba(0, 255, 255, 0.8));
            }
        }
        @keyframes diamond-float {
            0%, 100% {
                transform: translateY(0px) scale(1);
            }
            50% {
                transform: translateY(-3px) scale(1.05);
            }
        }
        .chibi-super-diamond {
            position: fixed;
            z-index: 1002; /* Even higher than regular diamonds */
            pointer-events: none;
            width: 200px; /* 2x smaller than before (400px / 2) */
            height: 200px;
            font-size: 160px; /* 2x smaller text (320px / 2) */
            text-align: center;
            line-height: 200px;
            animation: super-diamond-glow 2s infinite alternate, super-diamond-float 3s ease-in-out infinite;
            will-change: transform;
            filter: drop-shadow(0 0 8px rgba(255, 215, 0, 0.8)) drop-shadow(0 0 15px rgba(255, 100, 200, 0.6)) drop-shadow(0 0 20px rgba(0, 200, 255, 0.4));
        }
        @keyframes super-diamond-glow {
            from {
                filter: drop-shadow(0 0 6px rgba(255, 215, 0, 0.6)) drop-shadow(0 0 12px rgba(255, 100, 200, 0.4)) drop-shadow(0 0 18px rgba(0, 200, 255, 0.3));
            }
            to {
                filter: drop-shadow(0 0 12px rgba(255, 215, 0, 0.9)) drop-shadow(0 0 20px rgba(255, 100, 200, 0.7)) drop-shadow(0 0 25px rgba(0, 200, 255, 0.5));
            }
        }
        @keyframes super-diamond-float {
            0%, 100% {
                transform: translateY(0px) scale(1) rotate(0deg);
            }
            25% {
                transform: translateY(-3px) scale(1.02) rotate(2deg);
            }
            50% {
                transform: translateY(-5px) scale(1.05) rotate(0deg);
            }
            75% {
                transform: translateY(-3px) scale(1.02) rotate(-2deg);
            }
        }
        @keyframes tooltip-fade-in {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }
        @keyframes tooltip-fade-out {
            from {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
            to {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
            }
        }
        .chibi-sparkle {
            position: fixed;
            z-index: 998;
            pointer-events: none;
            width: 8px;
            height: 8px;
            background-color: white;
            border-radius: 50%;
            animation: sparkle-anim 1s ease-out forwards;
        }
        @keyframes sparkle-anim {
            0% { transform: scale(0); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.8; }
            100% { transform: scale(0); opacity: 0; }
        }
        .chibi-trap {
            position: fixed;
            z-index: 999;
            pointer-events: none;
            width: 60px;
            height: auto;
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }
        /* Helper chibi clones */
        .chibi-clone {
            position: fixed;
            will-change: transform;
            pointer-events: none;
            filter: drop-shadow(0 6px 14px rgba(0,0,0,.35));
        }
        /* Poof clouds */
        .poof-cloud {
            position: fixed;
            width: 18px;
            height: 18px;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.95), rgba(255,255,255,.7) 60%, rgba(255,255,255,0));
            border-radius: 50%;
            pointer-events: none;
            z-index: 13002;
            animation: poof-cloud-fade 600ms ease-out forwards;
        }
        @keyframes poof-cloud-fade {
            0% { opacity: 1; transform: translate(-2px, -2px) scale(.7); }
            60% { opacity: .85; transform: translate(0, 0) scale(1.1); }
            100% { opacity: 0; transform: translate(6px, 6px) scale(0.4); }
        }
        .chibi-wiggle {
            animation: wiggle 1s ease-in-out;
        }
        @keyframes wiggle {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(-5deg); }
            75% { transform: rotate(5deg); }
        }
        
        /* Autocomplete selected state */
        .autocomplete-item.selected {
            background-color: var(--color-primary);
            color: white;
        }
        
        /* Hide easter egg button by default */
        #editEasterEggBtn {
            display: none;
        }
        
        /* Show easter egg button when easter egg is active */
        .easter-egg-active #editEasterEggBtn {
            display: inline-flex;
        }
        
        /* IMMERSION MODE STYLES */
        #immersionModeOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 10000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.8s ease-in-out;
        }
        
        #immersionModeOverlay.active {
            opacity: 1;
            pointer-events: all;
        }
        
        /* Aurora Background */
        .immersion-aurora-bg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at var(--aurora-x, 50%) var(--aurora-y, 50%), 
                rgba(59, 130, 246, 0.15) 0%, 
                rgba(139, 92, 246, 0.1) 25%, 
                rgba(16, 185, 129, 0.08) 50%, 
                transparent 70%);
            animation: aurora-shift 8s ease-in-out infinite alternate;
        }
        
        .immersion-aurora-bg-2 {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at calc(100% - var(--aurora-x, 50%)) calc(100% - var(--aurora-y, 50%)), 
                rgba(236, 72, 153, 0.12) 0%, 
                rgba(59, 130, 246, 0.08) 30%, 
                transparent 60%);
            animation: aurora-shift-reverse 10s ease-in-out infinite alternate;
        }
        
        @keyframes aurora-shift {
            0% { 
                filter: hue-rotate(0deg) brightness(1);
                transform: scale(1) rotate(0deg);
            }
            50% { 
                filter: hue-rotate(15deg) brightness(1.05);
                transform: scale(1.05) rotate(1deg);
            }
            100% { 
                filter: hue-rotate(0deg) brightness(1);
                transform: scale(1) rotate(0deg);
            }
        }
        
        @keyframes aurora-shift-reverse {
            0% { 
                filter: hue-rotate(0deg) brightness(0.95);
                transform: scale(1.03) rotate(0deg);
            }
            50% { 
                filter: hue-rotate(-10deg) brightness(1.02);
                transform: scale(0.97) rotate(-1deg);
            }
            100% { 
                filter: hue-rotate(0deg) brightness(0.95);
                transform: scale(1.03) rotate(0deg);
            }
        }
        
        /* Dimmed overlay */
        .immersion-dim {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000000;
            backdrop-filter: blur(4px);
        }
        
        /* Main container - mimics deck builder layout */
        .immersion-main-container {
            perspective: 2000px;
            perspective-origin: 50% 50%;
            justify-content: center;
            align-items: center;
        }
        
        /* Individual immersion card - matches homepage exactly */
        .immersion-card {
            position: relative;
            width: var(--main-deck-size, 68px);
            height: calc(var(--main-deck-size, 68px) * 1.4); /* Maintain card aspect ratio */
            border-radius: 8px;
            overflow: hidden;
            cursor: grab;
            transform-style: preserve-3d;
            will-change: transform;
            opacity: 0;
            transform: scale(0.3) translateZ(-200px);
            transition: transform 0.8s cubic-bezier(0.16, 1, 0.3, 1), 
                        opacity 0.8s ease,
                        box-shadow 0.6s ease,
                        filter 0.4s ease;
        }
        
        .immersion-card.emerged {
            opacity: 1;
            transform: scale(1) translateZ(0px);
        }
        
        .immersion-card:active {
            cursor: grabbing;
        }
        
        .immersion-card.dragging {
            opacity: 0.5 !important;
            filter: brightness(1.3);
            animation: none !important;
        }
        
        .immersion-card:hover {
            transform: scale(1.1) translateZ(50px) !important;
            z-index: 100;
            filter: brightness(1.15) saturate(1.08);
            transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1);
        }
        
        .immersion-card:hover img {
            box-shadow: 
                0 0 40px rgba(59, 130, 246, 0.7),
                0 20px 60px rgba(0, 0, 0, 0.8),
                0 0 20px rgba(255, 255, 255, 0.3);
        }
        
        .immersion-card img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 12px;
            box-shadow: 
                0 0 30px rgba(59, 130, 246, 0.4),
                0 10px 40px rgba(0, 0, 0, 0.6);
            transition: box-shadow 0.3s ease;
        }
        
        /* Floating animation - extremely subtle and smooth */
        @keyframes immersion-float {
            0% {
                transform: translateY(0px);
            }
            25% {
                transform: translateY(-2px);
            }
            50% {
                transform: translateY(-6px);
            }
            75% {
                transform: translateY(-2px);
            }
            100% {
                transform: translateY(0px);
            }
        }
        
        
        
        /* Aura glow effect */
        .immersion-card::before {
            content: '';
            position: absolute;
            inset: -12px;
            border-radius: 20px;
            background: radial-gradient(ellipse at center, 
                rgba(59, 130, 246, 0.4) 0%, 
                rgba(139, 92, 246, 0.25) 30%, 
                rgba(16, 185, 129, 0.15) 50%,
                transparent 75%);
            opacity: 0.5;
            z-index: -1;
            animation: aura-pulse 5s ease-in-out infinite;
            pointer-events: none;
            filter: blur(8px);
        }
        
        .immersion-card:hover::before {
            opacity: 0.8;
            filter: blur(12px);
            animation: aura-pulse-fast 3s ease-in-out infinite;
        }
        
        @keyframes aura-pulse-fast {
            0%, 100% { 
                opacity: 0.7;
                transform: scale(1);
            }
            50% { 
                opacity: 1;
                transform: scale(1.15);
            }
        }
        
        @keyframes aura-pulse {
            0%, 100% { 
                opacity: 0.3;
                transform: scale(0.98);
            }
            50% { 
                opacity: 0.5;
                transform: scale(1.02);
            }
        }
        
        /* Exit button */
        .immersion-exit-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            background: rgba(30, 30, 40, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            opacity: 0;
            transform: scale(0.5);
            transition: opacity 0.3s ease, transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), 
                        background-color 0.2s ease;
            z-index: 10001;
            pointer-events: all;
        }
        
        .immersion-exit-btn.visible {
            opacity: 1;
            transform: scale(1);
        }
        
        .immersion-exit-btn:hover {
            background: rgba(220, 38, 38, 0.9);
            border-color: rgba(255, 255, 255, 0.6);
            transform: scale(1.1);
        }
        
        .immersion-exit-btn svg {
            width: 30px;
            height: 30px;
            stroke: white;
            stroke-width: 3;
        }
        
        /* Exit hitbox (invisible trigger area) */
        .immersion-exit-hitbox {
            position: fixed;
            top: 0;
            right: 0;
            width: 120px;
            height: 120px;
            z-index: 10001;
            pointer-events: all;
        }
        
        /* Scale slider hitbox */
        .immersion-scale-hitbox {
            position: fixed;
            bottom: 0;
            right: 0;
            width: 150px;
            height: 150px;
            z-index: 10001;
            pointer-events: all;
        }
        
        /* Scale slider */
        .immersion-scale-slider {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(30, 30, 40, 0.9);
            border: 2px solid rgba(212, 175, 55, 0.4);
            border-radius: 12px;
            padding: 16px 20px;
            z-index: 10001;
            pointer-events: all;
            opacity: 0;
            transform: scale(0.8) translateY(10px);
            transition: opacity 0.3s ease, transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        .immersion-scale-slider.visible {
            opacity: 1;
            transform: scale(1) translateY(0);
        }
        
        .immersion-scale-slider input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            cursor: pointer;
        }
        
        .immersion-scale-slider input[type="range"]::-webkit-slider-track {
            background: rgba(71, 85, 105, 0.8);
            height: 6px;
            border-radius: 3px;
        }
        
        .immersion-scale-slider input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            background: linear-gradient(135deg, #D4AF37, #FFD700);
            height: 16px;
            width: 16px;
            border-radius: 50%;
            margin-top: -5px;
            box-shadow: 0 0 10px rgba(212, 175, 55, 0.6);
            border: 2px solid #8B7500;
        }
        
        .immersion-scale-slider input[type="range"]::-moz-range-track {
            background: rgba(71, 85, 105, 0.8);
            height: 6px;
            border-radius: 3px;
        }
        
        .immersion-scale-slider input[type="range"]::-moz-range-thumb {
            background: linear-gradient(135deg, #D4AF37, #FFD700);
            height: 16px;
            width: 16px;
            border-radius: 50%;
            border: 2px solid #8B7500;
            box-shadow: 0 0 10px rgba(212, 175, 55, 0.6);
        }
        
        /* Section labels */
        .immersion-section-label {
            position: absolute;
            font-size: 1.5rem;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 
                0 2px 10px rgba(0, 0, 0, 0.8),
                0 0 20px rgba(59, 130, 246, 0.4);
            opacity: 0;
            transform: translateX(-50%) translateY(-10px) scale(0.9);
            transition: 
                opacity 1s ease 1.5s,
                transform 1s cubic-bezier(0.16, 1, 0.3, 1) 1.5s;
            pointer-events: none;
            z-index: 9999;
            letter-spacing: 0.05em;
        }
        
        #immersionModeOverlay.active .immersion-section-label {
            opacity: 1;
            transform: translateX(-50%) translateY(0) scale(1);
        }
        
        /* Deck sections */
        .immersion-deck-section {
            border-radius: 16px;
            background: transparent;
            border: none;
            transition: transform 0.1s ease-out, opacity 0.3s ease-out;
            transform-style: preserve-3d;
            backface-visibility: hidden;
            will-change: transform, opacity;
        }
        
        /* Database section styling */
        .immersion-deck-section[data-section-type="database"] {
            background: transparent;
            border: none;
        }
        
        .immersion-deck-section[data-section-type="database"] .immersion-section-label {
            color: rgba(196, 181, 253, 1);
        }
        
        /* Database drop zone highlight */
        .immersion-card.database-card {
            cursor: pointer;
        }
        
        .immersion-card.database-card::before {
            background: radial-gradient(ellipse at center, 
                rgba(139, 92, 246, 0.4) 0%, 
                rgba(236, 72, 153, 0.25) 40%, 
                transparent 70%);
        }
        
        .immersion-deck-section.drop-target {
            background: rgba(59, 130, 246, 0.25);
            border: 2px dashed rgba(59, 130, 246, 0.8);
            box-shadow: 
                0 0 30px rgba(59, 130, 246, 0.4),
                inset 0 0 20px rgba(59, 130, 246, 0.2);
        }
        
        /* Placeholder styling */
        .immersion-placeholder {
            background: linear-gradient(135deg, 
                rgba(59, 130, 246, 0.2) 0%, 
                rgba(139, 92, 246, 0.2) 50%, 
                rgba(59, 130, 246, 0.2) 100%);
            border: 2px dashed rgba(59, 130, 246, 0.8);
            animation: placeholder-pulse 1s ease-in-out infinite;
        }
        
        @keyframes placeholder-pulse {
            0%, 100% { 
                border-color: rgba(59, 130, 246, 0.6);
                box-shadow: 0 0 10px rgba(59, 130, 246, 0.3);
            }
            50% { 
                border-color: rgba(59, 130, 246, 1);
                box-shadow: 0 0 20px rgba(59, 130, 246, 0.6);
            }
        }
        
        /* Scrollbar for immersion sections - hidden */
        .immersion-deck-section {
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* Internet Explorer 10+ */
        }
        
        .immersion-deck-section::-webkit-scrollbar {
            width: 0px;
            background: transparent;
        }
        
        .immersion-deck-section::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .immersion-deck-section::-webkit-scrollbar-thumb {
            background: transparent;
        }
        
        .immersion-deck-section::-webkit-scrollbar-thumb:hover {
            background: transparent;
        }
        
        /* Immersion mode button active state */
        #immersionModeBtn.active {
            animation: millennium-glow 2s ease-in-out infinite;
        }
        
        @keyframes millennium-glow {
            0%, 100% {
                box-shadow: 0 0 10px rgba(212, 175, 55, 0.4);
            }
            50% {
                box-shadow: 0 0 25px rgba(212, 175, 55, 0.8), 0 0 40px rgba(212, 175, 55, 0.4);
            }
        }
        
        /* Ripple effect animation */
        @keyframes ripple-expand {
            0% {
                width: 10px;
                height: 10px;
                opacity: 1;
            }
            100% {
                width: 100px;
                height: 100px;
                opacity: 0;
            }
        }
    </style>
</head>
<body class="min-h-screen">
    <div id="pdf-staging-area" class="fixed -left-[9999px] top-0 w-[800px] p-8 bg-white text-black font-sans"></div>

    <div id="loadingOverlay" class="fixed inset-0 bg-black/70 z-50 flex items-center justify-center hidden"><div class="animate-spin rounded-full h-16 w-16 border-t-2 border-b-2 border-[var(--color-primary)]"></div></div>
    <div id="messageModal" class="fixed inset-0 bg-black/60 z-40 flex items-center justify-center hidden"><div class="bg-[var(--color-surface-1)] rounded-lg shadow-xl p-6 w-full max-w-sm mx-4"><p id="messageModalText" class="text-center text-lg mb-4"></p><button id="messageModalClose" class="w-full bg-[var(--color-primary)] hover:bg-[var(--color-primary-hover)] text-white font-bold py-2 px-4 rounded-lg transition-colors">OK</button></div></div>
    <div id="confirmModal" class="fixed inset-0 bg-black/60 z-40 flex items-center justify-center hidden"><div class="bg-[var(--color-surface-1)] rounded-lg shadow-xl p-6 w-full max-w-sm mx-4"><p id="confirmModalText" class="text-center text-lg mb-4"></p><div class="flex gap-4"><button id="confirmModalCancel" class="w-full bg-slate-600 hover:bg-slate-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">Cancel</button><button id="confirmModalConfirm" class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">Confirm</button></div></div></div>
    <div id="searchResultsModal" class="fixed inset-0 bg-black/60 z-40 flex items-center justify-center hidden"><div class="bg-[var(--color-surface-1)] rounded-lg shadow-xl p-6 w-full max-w-md mx-4 flex flex-col"><div class="flex justify-between items-center mb-4"><h3 class="text-xl font-semibold text-white">Card Search Results</h3><button id="searchResultsClose" class="text-slate-400 hover:text-white text-2xl font-bold">&times;</button></div><div id="searchResultsList" class="space-y-2 overflow-y-auto max-h-[60vh] pr-2"></div></div></div>
    
    <div id="searchDeckModal" class="fixed inset-0 bg-black/60 z-40 flex items-center justify-center hidden">
        <div class="bg-[var(--color-surface-1)] rounded-lg shadow-xl p-6 w-full max-w-md mx-4 flex flex-col">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-semibold text-white">Search Your Deck</h3>
                <button id="searchDeckModalClose" class="text-slate-400 hover:text-white text-2xl font-bold">&times;</button>
            </div>
            <div id="searchDeckModalList" class="space-y-2 overflow-y-auto max-h-[60vh] pr-2">
                <!-- Search results will be populated here -->
            </div>
        </div>
    </div>

    <div id="sidingPatternModal" class="fixed inset-0 bg-black/60 z-40 flex items-center justify-center hidden">
        <div class="bg-[var(--color-surface-1)] rounded-lg shadow-xl p-6 w-full max-w-4xl mx-4 flex flex-col max-h-[90vh]">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-semibold text-white">Siding Pattern Editor</h3>
                <button id="sidingPatternModalClose" class="text-slate-400 hover:text-white text-2xl font-bold">&times;</button>
            </div>
            <!-- This is a new div to hold temporary siding controls, which will be shown/hidden by JS -->
            <div id="siding-temp-controls" class="hidden text-center mb-2">
                <button id="saveTempSidingPatternBtn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md">Use this Siding for Simulation</button>
            </div>
            <p class="text-xs text-[var(--color-text-muted)] mb-2">Left-click to cycle # of copies. Right-click to deselect all copies of a card.</p>
            <div class="grid grid-cols-2 gap-4 flex-grow overflow-y-auto">
                <div><h4 class="text-lg font-semibold text-center mb-2">Main Deck (Side Out)</h4><div id="sidingPatternMainDeck" class="p-2 bg-black/20 rounded-lg space-y-1 h-full overflow-y-auto"></div></div>
                <div><h4 class="text-lg font-semibold text-center mb-2">Side Deck (Side In)</h4><div id="sidingPatternSideDeck" class="p-2 bg-black/20 rounded-lg space-y-1 h-full overflow-y-auto"></div></div>
            </div>
            <div id="sidingSelectedCount" class="text-center my-2 font-medium text-amber-400">Siding out 0, Siding in 0</div>
            <div class="mt-4 border-t border-slate-700 pt-4 space-y-4">
                <div id="siding-permanent-controls" class="grid md:grid-cols-2 gap-4">
                    <div>
                        <h4 class="font-semibold mb-2">Save New Pattern</h4>
                        <div class="flex gap-2"><input type="text" id="sidingPatternNameInput" placeholder="Pattern Name (e.g., Vs. Fire)" class="flex-grow bg-slate-700 border border-[var(--color-border)] rounded-md px-3 py-2"><button id="saveSidingPatternBtn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-3 rounded-md">Save</button></div>
                    </div>
                     <div>
                        <h4 class="font-semibold mb-2">Saved Patterns</h4>
                        <div id="sidingPatternList" class="space-y-2 max-h-32 overflow-y-auto"></div>
                    </div>
                    <div class="grid md:grid-cols-2 gap-4">
                         <button id="exportSidingPatternsBtn" class="w-full bg-slate-600 hover:bg-slate-700 font-bold py-2 px-3 rounded-md" title="Export all siding patterns for this deck to a .json file.">Export All Patterns</button>
                        <label for="importSidingPatternsInput" class="w-full text-center bg-slate-600 hover:bg-slate-700 font-bold py-2 px-3 rounded-md cursor-pointer" title="Import siding patterns from a .json file. This will merge with existing patterns.">Import Patterns</label>
                        <input type="file" id="importSidingPatternsInput" class="hidden" accept=".json">
                    </div>
                </div>
            </div>
        </div>
    </div>
    <!-- API Key Modal -->
    <div id="apiKeyModal" class="fixed inset-0 bg-black/60 z-50 flex items-center justify-center hidden">
        <div class="bg-[var(--color-surface-1)] rounded-lg shadow-xl p-6 w-full max-w-md mx-4">
            <div class="flex justify-between items-center mb-4"><h3 class="text-xl font-semibold">Enter Gemini API Key</h3><button id="apiKeyModalClose" class="text-slate-400 hover:text-white text-2xl font-bold">&times;</button></div>
            <p class="text-sm text-slate-400 mb-2">An API key is required for AI features. It is only stored for this session.</p>
            <input type="password" id="apiKeyInput" class="w-full bg-slate-800 border border-[var(--color-border)] rounded-md px-3 py-2 text-sm" placeholder="Enter your API key here">
            <button id="saveApiKeyBtn" class="mt-4 w-full bg-green-600 hover:bg-green-700 font-bold py-2 px-4 rounded-lg">Save and Continue</button>
        </div>
    </div>
    
    <!-- YDK File Management Modal -->
    <div id="ydkManagementModal" class="fixed inset-0 bg-black/60 z-40 flex items-center justify-center hidden">
        <div class="bg-[var(--color-surface-1)] rounded-lg shadow-xl p-6 w-full max-w-2xl mx-4 flex flex-col max-h-[80vh]">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-semibold text-white">Manage YDK Files</h3>
                <button id="ydkManagementModalClose" class="text-slate-400 hover:text-white text-2xl font-bold">&times;</button>
            </div>
            <div class="flex gap-2 mb-4">
                <button id="clearAllYDKFilesBtn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-3 rounded-md">Clear All</button>
                <button id="syncYDKFolderBtn" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-3 rounded-md">Sync Folder</button>
            </div>
            <div id="ydkFilesList" class="space-y-2 overflow-y-auto flex-1">
                <!-- YDK files will be listed here -->
            </div>
        </div>
    </div>
    
    <!-- Report Preview Modal -->
    <div id="reportPreviewModal" class="fixed inset-0 bg-black/60 z-40 flex items-center justify-center hidden">
        <div class="bg-[var(--color-surface-1)] rounded-lg shadow-xl w-full max-w-4xl h-[90vh] mx-4 flex flex-col">
            <div class="flex justify-between items-center p-4 border-b border-[var(--color-border)] flex-shrink-0">
                <h3 id="reportPreviewTitle" class="text-xl font-semibold text-white">Report Preview</h3>
                <button id="reportPreviewClose" class="text-slate-400 hover:text-white text-2xl font-bold">&times;</button>
            </div>
            <div class="flex-grow overflow-y-auto bg-white text-black p-6 font-sans" id="reportPreviewContent">
                <!-- Report HTML will be injected here -->
            </div>
            <div class="p-4 border-t border-[var(--color-border)] flex-shrink-0"><button id="reportPreviewDownload" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg">Download as PDF</button></div>
        </div>
    </div>

    <!-- Easter Egg Card Pool Modal -->
    <div id="easterEggModal" class="fixed inset-0 bg-black/60 z-40 flex items-center justify-center hidden">
        <div class="bg-[var(--color-surface-1)] rounded-lg shadow-xl p-6 w-full max-w-4xl mx-4 flex flex-col max-h-[90vh]">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-semibold text-white">Edit Easter Egg Card Pool</h3>
                <button id="easterEggModalClose" class="text-slate-400 hover:text-white text-2xl font-bold">&times;</button>
            </div>
            <div class="mb-4">
                <p class="text-sm text-[var(--color-text-muted)] mb-2">Customize which cards appear in the easter egg animation. Only trap cards are recommended.</p>
                <div class="relative flex gap-2 mb-4">
                    <div class="relative flex-grow">
                        <input type="text" id="easterEggSearchInput" placeholder="Search for cards to add..." class="w-full bg-slate-700 border border-[var(--color-border)] rounded-md px-3 py-2 focus:ring-2 focus:ring-[var(--color-primary)] focus:outline-none" autocomplete="off">
                        <div id="easterEggSearchResults" class="absolute left-0 right-0 top-full mt-1 bg-slate-800 border border-[var(--color-border)] rounded-md shadow-lg z-50 max-h-64 overflow-y-auto hidden"></div>
                    </div>
                    <button id="addEasterEggCardBtn" class="bg-[var(--color-primary)] hover:bg-[var(--color-primary-hover)] text-white font-bold py-2 px-4 rounded-md transition-colors whitespace-nowrap">Add Card</button>
                </div>
            </div>
            <div class="flex-grow overflow-y-auto">
                <h4 class="text-lg font-semibold text-center mb-2">Current Easter Egg Pool (<span id="easterEggCount">0</span> cards)</h4>
                <div id="easterEggPoolList" class="p-2 bg-black/20 rounded-lg space-y-1 h-full overflow-y-auto">
                    <!-- Easter egg cards will be listed here -->
                </div>
                <div class="mt-4 text-center">
                    <button id="clearEasterEggPoolBtn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-md">Clear All</button>
                </div>
            </div>
            <div class="mt-4 border-t border-slate-700 pt-4 flex gap-4">
                <button id="saveEasterEggPoolBtn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md">Save Changes</button>
                <button id="resetEasterEggPoolBtn" class="bg-orange-600 hover:bg-orange-700 text-white font-bold py-2 px-4 rounded-md">Reset to Default</button>
                <button id="cancelEasterEggModalBtn" class="bg-slate-600 hover:bg-slate-700 text-white font-bold py-2 px-4 rounded-md">Cancel</button>
            </div>
        </div>
    </div>
    
    <!-- Advanced Search Modal -->
    <div id="advancedSearchModal" class="hidden fixed inset-0 z-50 bg-black/80 backdrop-blur-sm">
        <div class="w-full h-full flex">
            <!-- Filter Sidebar -->
            <div class="w-80 bg-[var(--color-surface-1)] p-6 overflow-y-auto border-r border-[var(--color-border)] flex-shrink-0">
                <h3 class="text-2xl font-bold text-white mb-6">Filters</h3>
                
                <!-- Text Search -->
                <div class="mb-6">
                    <label class="block text-sm font-medium text-slate-300 mb-2">Name / Description</label>
                    <input type="text" id="advSearchTextInput" placeholder="Search text..." class="w-full bg-slate-700 border border-[var(--color-border)] rounded-md px-3 py-2 focus:ring-2 focus:ring-[var(--color-primary)] focus:outline-none text-sm">
                </div>
                
                <!-- Card Type -->
                <div class="mb-6">
                    <label class="block text-sm font-medium text-slate-300 mb-2">Card Type</label>
                    <select id="advSearchCardType" class="w-full bg-slate-700 border border-[var(--color-border)] rounded-md px-3 py-2 focus:ring-2 focus:ring-[var(--color-primary)] focus:outline-none text-sm">
                        <option value="">All Types</option>
                        <option value="monster">Monster</option>
                        <option value="spell">Spell</option>
                        <option value="trap">Trap</option>
                    </select>
                </div>
                
                <!-- Card Subtype -->
                <div class="mb-6">
                    <label class="block text-sm font-medium text-slate-300 mb-2">Subtype</label>
                    <select id="advSearchCardSubtype" class="w-full bg-slate-700 border border-[var(--color-border)] rounded-md px-3 py-2 focus:ring-2 focus:ring-[var(--color-primary)] focus:outline-none text-sm">
                        <option value="">All Subtypes</option>
                    </select>
                </div>
                
                <!-- Monster Type -->
                <div class="mb-6" id="advSearchMonsterTypeContainer">
                    <label class="block text-sm font-medium text-slate-300 mb-2">Monster Race</label>
                    <select id="advSearchMonsterType" class="w-full bg-slate-700 border border-[var(--color-border)] rounded-md px-3 py-2 focus:ring-2 focus:ring-[var(--color-primary)] focus:outline-none text-sm" multiple size="5">
                        <option value="Warrior">Warrior</option>
                        <option value="Spellcaster">Spellcaster</option>
                        <option value="Dragon">Dragon</option>
                        <option value="Fiend">Fiend</option>
                        <option value="Zombie">Zombie</option>
                        <option value="Machine">Machine</option>
                        <option value="Aqua">Aqua</option>
                        <option value="Pyro">Pyro</option>
                        <option value="Rock">Rock</option>
                        <option value="Winged Beast">Winged Beast</option>
                        <option value="Plant">Plant</option>
                        <option value="Insect">Insect</option>
                        <option value="Thunder">Thunder</option>
                        <option value="Beast">Beast</option>
                        <option value="Beast-Warrior">Beast-Warrior</option>
                        <option value="Dinosaur">Dinosaur</option>
                        <option value="Fish">Fish</option>
                        <option value="Sea Serpent">Sea Serpent</option>
                        <option value="Reptile">Reptile</option>
                        <option value="Psychic">Psychic</option>
                        <option value="Divine-Beast">Divine-Beast</option>
                        <option value="Creator God">Creator God</option>
                        <option value="Wyrm">Wyrm</option>
                        <option value="Cyberse">Cyberse</option>
                        <option value="Illusion">Illusion</option>
                    </select>
                    <p class="text-xs text-slate-400 mt-1">Hold Ctrl/Cmd to select multiple</p>
                </div>
                
                <!-- Attributes -->
                <div class="mb-6" id="advSearchAttributeContainerWrapper">
                    <label class="block text-sm font-medium text-slate-300 mb-2">Attribute</label>
                    <div id="advSearchAttributeContainer" class="flex flex-wrap gap-2">
                        <button data-attribute="DARK" class="px-3 py-1 rounded-full bg-slate-700 hover:bg-slate-600 text-sm border border-[var(--color-border)] transition-all">DARK</button>
                        <button data-attribute="LIGHT" class="px-3 py-1 rounded-full bg-slate-700 hover:bg-slate-600 text-sm border border-[var(--color-border)] transition-all">LIGHT</button>
                        <button data-attribute="WATER" class="px-3 py-1 rounded-full bg-slate-700 hover:bg-slate-600 text-sm border border-[var(--color-border)] transition-all">WATER</button>
                        <button data-attribute="FIRE" class="px-3 py-1 rounded-full bg-slate-700 hover:bg-slate-600 text-sm border border-[var(--color-border)] transition-all">FIRE</button>
                        <button data-attribute="EARTH" class="px-3 py-1 rounded-full bg-slate-700 hover:bg-slate-600 text-sm border border-[var(--color-border)] transition-all">EARTH</button>
                        <button data-attribute="WIND" class="px-3 py-1 rounded-full bg-slate-700 hover:bg-slate-600 text-sm border border-[var(--color-border)] transition-all">WIND</button>
                        <button data-attribute="DIVINE" class="px-3 py-1 rounded-full bg-slate-700 hover:bg-slate-600 text-sm border border-[var(--color-border)] transition-all">DIVINE</button>
                    </div>
                </div>
                
                <!-- Monster Subtypes -->
                <div class="mb-6" id="advSearchMonsterSubtypeContainerWrapper">
                    <label class="block text-sm font-medium text-slate-300 mb-2">Monster Abilities</label>
                    <div id="advSearchMonsterSubtypeContainer" class="space-y-2">
                        <label class="flex items-center"><input type="checkbox" value="Flip" class="mr-2"><span class="text-sm">Flip</span></label>
                        <label class="flex items-center"><input type="checkbox" value="Tuner" class="mr-2"><span class="text-sm">Tuner</span></label>
                        <label class="flex items-center"><input type="checkbox" value="Union" class="mr-2"><span class="text-sm">Union</span></label>
                        <label class="flex items-center"><input type="checkbox" value="Spirit" class="mr-2"><span class="text-sm">Spirit</span></label>
                        <label class="flex items-center"><input type="checkbox" value="Gemini" class="mr-2"><span class="text-sm">Gemini</span></label>
                        <label class="flex items-center"><input type="checkbox" value="Toon" class="mr-2"><span class="text-sm">Toon</span></label>
                    </div>
                </div>
                
                <!-- Level/Rank Range -->
                <div class="mb-6" id="advSearchLevelContainer">
                    <label class="block text-sm font-medium text-slate-300 mb-2">Level/Rank: <span id="advSearchLevelDisplay">0 - 12</span></label>
                    <div class="flex gap-2 items-center">
                        <input type="number" id="advSearchLevelMin" min="0" max="12" value="0" class="w-20 bg-slate-700 border border-[var(--color-border)] rounded-md px-2 py-1 text-sm">
                        <span class="text-slate-400">to</span>
                        <input type="number" id="advSearchLevelMax" min="0" max="12" value="12" class="w-20 bg-slate-700 border border-[var(--color-border)] rounded-md px-2 py-1 text-sm">
                    </div>
                </div>
                
                <!-- ATK Range -->
                <div class="mb-6" id="advSearchAtkContainer">
                    <label class="block text-sm font-medium text-slate-300 mb-2">ATK Range</label>
                    <div class="flex gap-2 items-center">
                        <input type="number" id="advSearchAtkMin" placeholder="Min" class="w-24 bg-slate-700 border border-[var(--color-border)] rounded-md px-2 py-1 text-sm">
                        <span class="text-slate-400">to</span>
                        <input type="number" id="advSearchAtkMax" placeholder="Max" class="w-24 bg-slate-700 border border-[var(--color-border)] rounded-md px-2 py-1 text-sm">
                    </div>
                </div>
                
                <!-- DEF Range -->
                <div class="mb-6" id="advSearchDefContainer">
                    <label class="block text-sm font-medium text-slate-300 mb-2">DEF Range</label>
                    <div class="flex gap-2 items-center">
                        <input type="number" id="advSearchDefMin" placeholder="Min" class="w-24 bg-slate-700 border border-[var(--color-border)] rounded-md px-2 py-1 text-sm">
                        <span class="text-slate-400">to</span>
                        <input type="number" id="advSearchDefMax" placeholder="Max" class="w-24 bg-slate-700 border border-[var(--color-border)] rounded-md px-2 py-1 text-sm">
                    </div>
                </div>
                
                <!-- Banlist Status -->
                <div class="mb-6">
                    <label class="block text-sm font-medium text-slate-300 mb-2">Banlist Status</label>
                    <div id="advSearchBanlistContainer" class="space-y-2">
                        <label class="flex items-center"><input type="checkbox" value="forbidden" class="mr-2"><span class="text-sm">Forbidden</span></label>
                        <label class="flex items-center"><input type="checkbox" value="limited" class="mr-2"><span class="text-sm">Limited</span></label>
                        <label class="flex items-center"><input type="checkbox" value="semi-limited" class="mr-2"><span class="text-sm">Semi-Limited</span></label>
                        <label class="flex items-center"><input type="checkbox" value="unlimited" class="mr-2"><span class="text-sm">Unlimited</span></label>
                    </div>
                </div>
                
                <!-- Sort Options -->
                <div class="mb-6">
                    <label class="block text-sm font-medium text-slate-300 mb-2">Sort By</label>
                    <select id="advSearchSortBy" class="w-full bg-slate-700 border border-[var(--color-border)] rounded-md px-3 py-2 focus:ring-2 focus:ring-[var(--color-primary)] focus:outline-none text-sm mb-2">
                        <option value="name">Alphabetical</option>
                        <option value="releaseDate">Release Date</option>
                    </select>
                    <select id="advSearchSortOrder" class="w-full bg-slate-700 border border-[var(--color-border)] rounded-md px-3 py-2 focus:ring-2 focus:ring-[var(--color-primary)] focus:outline-none text-sm">
                        <option value="asc">Ascending (A-Z / Oldest)</option>
                        <option value="desc">Descending (Z-A / Newest)</option>
                    </select>
                </div>
                
                <!-- Action Buttons -->
                <div class="space-y-2">
                    <button id="advSearchApplyBtn" class="w-full bg-[var(--color-primary)] hover:bg-[var(--color-primary-hover)] text-white font-bold py-2 px-4 rounded-md transition-colors">Apply Filters</button>
                    <button id="advSearchResetBtn" class="w-full bg-slate-600 hover:bg-slate-700 text-white font-bold py-2 px-4 rounded-md transition-colors">Reset Filters</button>
                    <button id="advSearchManageBanlistBtn" class="w-full bg-orange-600 hover:bg-orange-700 text-white font-bold py-2 px-4 rounded-md transition-colors">Manage Banlist</button>
                </div>
            </div>
            
            <!-- Results Panel -->
            <div class="flex-1 bg-[var(--color-surface)] p-6 overflow-hidden flex flex-col">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-2xl font-bold text-white">Search Results (<span id="advSearchResultsCount">0</span>)</h3>
                    <button id="advancedSearchModalClose" class="text-slate-400 hover:text-white text-3xl font-bold leading-none">&times;</button>
                </div>
                
                <!-- View Controls -->
                <div class="flex justify-between items-center mb-4">
                    <div class="flex items-center gap-4">
                        <button id="advSearchViewToggle" class="flex items-center gap-2 bg-slate-700 hover:bg-slate-600 px-3 py-2 rounded-md transition-colors text-sm">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z"></path></svg>
                            <span>Grid</span>
                        </button>
                        <button id="advSearchCardInfoToggle" class="bg-slate-700 hover:bg-slate-600 px-3 py-2 rounded-md transition-colors text-sm">Hide Info</button>
                    </div>
                    <div class="flex items-center gap-2">
                        <label class="text-sm text-slate-300">Per Page:</label>
                        <input type="range" id="advSearchPerPageSlider" min="25" max="200" step="25" value="50" class="w-32">
                        <span id="advSearchPerPageDisplay" class="text-sm font-medium text-slate-300 w-8">50</span>
                    </div>
                </div>
                
                <!-- Results Container -->
                <div id="advSearchResultsContainer" class="flex-1 overflow-y-auto pr-2 mb-4">
                    <p class="text-center text-slate-400 mt-20">Click "Apply Filters" to search</p>
                </div>
                
                <!-- Pagination -->
                <div id="advSearchPaginationContainer" class="flex justify-center items-center gap-4 pt-4 border-t border-[var(--color-border)]">
                    <button id="advSearchPrevPage" class="bg-slate-700 hover:bg-slate-600 px-4 py-2 rounded-md transition-colors disabled:opacity-50 disabled:cursor-not-allowed" disabled>Previous</button>
                    <span id="advSearchPageDisplay" class="text-sm font-medium">Page 1 of 1</span>
                    <button id="advSearchNextPage" class="bg-slate-700 hover:bg-slate-600 px-4 py-2 rounded-md transition-colors disabled:opacity-50 disabled:cursor-not-allowed" disabled>Next</button>
                </div>
            </div>
            
            <!-- Card Info Panel -->
            <div id="advSearchCardInfoPanel" class="w-96 bg-[var(--color-surface-1)] p-6 overflow-y-auto border-l border-[var(--color-border)] flex-shrink-0">
                <h3 class="text-2xl font-bold text-white mb-6">Card Info</h3>
                <div id="advSearchCardInfoContent" class="h-full">
                    <p class="text-center text-slate-400 mt-20">Hover over a card to see details</p>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Banlist Management Modal -->
    <div id="banlistModal" class="hidden fixed inset-0 z-50 bg-black/80 backdrop-blur-sm flex items-center justify-center">
        <div class="bg-[var(--color-surface-1)] rounded-lg shadow-xl p-6 w-full max-w-4xl mx-4 flex flex-col max-h-[90vh]">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-semibold text-white">Manage Custom Banlist</h3>
                <button id="banlistModalClose" class="text-slate-400 hover:text-white text-2xl font-bold">&times;</button>
            </div>
            <p class="text-sm text-slate-300 mb-4">Search for cards and assign them banlist statuses.</p>
            <div class="relative mb-4">
                <input type="text" id="banlistSearchInput" placeholder="Search for a card..." class="w-full bg-slate-700 border border-[var(--color-border)] rounded-md px-3 py-2 focus:ring-2 focus:ring-[var(--color-primary)] focus:outline-none">
            </div>
            <div id="banlistSearchResults" class="flex-1 overflow-y-auto mb-4 space-y-2 min-h-[400px]">
                <p class="text-center text-slate-400 mt-20">Search for cards to manage their banlist status</p>
            </div>
            <div class="flex justify-end gap-4 border-t border-[var(--color-border)] pt-4">
                <button id="banlistResetBtn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-md">Reset All</button>
                <button id="banlistSaveBtn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md">Save & Close</button>
            </div>
        </div>
    </div>

    <div class="container mx-auto p-4 md:p-6 lg:p-8">
        <header class="flex flex-wrap justify-between items-center mb-6 gap-4">
            <div class="flex items-center gap-4">
                <img id="chibi-logo" src="1000053898.png" alt="Logo" class="h-12 w-12 rounded-full object-cover cursor-pointer">
                <h1 class="text-3xl font-bold text-white cursor-pointer hover:text-[var(--color-primary)] transition-colors" id="headerTitle">kaihari's master tool</h1>
            </div>
            <div class="flex items-center gap-4">
                <button id="immersionModeBtn" class="bg-slate-700 hover:bg-slate-600 text-white p-2 rounded-md transition-colors" title="UNDER CONSTRUCTION">
                    <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none">
                        <!-- Upside down triangle -->
                        <path d="M12 20 L4 6 L20 6 Z" fill="#D4AF37" stroke="#8B7500" stroke-width="1.2"/>
                        <!-- Eye outline -->
                        <ellipse cx="12" cy="11" rx="3.5" ry="2.5" fill="#1a1a1a" stroke="#8B7500" stroke-width="0.8"/>
                        <!-- Pupil -->
                        <circle cx="12" cy="11" r="1.2" fill="#D4AF37"/>
                        <!-- Eye highlight -->
                        <circle cx="12.5" cy="10.5" r="0.5" fill="#FFE87C" opacity="0.8"/>
                    </svg>
                </button>
                <button id="fullscreenBtn" class="bg-slate-700 hover:bg-slate-600 text-white p-2 rounded-md transition-colors" title="Toggle Fullscreen">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"></path>
                    </svg>
                </button>
                <nav class="flex gap-2 p-1 bg-[var(--color-surface-1)] rounded-lg">
                <button id="navDeckBuilder" class="px-4 py-2 rounded-md text-sm font-semibold transition-colors hover:bg-[var(--color-primary-hover)]">Deckbuilder</button>
                <button id="navSimulator" class="px-4 py-2 rounded-md text-sm font-semibold transition-colors hover:bg-[var(--color-primary-hover)]">Simulator</button>
                <button id="navShootout" class="px-4 py-2 rounded-md text-sm font-semibold transition-colors hover:bg-[var(--color-primary-hover)]">Shootout</button>
                <button id="navAiTraining" class="px-4 py-2 rounded-md text-sm font-semibold transition-colors hover:bg-[var(--color-primary-hover)] online-feature">AI Training Mode</button>
                <button id="navOnlineMode" class="px-4 py-2 rounded-md text-sm font-semibold transition-colors bg-gray-500 text-gray-300 cursor-not-allowed opacity-50" title="Currently Unavailable" disabled>Online Mode</button>
            </nav>
            </div>
        </header>

        <main>
            <div id="deckBuilderView">
                <div id="deckBuilderContainer" class="flex gap-6 h-full">
                    <div id="cardDatabaseSection" class="bg-[var(--color-surface-1)] p-4 rounded-lg flex flex-col min-w-0 flex-shrink-0" style="width: 33.333%;"><h2 class="text-xl font-semibold mb-3">Card Database</h2><div class="flex flex-wrap items-center justify-between mb-2 gap-2"><button id="autocompleteModeToggle" class="text-xs bg-slate-700 hover:bg-slate-600 px-3 py-1.5 rounded-md transition-colors font-medium border border-[var(--color-border)] flex items-center gap-1"><svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.207A1 1 0 013 6.5V4z"></path></svg>Autocomplete: <span class="text-[var(--color-primary)]">DB</span></button><button id="editDbToggle" class="text-xs bg-slate-700 hover:bg-slate-600 px-3 py-1.5 rounded-md transition-colors font-medium border border-[var(--color-border)] flex items-center gap-1"><svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg>Edit DB</button><button id="viewToggleBtn" class="text-xs bg-slate-700 hover:bg-slate-600 px-3 py-1.5 rounded-md transition-colors font-medium border border-[var(--color-border)] flex items-center gap-1"><svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z"></path></svg>Grid</button><button id="resetDbBtn" class="text-xs bg-orange-600 hover:bg-orange-700 px-3 py-1.5 rounded-md transition-colors font-medium border border-[var(--color-border)] flex items-center gap-1" title="Reset database to only include cards currently in deck"><svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>Reset DB</button><button id="editEasterEggBtn" class="text-xs bg-purple-600 hover:bg-purple-700 px-3 py-1.5 rounded-md transition-colors font-medium border border-[var(--color-border)] flex items-center gap-1" title="Edit Easter Egg Card Pool"><svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.746 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"></path></svg>Edit Easter Egg</button></div><div id="gridSelectionControls" class="hidden flex items-center gap-2 mb-2"><button id="selectAllGridBtn" class="text-xs bg-blue-600 hover:bg-blue-700 px-3 py-1.5 rounded-md transition-colors font-medium">Select All</button><button id="clearSelectionGridBtn" class="text-xs bg-gray-600 hover:bg-gray-700 px-3 py-1.5 rounded-md transition-colors font-medium">Clear</button><button id="deleteSelectedGridBtn" class="text-xs bg-red-600 hover:bg-red-700 px-3 py-1.5 rounded-md transition-colors font-medium">Delete Selected (<span id="selectedCount">0</span>)</button></div><div class="flex justify-end mb-2"><button id="advancedSearchBtn" class="text-xs bg-blue-600 hover:bg-blue-700 px-3 py-1.5 rounded-md transition-colors font-medium border border-blue-500 flex items-center gap-1.5" title="Advanced Card Search"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.207A1 1 0 013 6.5V4z"></path></svg><span>Advanced Search</span></button></div><div class="flex flex-wrap gap-2 mb-3 relative"><input type="text" id="cardSearchInput" placeholder="Search for cards..." class="flex-grow min-w-[120px] bg-slate-700 border border-[var(--color-border)] rounded-md px-3 py-2 focus:ring-2 focus:ring-[var(--color-primary)] focus:outline-none" autocomplete="off"><div id="cardAutocompleteList" class="absolute left-0 right-0 top-full mt-1 bg-slate-800 border border-[var(--color-border)] rounded-md shadow-lg z-50 max-h-64 overflow-y-auto hidden"></div><button id="addCardBtn" class="bg-[var(--color-primary)] hover:bg-[var(--color-primary-hover)] text-white font-bold py-2 px-4 rounded-md transition-colors flex-shrink-0">Search</button></div><div id="cardDbList" class="space-y-2 overflow-y-auto pr-2 flex-grow"></div></div>
                    <div id="resizeHandle" class="w-2 bg-slate-600 hover:bg-slate-500 cursor-col-resize flex-shrink-0 transition-colors" title="Drag to resize panels"></div>
                    <div id="deckBuilderSection" class="bg-[var(--color-surface-1)] p-4 rounded-lg flex flex-col min-w-0 flex-grow">
                        <div class="flex flex-wrap items-center justify-between mb-1 gap-x-4 gap-y-2">
                            <h2 class="text-xl font-semibold">Deck Builder</h2>
                            <div class="flex items-center gap-4">
                                <div id="deckCountDisplay" class="text-sm font-medium text-[var(--color-text-muted)]">Main: 0 | Side: 0</div>
                                <div id="deckTypeCountsDisplay" class="text-sm font-medium text-[var(--color-text-muted)]">M: 0 | S: 0 | T: 0</div>
                            </div>
                        </div>
                        <div class="flex flex-wrap items-center justify-between mb-2 gap-x-4 gap-y-1">
                             <p class="text-xs text-[var(--color-text-muted)]">Right-click to remove. Drag & drop to reorder.</p>
                             <div class="flex items-center gap-2">
                                <button id="manageSidingBtn" class="text-xs bg-[var(--color-primary)] hover:bg-[var(--color-primary-hover)] font-semibold px-3 py-1 rounded-md" title="Create and manage siding strategies for this deck.">Manage Siding</button>
                                <button id="toggleSideDeckBtn" class="text-xs bg-slate-700 hover:bg-slate-600 font-semibold px-3 py-1 rounded-md transition-colors" title="Toggle Side Deck visibility">Hide Side</button>
                                <button id="toggleExtraDeckBtn" class="text-xs bg-slate-700 hover:bg-slate-600 font-semibold px-3 py-1 rounded-md transition-colors" title="Toggle Extra Deck visibility">Hide Extra</button>
                                <button id="toggleDatabaseBtn" class="text-xs bg-slate-700 hover:bg-slate-600 font-semibold px-3 py-1 rounded-md transition-colors" title="Toggle Card Database visibility">Hide DB</button>
                                <label for="deckScaleSlider" class="text-xs text-[var(--color-text-muted)]">Cards/Row</label>
                                <button id="scaleTargetBtn" class="text-xs bg-slate-600 hover:bg-slate-500 font-semibold px-2 py-1 rounded-md transition-colors" title="Click to cycle between Main, Side, and Extra deck">Main</button>
                                <input type="range" id="deckScaleSlider" min="1" max="15" step="1" value="8" class="w-24 h-1 bg-slate-600 rounded-lg appearance-none cursor-pointer" title="Set number of cards per row">
                                <span id="cardsPerRowDisplay" class="text-xs font-semibold text-[var(--color-primary)] min-w-[2rem] text-center">8</span>
                             </div>
                        </div>
                        <div class="flex items-center justify-between mb-2">
                            <div class="relative">
                                <button id="deckOptionsBtn" class="flex items-center gap-2 text-xs bg-slate-700 hover:bg-slate-600 font-semibold px-3 py-1 rounded-md transition-colors" title="Deck Options">
                                    <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path>
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
                                    </svg>
                                    Options
                                </button>
                                <div id="deckOptionsDropdown" class="hidden absolute top-full left-0 mt-1 w-48 bg-slate-800 border border-[var(--color-border)] rounded-md shadow-lg z-50">
                                    <div class="py-1">
                                        <button id="resetToDefaultSizesBtn" class="w-full text-left px-4 py-2 text-sm text-white hover:bg-slate-700 transition-colors">
                                            Reset to Default Sizes
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div id="deckGridContainer" class="flex-grow flex gap-4 mt-2 min-h-[50vh]">
                            <div id="mainDeckSection" class="bg-black/20 p-3 rounded-lg overflow-y-auto" style="min-width: 300px; flex-grow: 1; flex-shrink: 1;">
                                <h3 class="font-semibold text-center mb-2">Main Deck</h3>
                                <div id="mainDeckList" class="deck-grid"></div>
                            </div>
                            <div id="mainSideResizeHandle" class="w-2 bg-slate-600 hover:bg-slate-500 cursor-col-resize flex-shrink-0 transition-colors" title="Drag to resize main and side deck"></div>
                            <div id="sideDeckSection" class="bg-black/20 p-3 rounded-lg overflow-y-auto" style="width: 280px; min-width: 200px; flex-grow: 0; flex-shrink: 1;">
                                <h3 class="font-semibold text-center mb-2">Side Deck</h3>
                                <div id="sideDeckList" class="side-deck-grid"></div>
                            </div>
                            <div id="sideExtraResizeHandle" class="w-2 bg-slate-600 hover:bg-slate-500 cursor-col-resize flex-shrink-0 transition-colors" title="Drag to resize side and extra deck"></div>
                            <div id="extraDeckSection" class="bg-black/20 p-3 rounded-lg overflow-y-auto" style="width: 280px; min-width: 200px; flex-grow: 0; flex-shrink: 1;">
                                <h3 class="font-semibold text-center mb-2">Extra Deck</h3>
                                <div id="extraDeckList" class="side-deck-grid"></div>
                            </div>
                        </div>
                        <div class="mt-4 grid md:grid-cols-2 gap-4">
                            <div class="bg-[var(--color-surface-1)] p-3 rounded-lg"><label for="deckNameInput" class="block text-sm font-medium mb-1">Deck Name</label><div class="flex gap-2"><input type="text" id="deckNameInput" class="flex-grow bg-slate-700 border border-[var(--color-border)] rounded-md px-3 py-2 focus:ring-2 focus:ring-[var(--color-primary)] focus:outline-none" placeholder="My Awesome Deck"><button id="saveDeckBtn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-3 rounded-md">Save</button></div></div>
                            <div class="bg-[var(--color-surface-1)] p-3 rounded-lg"><label for="deckSelector" class="block text-sm font-medium mb-1">Saved Decks</label><div class="flex gap-2"><select id="deckSelector" class="flex-grow bg-slate-700 border border-[var(--color-border)] rounded-md px-3 py-2 focus:ring-2 focus:ring-[var(--color-primary)] focus:outline-none"></select><button id="loadDeckBtn" class="bg-[var(--color-primary)] hover:bg-[var(--color-primary-hover)] text-white font-bold py-2 px-3 rounded-md">Load</button><button id="deleteDeckBtn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-3 rounded-md">Del</button></div></div>
                            <div class="bg-[var(--color-surface-1)] p-3 rounded-lg md:col-span-2">
                                <label class="block text-sm font-medium mb-1">Import / Export</label>
                                <div class="grid grid-cols-2 sm:grid-cols-4 gap-2">
                                    <button id="exportDeckBtn" class="w-full bg-slate-600 hover:bg-slate-700 font-bold py-2 px-3 rounded-md" title="Export the current decklist to a .ydk file compatible with many simulators.">Export .YDK</button>
                                    <button id="exportDeckYDKXBtn" class="w-full bg-slate-600 hover:bg-slate-700 font-bold py-2 px-3 rounded-md" title="Export the current decklist to a .ydkx file with card pool and configurations.">Export .YDKX</button>
                                    <button id="exportDeckClipboardBtn" class="w-full bg-slate-600 hover:bg-slate-700 font-bold py-2 px-3 rounded-md" title="Copy the current decklist to the clipboard in YDKe format.">Copy YDKe</button>
                                    <button id="importDeckClipboardBtn" class="w-full bg-slate-600 hover:bg-slate-700 font-bold py-2 px-3 rounded-md" title="Import a decklist by pasting YDKe code from the clipboard.">Paste YDKe</button>
                                    <label for="importDeckInput" class="w-full bg-slate-600 hover:bg-slate-700 font-bold py-2 px-3 rounded-md cursor-pointer text-center" title="Import a decklist from a .ydk file.">Import .YDK</label>
                                    <input type="file" id="importDeckInput" class="hidden" accept=".ydk,.ydkx">
                                </div>
                            </div>
                            <div class="bg-[var(--color-surface-1)] p-3 rounded-lg md:col-span-2">
                                <label class="block text-sm font-medium mb-1">YDK File Management</label>
                                <div class="space-y-3">
                                    <div class="flex gap-2 flex-wrap">
                                        <button id="ydkFolderBtn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-3 rounded-md" title="Import all YDK files from a folder">Import YDK Folder</button>
                                        <label for="ydkFileInput" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-3 rounded-md cursor-pointer" title="Import a single YDK file">Import YDK File</label>
                                        <input type="file" id="ydkFileInput" class="hidden" accept=".ydk,.ydkx">
                                        <button id="syncFolderBtn" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-3 rounded-md hidden" title="Re-import from previously selected folder">Sync Folder</button>
                                        <button id="manageFilesBtn" class="bg-orange-600 hover:bg-orange-700 text-white font-bold py-2 px-3 rounded-md" title="Manage stored YDK files">Manage Files</button>
                                    </div>
                                    <div id="ydkFolderStatus" class="text-gray-400 text-sm">No YDK files stored</div>
                                    <div class="text-xs text-gray-500">
                                         Tip: Import your .ydk files once and they'll be stored for instant access
                                    </div>
                                    <div class="flex gap-2">
                                        <select id="ydkDeckSelector" class="flex-grow bg-slate-700 border border-[var(--color-border)] rounded-md px-3 py-2 focus:ring-2 focus:ring-[var(--color-primary)] focus:outline-none" disabled>
                                            <option value="">Import YDK files first</option>
                                        </select>
                                        <button id="setDefaultDeckBtn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-3 rounded-md" title="Set the selected deck as default for auto-loading" disabled>Set Default</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="simulationView" class="hidden">
                <div id="simulationSetup" class="max-w-2xl mx-auto bg-[var(--color-surface-1)] p-6 rounded-lg">
                    <h2 class="text-2xl font-bold mb-4">Simulation Setup</h2>
                    <div class="space-y-4">
                        <div><label for="simDeckSelector" class="block text-sm font-medium mb-1">1. Select Deck</label><select id="simDeckSelector" class="w-full bg-slate-700 border border-[var(--color-border)] rounded-md px-3 py-2 focus:ring-2 focus:ring-[var(--color-primary)] focus:outline-none"></select></div>
                        <label for="simPostSideModeToggle" class="flex items-center justify-between bg-slate-900/50 p-3 rounded-md cursor-pointer"><span class="font-medium text-white">Enable Post-side Mode?</span><div class="relative inline-flex items-center"><input type="checkbox" id="simPostSideModeToggle" class="sr-only peer"><div class="w-11 h-6 bg-slate-600 rounded-full peer peer-focus:ring-4 peer-focus:ring-blue-800 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-slate-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div></div></label>
                        <div id="postSideOptions" class="hidden space-y-4 bg-slate-900/30 p-4 rounded-lg border border-slate-700">
                            <div class="grid grid-cols-2 gap-2">
                                <label class="p-2 bg-slate-700 rounded-md text-center text-sm cursor-pointer has-[:checked]:bg-blue-600 has-[:checked]:ring-2 ring-blue-300"><input type="radio" name="siding-method" value="pattern" class="sr-only" checked>Use Saved Pattern</label>
                                <label class="p-2 bg-slate-700 rounded-md text-center text-sm cursor-pointer has-[:checked]:bg-blue-600 has-[:checked]:ring-2 ring-blue-300"><input type="radio" name="siding-method" value="manual" class="sr-only">Manual Siding</label>
                            </div>
                            <div id="siding-pattern-options">
                                <label for="simSidingPatternSelector" class="block text-sm font-medium mb-1">Siding Pattern</label>
                                <select id="simSidingPatternSelector" class="w-full bg-slate-700 border border-[var(--color-border)] rounded-md px-3 py-2 focus:ring-2 focus:ring-[var(--color-primary)] focus:outline-none"></select>
                            </div>
                            <div><label for="simModeSelector" class="block text-sm font-medium mb-1">Simulation Mode</label><select id="simModeSelector" class="w-full bg-slate-700 border border-[var(--color-border)] rounded-md px-3 py-2 focus:ring-2 focus:ring-[var(--color-primary)] focus:outline-none"><option value="standard">Compare Specific Cards</option><option value="analyze">Analyze Siding Impact</option></select></div>
                        </div>
                        <div id="standardSimOptions" class="space-y-4">
                            <div><label for="simTargetCardSelector" class="block text-sm font-medium mb-1">Card to Replace</label><select id="simTargetCardSelector" class="w-full bg-slate-700 border border-[var(--color-border)] rounded-md px-3 py-2 focus:ring-2 focus:ring-[var(--color-primary)] focus:outline-none"></select></div>
                            <div>
                                <label for="simCompareCardSelector" class="block text-sm font-medium mb-1">Card to Compare With</label>
                                <select id="simCompareCardSelector" class="w-full bg-slate-700 border border-[var(--color-border)] rounded-md px-3 py-2 focus:ring-2 focus:ring-[var(--color-primary)] focus:outline-none"></select>
                            </div>
                            <div><label for="simReplacementCount" class="block text-sm font-medium mb-1">Copies to Replace</label><select id="simReplacementCount" class="w-full bg-slate-700 border border-[var(--color-border)] rounded-md px-3 py-2 focus:ring-2 focus:ring-[var(--color-primary)] focus:outline-none"></select></div>
                        </div>
                        <div><label for="simTrialsInput" class="block text-sm font-medium mb-1">Number of Trials</label><input type="number" id="simTrialsInput" value="20" min="1" max="1000" class="w-full bg-slate-700 border border-[var(--color-border)] rounded-md px-3 py-2 focus:ring-2 focus:ring-[var(--color-primary)] focus:outline-none"></div>
                        <button id="startSimBtn" class="w-full bg-[var(--color-primary)] hover:bg-[var(--color-primary-hover)] text-white font-bold py-3 text-lg rounded-lg transition-colors">Start Simulation</button>
                    </div>
                </div>
                <div id="simulationDisplay" class="hidden">
                    <div class="text-center mb-4">
                        <p class="text-lg font-semibold">Which hand is better?</p>
                        <p class="text-[var(--color-text-muted)]">Use <kbd class="font-sans text-blue-300">&larr;</kbd> A, <kbd class="font-sans text-blue-300">&rarr;</kbd> B, <kbd class="font-sans text-blue-300">&darr;</kbd> Tie, <kbd class="font-sans text-blue-300">&uarr;</kbd> Undo. Press <kbd class="font-sans text-blue-300">Delete</kbd> to end.</p>
                        <div class="inline-flex items-center mt-2">
                             <button id="toggleNotesBtn" class="text-xs bg-slate-600 hover:bg-slate-700 font-semibold px-3 py-1 rounded-md">Toggle Notes</button>
                            <div class="relative inline-block ml-2 group">
                                <span class="cursor-help text-xs bg-slate-500 rounded-full w-4 h-4 inline-flex items-center justify-center">?</span>
                                <div class="absolute bottom-full mb-2 w-48 bg-slate-800 text-white text-xs rounded-lg py-2 px-3 opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none">
                                    Click on any card in a hand to add its name to your notes.
                                </div>
                            </div>
                        </div>
                        <div id="trialCounter" class="mt-2 text-xl font-bold text-white"></div>
                    </div>
                    <div id="notesSection" class="hidden max-w-3xl mx-auto mb-4">
                        <label for="trialNotes" class="block text-sm font-medium mb-1">Trial Notes</label>
                        <textarea id="trialNotes" class="w-full bg-slate-900/50 border border-[var(--color-border)] rounded-md p-2 h-24" placeholder="Notes on this trial..."></textarea>
                        <button id="deleteDraft" class="text-xs bg-red-700 hover:bg-red-800 font-semibold px-3 py-1 rounded-md mt-1">Delete Draft</button>
                    </div>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6 items-start">
                        <div class="bg-[var(--color-surface-1)]/50 p-4 rounded-lg"><h3 class="text-xl font-semibold mb-3 text-center">Deck A</h3><div id="handAContainer" class="card-grid mb-4"></div><details class="bg-[var(--color-surface-3)]/50 rounded"><summary class="cursor-pointer p-2 font-medium text-center">Show/Hide Deck State</summary><div class="p-2 border-t border-[var(--color-border)]"><h4 class="font-semibold mb-2">Next 4 Cards:</h4><div id="nextCardsA" class="card-grid mb-4"></div><h4 class="font-semibold mb-2">Rest of Deck:</h4><div id="fullDeckA" class="card-grid max-h-48 overflow-y-auto"></div></div></details></div>
                        <div class="bg-[var(--color-surface-1)]/50 p-4 rounded-lg"><h3 class="text-xl font-semibold mb-3 text-center">Deck B</h3><div id="handBContainer" class="card-grid mb-4"></div><details class="bg-[var(--color-surface-3)]/50 rounded"><summary class="cursor-pointer p-2 font-medium text-center">Show/Hide Deck State</summary><div class="p-2 border-t border-[var(--color-border)]"><h4 class="font-semibold mb-2">Next 4 Cards:</h4><div id="nextCardsB" class="card-grid mb-4"></div><h4 class="font-semibold mb-2">Rest of Deck:</h4><div id="fullDeckB" class="card-grid max-h-48 overflow-y-auto"></div></div></details></div>
                    </div>
                </div>
            </div>

            <div id="aiTrainingView" class="hidden">
                 <div class="max-w-2xl mx-auto bg-[var(--color-surface-1)] p-6 rounded-lg">
                    <h2 class="text-2xl font-bold mb-4">AI Training Mode</h2>
                    <div class="space-y-4">
                        <div>
                            <label for="importAiEvaluatorInput" class="block text-sm font-medium mb-1">1. Import AI Evaluator (.json)</label>
                            <input type="file" id="importAiEvaluatorInput" class="w-full text-sm text-slate-400 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100" accept=".json" title="Import a previously generated AI evaluator file.">
                        </div>
                         <div><label for="aiTrainingDeckSelector" class="block text-sm font-medium mb-1">2. Select Deck to Train On</label><select id="aiTrainingDeckSelector" class="w-full bg-slate-700 border border-[var(--color-border)] rounded-md px-3 py-2 focus:ring-2 focus:ring-[var(--color-primary)] focus:outline-none"></select></div>
                        <div>
                            <label for="aiTrainingTrialsInput" class="block text-sm font-medium mb-1">3. Number of Trials to Run</label>
                            <input type="number" id="aiTrainingTrialsInput" value="50" min="1" max="1000" class="w-full bg-slate-700 border border-[var(--color-border)] rounded-md px-3 py-2">
                        </div>
                        <div>
                            <label for="aiTrainingInstructions" class="block text-sm font-medium mb-1">4. User Instructions (Optional)</label>
                            <textarea id="aiTrainingInstructions" class="w-full bg-slate-700 border border-[var(--color-border)] rounded-md p-2 h-24" placeholder="e.g., Prioritize a strong Turn 1 board."></textarea>
                        </div>
                        <button id="startAiTrainingBtn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 text-lg rounded-lg transition-colors">Start AI Simulation</button>
                    </div>
                </div>
                <div id="aiTrainingResultsView" class="hidden mt-6"></div>
            </div>
            
            <div id="reportView" class="hidden">
                 <div class="max-w-4xl mx-auto bg-[var(--color-surface-1)] p-6 rounded-lg">
                    <div id="reportContent"></div>
                    <div class="mt-6 space-y-4">
                        <div class="flex flex-col md:flex-row gap-4">
                             <button id="aiReportAnalysisBtn" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg hidden" title="Get a detailed analysis of the simulation results from Gemini."> Get AI Analysis</button>
                             <button id="generateAiEvaluatorBtn" class="flex-1 bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg hidden" title="Create a downloadable AI algorithm based on your evaluations and notes."> Generate AI Evaluator</button>
                             <button id="generatePromptBtn" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg hidden" title="Generate a prompt you can copy to any AI model for analysis."> Generate AI Prompt</button>
                             <button id="generateAiEvaluatorPromptBtn" class="flex-1 bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg hidden" title="Generate a prompt for creating an AI evaluator algorithm."> Generate Evaluator Prompt</button>
                        </div>
                        <div id="aiReportAnalysisContent" class="p-4 bg-slate-800 rounded-lg whitespace-pre-wrap"></div>
                        <div id="rerunSection" class="hidden border-t border-slate-700 pt-4 text-center">
                             <h4 class="font-semibold mb-2">Run More Trials</h4>
                             <div class="flex justify-center items-center gap-2">
                                 <input type="number" id="rerunTrialsInput" value="20" min="1" max="1000" class="w-24 bg-slate-700 border border-[var(--color-border)] rounded-md px-3 py-2 focus:ring-2 focus:ring-[var(--color-primary)] focus:outline-none">
                                <button id="rerunSimBtn" class="bg-[var(--color-primary)] hover:bg-[var(--color-primary-hover)] text-white font-bold py-2 px-4 rounded-lg" title="Run another simulation with the same settings.">Start Another Simulation</button>
                             </div>
                        </div>
                    </div>
                    <button id="exportReportBtn" class="mt-6 w-full bg-slate-600 hover:bg-slate-700 text-white font-bold py-2 px-4 rounded-lg">Export Report as .txt</button>
                 </div>
            </div>
            
            <!-- NEW: SHOOTOUT MODE VIEWS -->
            <div id="shootoutView" class="hidden">
                <div class="max-w-2xl mx-auto bg-[var(--color-surface-1)] p-6 rounded-lg">
                    <h2 class="text-2xl font-bold mb-4">Shootout Mode Setup</h2>
                    <div class="space-y-4">
                        <div><label for="shootoutUserDeckSelector" class="block text-sm font-medium mb-1">1. Select Your Deck</label><select id="shootoutUserDeckSelector" class="w-full bg-slate-700 border border-[var(--color-border)] rounded-md px-3 py-2"></select></div>
                        <div><label for="shootoutOpponentDeckInput" class="block text-sm font-medium mb-1">2. Load Opponent's Deck (.ydk/.ydkx)</label><input type="file" id="shootoutOpponentDeckInput" class="w-full text-sm text-slate-400 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100" accept=".ydk,.ydkx"><p id="shootoutOpponentDeckName" class="text-xs mt-1 text-red-400">No opponent deck loaded.</p></div>
                        <div>
                            <h3 class="block text-sm font-medium mb-2">3. Choose Scenario</h3>
                            <div class="grid grid-cols-2 gap-2">
                                <label class="p-3 bg-slate-700 rounded-md text-center cursor-pointer has-[:checked]:bg-blue-600 has-[:checked]:ring-2 ring-blue-300"><input type="radio" name="shootout-mode" value="g1-first" class="sr-only" checked>Game 1, Going First</label>
                                <label class="p-3 bg-slate-700 rounded-md text-center cursor-pointer has-[:checked]:bg-blue-600 has-[:checked]:ring-2 ring-blue-300"><input type="radio" name="shootout-mode" value="g1-second" class="sr-only">Game 1, Going Second</label>
                                <label class="p-3 bg-slate-700 rounded-md text-center cursor-pointer has-[:checked]:bg-blue-600 has-[:checked]:ring-2 ring-blue-300"><input type="radio" name="shootout-mode" value="post-side-first" class="sr-only">Post-Side, Going First</label>
                                <label class="p-3 bg-slate-700 rounded-md text-center cursor-pointer has-[:checked]:bg-blue-600 has-[:checked]:ring-2 ring-blue-300"><input type="radio" name="shootout-mode" value="post-side-second" class="sr-only">Post-Side, Going Second</label>
                            </div>
                        </div>
                        <div><label for="shootoutTrialsInput" class="block text-sm font-medium mb-1">4. Number of Trials</label><input type="number" id="shootoutTrialsInput" value="10" min="1" max="1000" class="w-full bg-slate-700 border border-[var(--color-border)] rounded-md px-3 py-2"></div>
                        <button id="startShootoutBtn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 text-lg rounded-lg transition-colors">Start Shootout</button>
                    </div>
                </div>
            </div>

            <div id="shootoutSidingView" class="hidden">
                 <div class="bg-[var(--color-surface-1)] p-6 rounded-lg">
                    <h2 id="shootoutSidingViewTitle" class="text-2xl font-bold mb-4 text-center">Siding Phase</h2>
                    <p class="text-center text-sm text-slate-400 mb-4">Left-click to select a copy. Right-click to deselect all copies of a card.</p>
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                        <div class="bg-slate-900/50 p-4 rounded-lg">
                            <h3 class="text-xl font-semibold mb-2 text-center">Your Deck</h3>
                            <p id="shootoutSidingUserInfo" class="text-center text-amber-400 text-sm mb-2">Siding Out: 0 | Siding In: 0</p>
                            <h4 class="font-semibold text-slate-300">Main Deck (Click to side out)</h4>
                            <div id="shootoutSidingUserMain" class="deck-grid bg-black/20 p-2 rounded-md min-h-[150px] mb-2"></div>
                            <h4 class="font-semibold text-slate-300">Side Deck (Click to side in)</h4>
                            <div id="shootoutSidingUserSide" class="deck-grid bg-black/20 p-2 rounded-md min-h-[80px]"></div>
                        </div>
                        <div class="bg-slate-900/50 p-4 rounded-lg">
                            <h3 class="text-xl font-semibold mb-2 text-center">Opponent's Deck</h3>
                             <p id="shootoutSidingOpponentInfo" class="text-center text-amber-400 text-sm mb-2">Siding Out: 0 | Siding In: 0</p>
                            <h4 class="font-semibold text-slate-300">Main Deck (Click to side out)</h4>
                            <div id="shootoutSidingOpponentMain" class="deck-grid bg-black/20 p-2 rounded-md min-h-[150px] mb-2"></div>
                            <h4 class="font-semibold text-slate-300">Side Deck (Click to side in)</h4>
                            <div id="shootoutSidingOpponentSide" class="deck-grid bg-black/20 p-2 rounded-md min-h-[80px]"></div>
                        </div>
                    </div>
                    <button id="shootoutFinalizeSidingBtn" class="w-full max-w-md mx-auto mt-6 block bg-green-600 hover:bg-green-700 text-white font-bold py-3 text-lg rounded-lg transition-colors">Done Siding</button>
                 </div>
            </div>

            <div id="shootoutSimulatorView" class="hidden">
                 <h2 class="text-2xl font-bold mb-4 text-center">Shootout Simulator</h2>
                 <div class="text-center mb-2">
                    <span id="shootoutSimScenarioIndicator" class="px-3 py-1 text-xs font-semibold tracking-wider text-blue-100 bg-blue-800/50 rounded-full"></span>
                 </div>
                 <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 items-start mt-4">
                    <!-- User Side -->
                    <div class="bg-[var(--color-surface-1)]/50 p-4 rounded-lg">
                        <div class="flex justify-between items-center mb-3">
                             <h3 class="text-xl font-semibold text-center">Your Hand</h3>
                             <p id="shootoutSimUserDeckCount" class="text-sm font-mono"></p>
                        </div>
                        <div id="shootoutSimUserHand" class="card-grid mb-4"></div>
                        <div id="shootoutSimUserControls" class="p-2 bg-slate-900/30 rounded-md">
                            <h4 class="text-sm font-semibold mb-2">Actions</h4>
                            <div class="flex flex-wrap gap-2">
                                <button id="drawShootoutCardBtn" class="text-xs bg-blue-600 hover:bg-blue-700 px-3 py-1 rounded-md">Draw Card</button>
                                <button id="searchDeckBtn" class="text-xs bg-blue-600 hover:bg-blue-700 px-3 py-1 rounded-md">Search Deck</button>
                            </div>
                        </div>
                        <details class="bg-[var(--color-surface-3)]/50 rounded mt-4">
                            <summary class="cursor-pointer p-2 font-medium text-center">Show/Hide Deck State</summary>
                            <div class="p-2 border-t border-[var(--color-border)]">
                                <h4 class="font-semibold mb-2">Rest of Deck:</h4>
                                <div id="userFullDeck" class="card-grid max-h-48 overflow-y-auto"></div>
                            </div>
                        </details>
                        <!-- Drop Zones for Drag-and-Drop -->
                        <div class="mt-4 space-y-2">
                            <div data-drop-action="top" class="shootout-drop-zone p-3 border-2 border-dashed border-slate-600 rounded-lg text-center text-xs text-slate-400 transition-colors">Move to Top</div>
                            <div data-drop-action="shuffle" class="shootout-drop-zone p-3 border-2 border-dashed border-slate-600 rounded-lg text-center text-xs text-slate-400 transition-colors">Shuffle In</div>
                            <div data-drop-action="bottom" class="shootout-drop-zone p-3 border-2 border-dashed border-slate-600 rounded-lg text-center text-xs text-slate-400 transition-colors">Move to Bottom</div>
                        </div>
                    </div>
                     <!-- Opponent Side -->
                    <div class="bg-[var(--color-surface-1)]/50 p-4 rounded-lg">
                         <div class="flex justify-between items-center mb-3">
                             <h3 class="text-xl font-semibold text-center">Opponent's Hand</h3>
                             <p id="shootoutSimOpponentDeckCount" class="text-sm font-mono"></p>
                         </div>
                        <div id="shootoutSimOpponentHand" class="card-grid mb-4"></div>
                        <div id="shootoutSimOpponentControls" class="p-2 bg-slate-900/30 rounded-md">
                            <h4 class="text-sm font-semibold mb-2">Actions</h4>
                            <div class="flex flex-wrap gap-2">
                                <button id="drawOpponentCardBtn" class="text-xs bg-blue-600 hover:bg-blue-700 px-3 py-1 rounded-md">Draw Card</button>
                                <button id="searchOpponentDeckBtn" class="text-xs bg-blue-600 hover:bg-blue-700 px-3 py-1 rounded-md">Search Deck</button>
                            </div>
                        </div>
                        <details class="bg-[var(--color-surface-3)]/50 rounded mt-4">
                            <summary class="cursor-pointer p-2 font-medium text-center">Show/Hide Deck State</summary>
                            <div class="p-2 border-t border-[var(--color-border)]">
                                <h4 class="font-semibold mb-2">Rest of Deck:</h4>
                                <div id="opponentFullDeck" class="card-grid max-h-48 overflow-y-auto"></div>
                            </div>
                        </details>
                        <!-- Drop Zones for Drag-and-Drop -->
                        <div class="mt-4 space-y-2">
                            <div data-drop-action="top" class="shootout-drop-zone p-3 border-2 border-dashed border-slate-600 rounded-lg text-center text-xs text-slate-400 transition-colors">Move to Top</div>
                            <div data-drop-action="shuffle" class="shootout-drop-zone p-3 border-2 border-dashed border-slate-600 rounded-lg text-center text-xs text-slate-400 transition-colors">Shuffle In</div>
                            <div data-drop-action="bottom" class="shootout-drop-zone p-3 border-2 border-dashed border-slate-600 rounded-lg text-center text-xs text-slate-400 transition-colors">Move to Bottom</div>
                        </div>
                    </div>
                 </div>
                 <!-- Judgement Section -->
                 <div class="max-w-3xl mx-auto mt-6 bg-slate-800 p-4 rounded-lg">
                    <h3 class="text-lg font-semibold text-center mb-2">Record Judgment</h3>
                    <div class="text-center mb-3">
                        <p class="text-[var(--color-text-muted)] text-sm">Use <kbd class="font-sans text-blue-300">&larr;</kbd> I Win, <kbd class="font-sans text-blue-300">&rarr;</kbd> Opponent Wins, <kbd class="font-sans text-blue-300">&darr;</kbd> Tie, <kbd class="font-sans text-blue-300">&uarr;</kbd> Undo</p>
                    </div>
                     <textarea id="shootoutNotes" class="w-full bg-slate-900/50 border border-[var(--color-border)] rounded-md p-2 h-24 mb-3" placeholder="Notes on this matchup..."></textarea>
                     <div class="grid grid-cols-3 gap-4">
                        <button id="shootoutJdgUserWinBtn" class="w-full bg-green-600 hover:bg-green-700 font-bold py-3 rounded-lg">I Win</button>
                        <button id="shootoutJdgTieBtn" class="w-full bg-yellow-600 hover:bg-yellow-700 font-bold py-3 rounded-lg">Tie</button>
                        <button id="shootoutJdgOpponentWinBtn" class="w-full bg-red-600 hover:bg-red-700 font-bold py-3 rounded-lg">Opponent Wins</button>
                        <button id="shootoutUndoBtn" class="col-span-3 w-full bg-slate-600 hover:bg-slate-700 font-bold py-2 rounded-lg text-sm">Undo Last Judgment</button>
                     </div>
                 </div>
            </div>

            <div id="shootoutReportView" class="hidden">
                 <div class="max-w-3xl mx-auto bg-[var(--color-surface-1)] p-6 rounded-lg">
                    <div id="shootoutReportContent" class="text-center"></div>
                    <div id="aiAnalysisResult" class="mt-4 p-4 bg-slate-800 rounded-lg text-left prose prose-invert max-w-none prose-h3:text-blue-300 prose-strong:text-white"></div>
                    <div class="mt-6 border-t border-slate-700 pt-6 space-y-3 text-center">
                        <button id="shootoutReportAnalyzeBtn" class="w-full bg-blue-600 hover:bg-blue-700 font-bold py-2 px-4 rounded-lg">Analyze Hand Data (PDF)</button>
                        <button id="shootoutReportExportBtn" class="w-full bg-blue-600 hover:bg-blue-700 font-bold py-2 px-4 rounded-lg">Export Hands & Notes (PDF)</button>
                        <button id="shootoutReportAiBtn" class="w-full bg-purple-600 hover:bg-purple-700 font-bold py-2 px-4 rounded-lg"> Get AI Analysis of Session</button>
                        <button id="shootoutGeneratePromptBtn" class="w-full bg-purple-600 hover:bg-purple-700 font-bold py-2 px-4 rounded-lg hidden"> Generate AI Analysis Prompt</button>
                        <div id="continueShootoutContainer" class="w-full"><button id="shootoutReportContinueBtn" class="w-full bg-slate-600 hover:bg-slate-700 font-bold py-2 px-4 rounded-lg">Continue More Trials</button><div id="continueShootoutForm" class="hidden flex justify-center items-center gap-2 mt-3"><input type="number" id="additionalTrialsInput" value="10" class="w-24 bg-slate-700 border border-[var(--color-border)] rounded-md px-3 py-2 text-center"><button id="confirmContinueBtn" class="bg-green-600 hover:bg-green-700 font-bold py-2 px-4 rounded-lg">Confirm</button></div></div>
                    </div>
                 </div>
            </div>

        </main>

        <!-- Prompt Generation Modal -->
        <div id="promptModal" class="hidden fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/70">
            <div class="bg-[var(--color-surface-1)] rounded-lg shadow-2xl max-w-4xl w-full max-h-[90vh] flex flex-col">
                <div class="flex justify-between items-center p-4 border-b border-[var(--color-border)]">
                    <h3 class="text-xl font-bold text-white">AI Analysis Prompt</h3>
                    <button id="promptModalClose" class="text-slate-400 hover:text-white text-2xl leading-none">&times;</button>
                </div>
                <div class="p-4 flex-grow overflow-hidden flex flex-col">
                    <p class="text-sm text-slate-300 mb-3">Copy this prompt and paste it into your preferred AI model (ChatGPT, Claude, Gemini, etc.) for analysis:</p>
                    <textarea id="promptModalTextarea" readonly class="flex-grow w-full bg-slate-900 border border-[var(--color-border)] rounded-md p-3 font-mono text-sm text-slate-200 resize-none" style="min-height: 400px;"></textarea>
                </div>
                <div class="flex gap-3 p-4 border-t border-[var(--color-border)]">
                    <button id="copyPromptBtn" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                         Copy to Clipboard
                    </button>
                    <button id="downloadPromptBtn" class="flex-1 bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                         Download as .txt
                    </button>
                </div>
            </div>
        </div>
        
        <div id="color-customizer" class="fixed bottom-0 right-0 mb-4 mr-4 text-sm z-50">
            <div class="flex flex-col items-end gap-2">
                <button id="toggle-customizer-btn" class="bg-[var(--color-surface-1)] hover:bg-slate-600 text-white font-bold p-2 rounded-full shadow-lg w-10 h-10 flex items-center justify-center"></button>
            </div>
            <div id="customizer-panel" class="hidden absolute bottom-14 right-0 bg-[var(--color-surface-1)] p-4 rounded-lg shadow-2xl w-64 space-y-2">
                <h4 class="font-bold text-center">Theme Customizer</h4>
                <div class="flex justify-between items-center">
                    <label for="color-bg">Background</label>
                    <input type="color" id="color-bg" data-var="--color-bg" class="p-1 h-8 w-14 block bg-slate-700 border border-[var(--color-border)] cursor-pointer rounded-lg">
                </div>
                <div class="flex justify-between items-center">
                    <label for="color-surface-1">Panels</label>
                    <input type="color" id="color-surface-1" data-var="--color-surface-1" class="p-1 h-8 w-14 block bg-slate-700 border border-[var(--color-border)] cursor-pointer rounded-lg">
                </div>
                <div class="flex justify-between items-center">
                    <label for="color-primary">Primary</label>
                    <input type="color" id="color-primary" data-var="--color-primary" class="p-1 h-8 w-14 block bg-slate-700 border border-[var(--color-border)] cursor-pointer rounded-lg">
                </div>
                <div class="flex justify-between items-center">
                    <label for="color-text-base">Text</label>
                    <input type="color" id="color-text-base" data-var="--color-text-base" class="p-1 h-8 w-14 block bg-slate-700 border border-[var(--color-border)] cursor-pointer rounded-lg">
                </div>
                <div class="flex justify-between items-center">
                    <label for="color-border">Borders</label>
                    <input type="color" id="color-border" data-var="--color-border" class="p-1 h-8 w-14 block bg-slate-700 border border-[var(--color-border)] cursor-pointer rounded-lg">
                </div>
                <button id="reset-theme-btn" class="w-full mt-2 bg-red-600 hover:bg-red-700 text-white font-bold py-1 px-2 rounded-md">Reset Theme</button>
            </div>
        </div>
    </div>
</body>
</html>